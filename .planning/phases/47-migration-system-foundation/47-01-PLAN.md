---
phase: 47-migration-system-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/functions/migration-runner.R
  - db/migrations/002_add_genomic_annotations.sql
autonomous: true

must_haves:
  truths:
    - "Developer can run migration runner and see which migrations were applied"
    - "Running migration runner twice produces identical database state"
    - "schema_version table shows timestamp and filename for each applied migration"
    - "Migration 002 can be re-run without error on database where it already ran"
  artifacts:
    - path: "api/functions/migration-runner.R"
      provides: "Migration execution and tracking logic"
      exports: ["run_migrations", "ensure_schema_version_table", "get_applied_migrations"]
      min_lines: 100
    - path: "db/migrations/002_add_genomic_annotations.sql"
      provides: "Idempotent genomic annotations migration"
      contains: "CREATE PROCEDURE IF NOT EXISTS"
  key_links:
    - from: "api/functions/migration-runner.R"
      to: "DBI::dbExecute"
      via: "immediate = TRUE for multi-statement execution"
      pattern: "dbExecute.*immediate\\s*=\\s*TRUE"
    - from: "api/functions/migration-runner.R"
      to: "schema_version table"
      via: "SQL INSERT for tracking"
      pattern: "INSERT INTO schema_version"
---

<objective>
Create the migration runner infrastructure and fix Migration 002 for idempotency.

Purpose: Establish reliable database migration execution with state tracking, enabling safe re-runs and sequential application of schema changes.

Output: Working migration-runner.R that can execute all existing migrations, plus idempotent Migration 002 that can be safely re-run.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/47-migration-system-foundation/47-CONTEXT.md
@.planning/phases/47-migration-system-foundation/47-RESEARCH.md

@api/functions/db-helpers.R
@api/start_sysndd_api.R
@db/migrations/001_add_about_content.sql
@db/migrations/002_add_genomic_annotations.sql
@db/migrations/003_fix_hgnc_column_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration-runner.R with core functions</name>
  <files>api/functions/migration-runner.R</files>
  <action>
Create `api/functions/migration-runner.R` with the following functions:

1. **ensure_schema_version_table(conn)** - Creates tracking table if not exists
   - SQL: CREATE TABLE IF NOT EXISTS schema_version (filename VARCHAR(255) PRIMARY KEY, applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, success BOOLEAN DEFAULT TRUE)
   - Use DBI::dbExecute with immediate = TRUE

2. **list_migration_files(migrations_dir)** - Lists SQL files sorted by numeric prefix
   - Default dir: "db/migrations"
   - Use fs::dir_ls() to list *.sql files
   - Sort by filename (001_, 002_, etc. naturally sort correctly)
   - Return vector of filenames (not full paths)

3. **get_applied_migrations(conn)** - Returns vector of already-applied filenames
   - Query: SELECT filename FROM schema_version WHERE success = TRUE ORDER BY filename
   - Use DBI::dbGetQuery()
   - Return character vector (empty if table empty)

4. **record_migration(filename, conn)** - Records successful migration
   - INSERT INTO schema_version (filename, success) VALUES (?, TRUE)
   - Use DBI::dbExecute with params list

5. **split_sql_statements(sql_content)** - Splits SQL file into executable statements
   - Detect DELIMITER commands (for stored procedures like in 003)
   - If DELIMITER found: extract custom delimiter, strip DELIMITER lines, split on custom delimiter
   - Otherwise: split on semicolon followed by newline
   - Filter out empty statements
   - Return character vector of statements

6. **execute_migration(filepath, migrations_dir, conn)** - Executes single migration
   - Read file content with readLines() + paste(collapse = "\n")
   - Split into statements using split_sql_statements()
   - Execute each non-empty statement with DBI::dbExecute(conn, stmt, immediate = TRUE)
   - On success: call record_migration()
   - On error: log_error() and stop() to halt further migrations
   - Use logger for INFO/ERROR output

7. **run_migrations(migrations_dir, conn, verbose)** - Main entry point
   - Default: migrations_dir = "db/migrations", conn = NULL (uses global pool), verbose = FALSE
   - Call ensure_schema_version_table()
   - Get migration files and applied list
   - Calculate pending = setdiff(migration_files, applied)
   - If no pending: log_info("No pending migrations")
   - For each pending migration in order: execute_migration()
   - Return list(total_applied = length(applied), newly_applied = length(pending_applied), filenames = pending_applied)
   - Summary log: "Applied N migrations (001, 002, ...)" at INFO level

Follow existing patterns from db-helpers.R:
- Use logger for logging (log_info, log_error, log_debug)
- Handle pool vs direct connection like db_execute_query does
- Document functions with roxygen2 comments

IMPORTANT: For connection handling, use pool::poolCheckout/poolReturn pattern when conn is NULL (using global pool). This matches db-helpers.R pattern.

MySQL DDL note: DDL statements (CREATE TABLE, ALTER TABLE) cause implicit commits and cannot be rolled back. Design assumes each migration is atomic at the statement level, not transactional.
  </action>
  <verify>
Run `Rscript -e "source('api/functions/migration-runner.R')"` - should load without errors.

Check function exports exist:
```bash
grep -E "^(run_migrations|ensure_schema_version_table|get_applied_migrations|execute_migration|split_sql_statements)" api/functions/migration-runner.R
```
  </verify>
  <done>
- migration-runner.R exists with all 7 functions
- File sources without syntax errors
- Functions follow db-helpers.R patterns (pool handling, logging, error handling)
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite Migration 002 for idempotency</name>
  <files>db/migrations/002_add_genomic_annotations.sql</files>
  <action>
Rewrite `db/migrations/002_add_genomic_annotations.sql` using the stored procedure pattern from Migration 003.

Current (non-idempotent):
```sql
ALTER TABLE non_alt_loci_set ADD COLUMN gnomad_constraints TEXT NULL;
ALTER TABLE non_alt_loci_set ADD COLUMN alphafold_id VARCHAR(100) NULL;
```

Replace with idempotent version:
```sql
-- Add pre-annotated genomic data columns to non_alt_loci_set
-- gnomAD constraint scores (JSON) and AlphaFold model identifier
--
-- gnomad_constraints: JSON blob from gnomAD v4 GraphQL API containing
--   pLI, LOEUF, o/e ratios, Z-scores, expected/observed counts
--   Populated during HGNC update process (batch enrichment)
--
-- alphafold_id: Pre-computed AlphaFold model identifier (AF-{uniprot_id}-F1)
--   Derived from first UniProt ID during HGNC update process
--   Used by Phase 45 (3D protein structure viewer)
--
-- Idempotent: Uses stored procedure to check column existence before ALTER

DELIMITER //

CREATE PROCEDURE IF NOT EXISTS migrate_002_genomic_annotations()
BEGIN
    -- Add gnomad_constraints column if not exists
    IF NOT EXISTS (
        SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS
        WHERE TABLE_SCHEMA = DATABASE()
          AND TABLE_NAME = 'non_alt_loci_set'
          AND COLUMN_NAME = 'gnomad_constraints'
    ) THEN
        ALTER TABLE non_alt_loci_set ADD COLUMN gnomad_constraints TEXT NULL;
    END IF;

    -- Add alphafold_id column if not exists
    IF NOT EXISTS (
        SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS
        WHERE TABLE_SCHEMA = DATABASE()
          AND TABLE_NAME = 'non_alt_loci_set'
          AND COLUMN_NAME = 'alphafold_id'
    ) THEN
        ALTER TABLE non_alt_loci_set ADD COLUMN alphafold_id VARCHAR(100) NULL;
    END IF;
END //

DELIMITER ;

CALL migrate_002_genomic_annotations();
DROP PROCEDURE IF EXISTS migrate_002_genomic_annotations;
```

Key changes:
1. Keep original header comments (purpose documentation)
2. Add idempotency note to header
3. Wrap ALTER statements in stored procedure with IF NOT EXISTS checks
4. Use DELIMITER // pattern (same as Migration 003)
5. Call procedure then drop it (cleanup)
  </action>
  <verify>
Check file uses stored procedure pattern:
```bash
grep -q "CREATE PROCEDURE IF NOT EXISTS" db/migrations/002_add_genomic_annotations.sql && echo "OK: Uses stored procedure pattern"
grep -q "INFORMATION_SCHEMA.COLUMNS" db/migrations/002_add_genomic_annotations.sql && echo "OK: Has column existence check"
grep -q "DROP PROCEDURE" db/migrations/002_add_genomic_annotations.sql && echo "OK: Cleans up procedure"
```
  </verify>
  <done>
- Migration 002 uses stored procedure pattern matching Migration 003
- Contains IF NOT EXISTS checks for both columns (gnomad_constraints, alphafold_id)
- Procedure is called then dropped for cleanup
  </done>
</task>

</tasks>

<verification>
Overall phase checks:

1. **Syntax validation:**
   ```bash
   Rscript -e "source('api/functions/migration-runner.R')"
   ```

2. **Function presence:**
   ```bash
   grep -c "^[a-z_]*\s*<-\s*function" api/functions/migration-runner.R
   # Should show 7 or more functions
   ```

3. **Migration 002 idempotency:**
   ```bash
   grep "CREATE PROCEDURE IF NOT EXISTS" db/migrations/002_add_genomic_annotations.sql
   grep "INFORMATION_SCHEMA.COLUMNS" db/migrations/002_add_genomic_annotations.sql
   ```

4. **Integration test (if database available):**
   Run migration runner twice - second run should report "No pending migrations" or "0 newly applied"
</verification>

<success_criteria>
1. api/functions/migration-runner.R exists with run_migrations(), ensure_schema_version_table(), get_applied_migrations(), execute_migration(), split_sql_statements(), list_migration_files(), record_migration() functions
2. migration-runner.R sources without errors
3. db/migrations/002_add_genomic_annotations.sql uses stored procedure pattern with INFORMATION_SCHEMA checks
4. Both tasks completed, code follows existing codebase patterns
</success_criteria>

<output>
After completion, create `.planning/phases/47-migration-system-foundation/47-01-SUMMARY.md`
</output>
