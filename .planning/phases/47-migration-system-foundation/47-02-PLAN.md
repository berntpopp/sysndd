---
phase: 47-migration-system-foundation
plan: 02
type: execute
wave: 2
depends_on: ["47-01"]
files_modified:
  - api/tests/testthat/test-unit-migration-runner.R
autonomous: true

must_haves:
  truths:
    - "Migration runner functions have unit test coverage"
    - "Tests verify idempotency (running twice produces same result)"
    - "Tests verify sequential execution order"
    - "Tests verify schema_version table tracking"
  artifacts:
    - path: "api/tests/testthat/test-unit-migration-runner.R"
      provides: "Unit tests for migration-runner.R"
      contains: "test_that"
      min_lines: 80
  key_links:
    - from: "api/tests/testthat/test-unit-migration-runner.R"
      to: "api/functions/migration-runner.R"
      via: "source() or testthat loading"
      pattern: "source.*migration-runner"
---

<objective>
Add unit tests for the migration runner to verify idempotency, sequential execution, and state tracking.

Purpose: Ensure the migration system works correctly and catches regressions when code changes.

Output: Comprehensive test file covering all migration runner functions and key behaviors.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/47-migration-system-foundation/47-01-SUMMARY.md

@api/functions/migration-runner.R
@api/tests/testthat/setup.R
@api/tests/testthat/helper-db.R
@api/tests/testthat/test-unit-file-functions.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unit tests for migration-runner.R</name>
  <files>api/tests/testthat/test-unit-migration-runner.R</files>
  <action>
Create `api/tests/testthat/test-unit-migration-runner.R` with comprehensive tests.

Follow existing test patterns from test-unit-file-functions.R and other test files.

**Test structure:**

```r
# test-unit-migration-runner.R
#
# Unit tests for migration runner functions.
# Tests SQL splitting, file listing, and core logic.
# Integration tests with real database are separate.

# Source the migration runner
source("functions/migration-runner.R", local = TRUE)

describe("split_sql_statements", {
  it("splits simple SQL on semicolon-newline", {
    sql <- "SELECT 1;\nSELECT 2;\n"
    result <- split_sql_statements(sql)
    expect_length(result, 2)
    expect_equal(trimws(result[1]), "SELECT 1")
    expect_equal(trimws(result[2]), "SELECT 2")
  })

  it("handles single statement without trailing newline", {
    sql <- "SELECT 1"
    result <- split_sql_statements(sql)
    expect_length(result, 1)
  })

  it("filters out empty statements", {
    sql <- "SELECT 1;\n\n;\nSELECT 2;\n"
    result <- split_sql_statements(sql)
    # Should only have 2 non-empty statements
    expect_true(all(nchar(trimws(result)) > 0))
  })

  it("handles DELIMITER for stored procedures", {
    sql <- "DELIMITER //\nCREATE PROCEDURE test() BEGIN SELECT 1; END //\nDELIMITER ;\nCALL test();\n"
    result <- split_sql_statements(sql)
    # Should split on // not ;
    expect_true(any(grepl("CREATE PROCEDURE", result)))
    expect_true(any(grepl("CALL test", result)))
  })

  it("preserves comments in SQL", {
    sql <- "-- Comment\nSELECT 1;\n"
    result <- split_sql_statements(sql)
    expect_true(grepl("-- Comment", result[1]))
  })
})

describe("list_migration_files", {
  it("returns sorted list of SQL files", {
    # Create temp directory with test migrations
    temp_dir <- tempdir()
    migrations_dir <- file.path(temp_dir, "test_migrations")
    dir.create(migrations_dir, showWarnings = FALSE)

    # Create test files (out of order to test sorting)
    writeLines("SELECT 1;", file.path(migrations_dir, "002_second.sql"))
    writeLines("SELECT 1;", file.path(migrations_dir, "001_first.sql"))
    writeLines("SELECT 1;", file.path(migrations_dir, "003_third.sql"))

    result <- list_migration_files(migrations_dir)

    expect_length(result, 3)
    expect_equal(result[1], "001_first.sql")
    expect_equal(result[2], "002_second.sql")
    expect_equal(result[3], "003_third.sql")

    # Cleanup
    unlink(migrations_dir, recursive = TRUE)
  })

  it("returns empty vector for empty directory", {
    temp_dir <- tempdir()
    empty_dir <- file.path(temp_dir, "empty_migrations")
    dir.create(empty_dir, showWarnings = FALSE)

    result <- list_migration_files(empty_dir)
    expect_length(result, 0)

    unlink(empty_dir, recursive = TRUE)
  })

  it("ignores non-SQL files", {
    temp_dir <- tempdir()
    migrations_dir <- file.path(temp_dir, "mixed_migrations")
    dir.create(migrations_dir, showWarnings = FALSE)

    writeLines("SELECT 1;", file.path(migrations_dir, "001_valid.sql"))
    writeLines("# README", file.path(migrations_dir, "README.md"))
    writeLines("test", file.path(migrations_dir, "test.txt"))

    result <- list_migration_files(migrations_dir)

    expect_length(result, 1)
    expect_equal(result[1], "001_valid.sql")

    unlink(migrations_dir, recursive = TRUE)
  })
})

describe("migration idempotency logic", {
  it("setdiff correctly identifies pending migrations", {
    all_files <- c("001_first.sql", "002_second.sql", "003_third.sql")
    applied <- c("001_first.sql")

    pending <- setdiff(all_files, applied)

    expect_length(pending, 2)
    expect_equal(pending, c("002_second.sql", "003_third.sql"))
  })

  it("returns empty when all migrations applied", {
    all_files <- c("001_first.sql", "002_second.sql")
    applied <- c("001_first.sql", "002_second.sql")

    pending <- setdiff(all_files, applied)

    expect_length(pending, 0)
  })
})
```

**Additional test blocks to add:**

1. **DELIMITER extraction test** - Test that custom delimiter (like `//`) is correctly detected
2. **SQL with multi-line comments** - Ensure `/* ... */` comments don't break splitting
3. **Edge case: semicolon in string** - Document known limitation (or handle if split_sql_statements does)

**Test organization:**
- Group by function using describe() blocks
- Use it() for individual test cases
- Include setup/teardown for temp files
- No database mocking needed for pure unit tests
- Skip database-dependent tests with skip_if_not()
  </action>
  <verify>
Run tests:
```bash
cd api && Rscript -e "testthat::test_file('tests/testthat/test-unit-migration-runner.R')"
```

All tests should pass. Check test count:
```bash
grep -c "it(" api/tests/testthat/test-unit-migration-runner.R
# Should show 8+ test cases
```
  </verify>
  <done>
- test-unit-migration-runner.R exists with comprehensive tests
- Tests cover split_sql_statements(), list_migration_files(), idempotency logic
- All tests pass when run with testthat
- Test file follows project conventions (describe/it blocks, temp file cleanup)
  </done>
</task>

</tasks>

<verification>
Overall verification:

1. **Run test file:**
   ```bash
   cd /home/bernt-popp/development/sysndd/api && Rscript -e "testthat::test_file('tests/testthat/test-unit-migration-runner.R')"
   ```

2. **Run full test suite to ensure no regressions:**
   ```bash
   cd /home/bernt-popp/development/sysndd && make test-api
   ```

3. **Check test coverage of key functions:**
   ```bash
   grep -E "(split_sql_statements|list_migration_files)" api/tests/testthat/test-unit-migration-runner.R
   ```
</verification>

<success_criteria>
1. api/tests/testthat/test-unit-migration-runner.R exists
2. Contains 8+ test cases covering core functions
3. All tests pass when executed
4. Full API test suite still passes (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/47-migration-system-foundation/47-02-SUMMARY.md`
</output>
