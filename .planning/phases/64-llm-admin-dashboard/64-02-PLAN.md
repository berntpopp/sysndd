---
phase: 64-llm-admin-dashboard
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - db/migrations/008_add_llm_prompt_templates.sql
  - api/functions/llm-service.R
autonomous: true

must_haves:
  truths:
    - "llm_prompt_templates table exists in database"
    - "Default prompts (v1.0) are seeded for all 4 prompt types"
    - "get_prompt_template() retrieves active template from database"
    - "save_prompt_template() stores new version in database"
    - "Existing prompt functions continue to work (backward compatible)"
  artifacts:
    - path: "db/migrations/008_add_llm_prompt_templates.sql"
      provides: "Database migration for prompt templates table"
      contains: "CREATE TABLE.*llm_prompt_templates"
    - path: "api/functions/llm-service.R"
      provides: "Prompt template database functions"
      exports: ["get_prompt_template", "save_prompt_template", "get_all_prompt_templates"]
  key_links:
    - from: "api/functions/llm-service.R"
      to: "db/migrations/008_add_llm_prompt_templates.sql"
      via: "database query"
      pattern: "llm_prompt_templates"
    - from: "api/endpoints/llm_admin_endpoints.R"
      to: "api/functions/llm-service.R"
      via: "function calls"
      pattern: "get_prompt_template|save_prompt_template"
---

<objective>
Add database migration for prompt templates and implement prompt template functions

Purpose: Enable admin editing of LLM prompts with versioning, storing templates in database instead of hardcoded in R code.

Output: Migration 008 creating llm_prompt_templates table with seeded default prompts, and R functions to query/save templates
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/64-llm-admin-dashboard/64-RESEARCH.md
@.planning/LLM_ADMIN_DASHBOARD_PLAN.md
@db/migrations/006_add_llm_summary_cache.sql (migration pattern)
@db/migrations/007_comparisons_config.sql (recent migration pattern)
@api/functions/llm-service.R (extend with template functions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration for llm_prompt_templates table</name>
  <files>db/migrations/008_add_llm_prompt_templates.sql</files>
  <action>
Create new migration file db/migrations/008_add_llm_prompt_templates.sql following the existing migration pattern (stored procedure for idempotence):

```sql
-- Add LLM prompt templates table for admin-editable prompts
--
-- Design:
-- - prompt_type: ENUM for 4 prompt types (functional_generation, functional_judge, phenotype_generation, phenotype_judge)
-- - version: Allows multiple versions, only one is_active per type
-- - template_text: The actual prompt template
-- - is_active: Boolean for soft versioning
-- - created_by: FK to user table (NULL for system defaults)
--
-- Idempotent: Uses stored procedure with IF NOT EXISTS checks

DELIMITER //

CREATE PROCEDURE IF NOT EXISTS migrate_008_llm_prompt_templates()
BEGIN
    -- Create llm_prompt_templates table if not exists
    IF NOT EXISTS (
        SELECT 1 FROM INFORMATION_SCHEMA.TABLES
        WHERE TABLE_SCHEMA = DATABASE()
          AND TABLE_NAME = 'llm_prompt_templates'
    ) THEN
        CREATE TABLE llm_prompt_templates (
            template_id INT AUTO_INCREMENT PRIMARY KEY,
            prompt_type ENUM('functional_generation', 'functional_judge',
                            'phenotype_generation', 'phenotype_judge') NOT NULL,
            version VARCHAR(20) NOT NULL DEFAULT '1.0',
            template_text TEXT NOT NULL,
            description TEXT,
            is_active BOOLEAN NOT NULL DEFAULT TRUE,
            created_by INT NULL COMMENT 'user_id of creator, NULL for system defaults',
            created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            UNIQUE KEY idx_prompt_type_version (prompt_type, version),
            INDEX idx_is_active (is_active),
            INDEX idx_prompt_type_active (prompt_type, is_active)
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
    END IF;
END //

CALL migrate_008_llm_prompt_templates() //

DROP PROCEDURE IF EXISTS migrate_008_llm_prompt_templates //

DELIMITER ;
```

**Important:** Do NOT include the INSERT statements in the migration. The seeding will be handled by R code on first access (backward compatible with existing hardcoded prompts). The migration only creates the table structure.
  </action>
  <verify>
File exists at db/migrations/008_add_llm_prompt_templates.sql and contains CREATE TABLE llm_prompt_templates.
  </verify>
  <done>
Migration file 008_add_llm_prompt_templates.sql exists with correct table schema including prompt_type ENUM, version, template_text, is_active, and proper indexes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add prompt template database functions to llm-service.R</name>
  <files>api/functions/llm-service.R</files>
  <action>
Add these functions to api/functions/llm-service.R (at the end of the file, before any existing export comments):

1. **get_prompt_template(prompt_type)** - Retrieve active template:
```r
#' Get active prompt template from database
#'
#' Returns the active prompt template for the specified type.
#' Falls back to hardcoded default if no database entry exists.
#'
#' @param prompt_type Character, one of "functional_generation", "functional_judge",
#'   "phenotype_generation", "phenotype_judge"
#'
#' @return List with template_text, version, prompt_type
#'
#' @export
get_prompt_template <- function(prompt_type) {
  valid_types <- c("functional_generation", "functional_judge",
                   "phenotype_generation", "phenotype_judge")
  if (!prompt_type %in% valid_types) {
    log_error("Invalid prompt_type: {prompt_type}")
    rlang::abort(paste("Invalid prompt_type:", prompt_type))
  }

  # Try database first
  result <- tryCatch({
    db_execute_query(
      "SELECT template_id, prompt_type, version, template_text, description
       FROM llm_prompt_templates
       WHERE prompt_type = ? AND is_active = TRUE
       ORDER BY created_at DESC
       LIMIT 1",
      list(prompt_type)
    )
  }, error = function(e) {
    log_warn("Failed to query prompt templates: {e$message}")
    tibble::tibble()
  })

  if (nrow(result) > 0) {
    return(list(
      template_id = result$template_id[1],
      prompt_type = result$prompt_type[1],
      version = result$version[1],
      template_text = result$template_text[1],
      description = result$description[1]
    ))
  }

  # Fallback to hardcoded defaults
  log_debug("Using hardcoded default for prompt_type: {prompt_type}")
  get_default_prompt_template(prompt_type)
}
```

2. **get_default_prompt_template(prompt_type)** - Hardcoded fallbacks:
```r
#' Get hardcoded default prompt template
#'
#' Returns the original hardcoded prompt for backward compatibility.
#' Used when database table doesn't exist or has no entry for type.
#'
#' @param prompt_type Character
#' @return List with template_text, version, prompt_type
get_default_prompt_template <- function(prompt_type) {
  # Extract from existing build_cluster_prompt and build_phenotype_cluster_prompt functions
  templates <- list(
    functional_generation = "You are an expert bioinformatician analyzing gene functional clusters for a neurodevelopmental disorder database. Analyze the following cluster of genes and provide a concise summary.",
    functional_judge = "You are a STRICT scientific accuracy validator. Review the following AI-generated summary and evaluate whether it accurately represents the gene cluster data.",
    phenotype_generation = "You are an expert clinical geneticist analyzing phenotype clusters for a neurodevelopmental disorder database. Analyze the following cluster of entities and provide a concise summary.",
    phenotype_judge = "You are a STRICT validator for AI-generated phenotype cluster summaries. Review the following summary and evaluate scientific accuracy."
  )

  list(
    template_id = NA_integer_,
    prompt_type = prompt_type,
    version = "1.0",
    template_text = templates[[prompt_type]],
    description = "Default hardcoded template"
  )
}
```

3. **save_prompt_template()** - Save new template version:
```r
#' Save prompt template to database
#'
#' Creates a new version of a prompt template. Optionally deactivates
#' previous versions of the same type.
#'
#' @param prompt_type Character
#' @param template_text Character, the prompt text
#' @param version Character, version string (e.g., "1.1")
#' @param description Character or NULL
#' @param created_by Integer or NULL, user_id
#' @param deactivate_previous Logical, if TRUE marks previous versions as inactive
#'
#' @return Integer, the template_id of the new entry
#'
#' @export
save_prompt_template <- function(prompt_type, template_text, version,
                                  description = NULL, created_by = NULL,
                                  deactivate_previous = TRUE) {
  valid_types <- c("functional_generation", "functional_judge",
                   "phenotype_generation", "phenotype_judge")
  if (!prompt_type %in% valid_types) {
    rlang::abort(paste("Invalid prompt_type:", prompt_type))
  }

  # Convert NULLs to NA for DBI binding
  description_val <- if (is.null(description)) NA_character_ else description
  created_by_val <- if (is.null(created_by)) NA_integer_ else as.integer(created_by)

  result <- db_with_transaction({
    if (deactivate_previous) {
      db_execute_statement(
        "UPDATE llm_prompt_templates SET is_active = FALSE WHERE prompt_type = ?",
        list(prompt_type)
      )
    }

    db_execute_statement(
      "INSERT INTO llm_prompt_templates
       (prompt_type, version, template_text, description, is_active, created_by)
       VALUES (?, ?, ?, ?, TRUE, ?)",
      list(prompt_type, version, template_text, description_val, created_by_val)
    )

    id_result <- db_execute_query("SELECT LAST_INSERT_ID() AS id")
    id_result$id[1]
  })

  log_info("Saved prompt template: type={prompt_type}, version={version}, id={result}")
  result
}
```

4. **get_all_prompt_templates()** - Get all templates for admin view:
```r
#' Get all prompt templates for admin display
#'
#' Returns the active template for each prompt type.
#'
#' @return Named list with template data for each type
#'
#' @export
get_all_prompt_templates <- function() {
  types <- c("functional_generation", "functional_judge",
             "phenotype_generation", "phenotype_judge")

  templates <- lapply(types, get_prompt_template)
  names(templates) <- types
  templates
}
```
  </action>
  <verify>
Run: cd /home/bernt-popp/development/sysndd/api && Rscript -e "source('functions/llm-service.R'); print(exists('get_prompt_template')); print(exists('save_prompt_template')); print(exists('get_all_prompt_templates'))"
All should return TRUE.
  </verify>
  <done>
Four new functions exist in llm-service.R: get_prompt_template, get_default_prompt_template, save_prompt_template, get_all_prompt_templates.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add prompt endpoints to llm_admin_endpoints.R and run linting</name>
  <files>api/endpoints/llm_admin_endpoints.R</files>
  <action>
**Note:** This task depends on Plan 01 completing first. If llm_admin_endpoints.R doesn't exist yet, create it with these endpoints plus the ones from Plan 01.

Add these prompt-related endpoints to llm_admin_endpoints.R:

1. **GET /prompts** - Get all prompt templates:
```r
#* Get all prompt templates
#*
#* Returns the active template for each prompt type.
#*
#* @tag llm-admin
#* @serializer json
#*
#* @get /prompts
function(req, res) {
  require_role(req, res, "Administrator")
  get_all_prompt_templates()
}
```

2. **PUT /prompts/<type>** - Update a prompt template:
```r
#* Update a prompt template
#*
#* Creates a new version of the specified prompt template.
#*
#* @tag llm-admin
#* @serializer json
#*
#* @put /prompts/<type>
function(req, res, type) {
  require_role(req, res, "Administrator")

  valid_types <- c("functional_generation", "functional_judge",
                   "phenotype_generation", "phenotype_judge")
  if (!type %in% valid_types) {
    res$status <- 400
    return(list(error = "Invalid prompt type", valid_types = valid_types))
  }

  body <- jsonlite::fromJSON(req$postBody)
  if (is.null(body$template) || is.null(body$version)) {
    res$status <- 400
    return(list(error = "Missing required fields: template, version"))
  }

  user_id <- get_user_id_from_token(req)

  template_id <- save_prompt_template(
    prompt_type = type,
    template_text = body$template,
    version = body$version,
    description = body$description,
    created_by = user_id
  )

  list(success = TRUE, type = type, version = body$version, template_id = template_id)
}
```

**Run linting:**
- cd /home/bernt-popp/development/sysndd && make lint-api
- Fix any issues in the new code
  </action>
  <verify>
Run: cd /home/bernt-popp/development/sysndd && make lint-api
Should pass with no errors.
  </verify>
  <done>
GET /prompts and PUT /prompts/:type endpoints added to llm_admin_endpoints.R, R linting passes.
  </done>
</task>

</tasks>

<verification>
1. Migration file 008_add_llm_prompt_templates.sql exists with correct schema
2. Four new functions in llm-service.R source without error
3. Prompt endpoints added to llm_admin_endpoints.R
4. R linting passes (make lint-api)
</verification>

<success_criteria>
- Migration 008 creates llm_prompt_templates table with proper schema
- get_prompt_template() returns hardcoded default when table is empty
- save_prompt_template() creates new versioned entry in database
- GET /api/llm/prompts returns all 4 prompt templates
- PUT /api/llm/prompts/:type saves new template version
- Existing prompt building functions continue to work
</success_criteria>

<output>
After completion, create `.planning/phases/64-llm-admin-dashboard/64-02-SUMMARY.md`
</output>
