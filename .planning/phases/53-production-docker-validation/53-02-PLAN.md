---
phase: 53-production-docker-validation
plan: 02
type: execute
wave: 2
depends_on: ["53-01"]
files_modified:
  - Makefile
  - api/tests/testthat/test-integration-health.R
autonomous: true

must_haves:
  truths:
    - "`make preflight` builds production Docker image"
    - "`make preflight` starts containers and waits for health check"
    - "`make preflight` cleans up containers after validation"
    - "`make preflight` exits 0 on success, 1 on failure"
    - "Integration test verifies /health/ready endpoint behavior"
  artifacts:
    - path: "Makefile"
      provides: "preflight target for production validation"
      contains: "preflight:"
    - path: "api/tests/testthat/test-integration-health.R"
      provides: "Integration tests for health endpoint"
      contains: "health/ready"
  key_links:
    - from: "Makefile"
      to: "docker-compose.yml"
      via: "docker compose up/down commands"
      pattern: "docker compose"
    - from: "Makefile"
      to: "/health/ready"
      via: "curl health check"
      pattern: "curl.*health/ready"
---

<objective>
Create Makefile preflight target for production validation and integration tests for the health endpoint.

Purpose: Enable pre-deployment validation and automated testing of production Docker configuration.
Output: `make preflight` target that builds, starts, validates, and cleans up; integration tests for health endpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/53-production-docker-validation/53-CONTEXT.md
@.planning/phases/53-production-docker-validation/53-RESEARCH.md
@.planning/phases/53-production-docker-validation/53-01-SUMMARY.md
@Makefile
@docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add `make preflight` target for production validation</name>
  <files>Makefile</files>
  <action>
  Add the preflight target to the Makefile in the Quality Targets section (after pre-commit target, around line 168).

  First, add preflight to the .PHONY declaration (line 37):
  ```makefile
  .PHONY: help check-r check-npm check-docker install-api install-app dev serve-app build-app watch-app test-api test-api-full coverage lint-api lint-app format-api format-app pre-commit preflight docker-build docker-up docker-down docker-dev docker-dev-db docker-logs docker-status
  ```

  Then add the preflight target after pre-commit (insert after line 167):
  ```makefile

  # Configuration for preflight validation
  PREFLIGHT_TIMEOUT := 120
  PREFLIGHT_HEALTH_ENDPOINT := http://localhost/health/ready

  preflight: check-docker ## [quality] Run production preflight validation
  	@printf "$(CYAN)==> Running production preflight validation...$(RESET)\n"
  	@printf "\n$(CYAN)[1/4] Building production API image...$(RESET)\n"
  	@docker build -t sysndd-api:preflight -f $(ROOT_DIR)/api/Dockerfile $(ROOT_DIR)/api/ || \
  		(printf "$(RED)Build failed$(RESET)\n" && exit 1)
  	@printf "$(GREEN)Build complete$(RESET)\n"
  	@printf "\n$(CYAN)[2/4] Starting production containers...$(RESET)\n"
  	@cd $(ROOT_DIR) && docker compose -f docker-compose.yml up -d || \
  		(printf "$(RED)Container startup failed$(RESET)\n" && exit 1)
  	@printf "$(GREEN)Containers started$(RESET)\n"
  	@printf "\n$(CYAN)[3/4] Waiting for health check (timeout: $(PREFLIGHT_TIMEOUT)s)...$(RESET)\n"
  	@SECONDS=0; \
  	while [ $$SECONDS -lt $(PREFLIGHT_TIMEOUT) ]; do \
  		RESPONSE=$$(curl -sf $(PREFLIGHT_HEALTH_ENDPOINT) 2>/dev/null); \
  		if [ $$? -eq 0 ]; then \
  			printf "$(GREEN)Health check passed!$(RESET)\n"; \
  			printf "Response: $$RESPONSE\n"; \
  			HEALTH_OK=1; \
  			break; \
  		fi; \
  		printf "."; \
  		sleep 2; \
  		SECONDS=$$((SECONDS+2)); \
  	done; \
  	if [ -z "$$HEALTH_OK" ]; then \
  		printf "\n$(RED)Health check timed out after $(PREFLIGHT_TIMEOUT)s$(RESET)\n"; \
  		printf "\n$(YELLOW)Last 50 lines of API logs:$(RESET)\n"; \
  		docker compose -f docker-compose.yml logs api --tail=50; \
  		printf "\n$(CYAN)[4/4] Cleanup (after failure)...$(RESET)\n"; \
  		docker compose -f docker-compose.yml down; \
  		printf "\n$(RED)PREFLIGHT FAILED$(RESET)\n"; \
  		exit 1; \
  	fi
  	@printf "\n$(CYAN)[4/4] Cleanup...$(RESET)\n"
  	@cd $(ROOT_DIR) && docker compose -f docker-compose.yml down
  	@printf "\n$(GREEN)========================================$(RESET)\n"
  	@printf "$(GREEN)       PREFLIGHT PASSED                 $(RESET)\n"
  	@printf "$(GREEN)========================================$(RESET)\n"
  	@printf "\n$(CYAN)Production Docker build validated:$(RESET)\n"
  	@printf "  - API image builds successfully\n"
  	@printf "  - Containers start without errors\n"
  	@printf "  - /health/ready returns 200\n"
  	@printf "  - Database connectivity verified\n"
  ```

  Key implementation notes:
  - Uses production docker-compose.yml only (no dev overrides)
  - 120s timeout allows for cold start (image pull, migrations)
  - Shows progress dots during health check wait
  - Dumps API logs on failure for debugging
  - Always cleans up containers (on success or failure)
  - Exit code 0 on success, 1 on failure (CI-friendly)
  - Uses localhost/health/ready (via Traefik) to validate full stack
  </action>
  <verify>
  - `grep -n "preflight:" Makefile` shows target exists
  - `grep -n "PREFLIGHT_TIMEOUT" Makefile` shows timeout configuration
  - `grep -n "health/ready" Makefile` shows health endpoint check
  - `make help | grep preflight` shows target in help output
  </verify>
  <done>`make preflight` target builds prod image, starts containers, waits for /health/ready, cleans up, reports PASS/FAIL with exit codes</done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests for health endpoint</name>
  <files>api/tests/testthat/test-integration-health.R</files>
  <action>
  Create a new test file `api/tests/testthat/test-integration-health.R` for health endpoint integration tests.

  ```r
  # test-integration-health.R
  #
  # Integration tests for health endpoints.
  # These tests verify /health and /health/ready endpoints work correctly.
  # Run with: cd api && Rscript -e "testthat::test_file('tests/testthat/test-integration-health.R')"

  library(testthat)
  library(httr)

  # Helper to check if API is running
  skip_if_no_api <- function() {
    api_url <- Sys.getenv("API_URL", "http://localhost:7778")
    tryCatch({
      resp <- httr::GET(paste0(api_url, "/health/"), timeout(5))
      if (httr::status_code(resp) != 200) {
        skip("API not responding (health check failed)")
      }
    }, error = function(e) {
      skip(paste("API not available:", e$message))
    })
  }

  describe("/health endpoint", {
    it("returns healthy status with version", {
      skip_if_no_api()
      api_url <- Sys.getenv("API_URL", "http://localhost:7778")

      resp <- httr::GET(paste0(api_url, "/health/"))

      expect_equal(httr::status_code(resp), 200)

      body <- httr::content(resp, as = "parsed")
      expect_equal(body$status, "healthy")
      expect_true(!is.null(body$version))
      expect_true(!is.null(body$timestamp))
    })
  })

  describe("/health/ready endpoint", {
    it("returns healthy status when database connected", {
      skip_if_no_api()
      api_url <- Sys.getenv("API_URL", "http://localhost:7778")

      resp <- httr::GET(paste0(api_url, "/health/ready"))

      expect_equal(httr::status_code(resp), 200)

      body <- httr::content(resp, as = "parsed")
      expect_equal(body$status, "healthy")
      expect_equal(body$database, "connected")
    })

    it("includes migration status in response", {
      skip_if_no_api()
      api_url <- Sys.getenv("API_URL", "http://localhost:7778")

      resp <- httr::GET(paste0(api_url, "/health/ready"))
      body <- httr::content(resp, as = "parsed")

      expect_true(!is.null(body$migrations))
      expect_true(!is.null(body$migrations$pending))
      expect_true(!is.null(body$migrations$applied))
      # When healthy, pending should be 0
      expect_equal(body$migrations$pending, 0)
    })

    it("includes pool statistics in response", {
      skip_if_no_api()
      api_url <- Sys.getenv("API_URL", "http://localhost:7778")

      resp <- httr::GET(paste0(api_url, "/health/ready"))
      body <- httr::content(resp, as = "parsed")

      expect_true(!is.null(body$pool))
      expect_true(!is.null(body$pool$max_size))
      # max_size should match DB_POOL_SIZE env var (default 5)
      expect_true(body$pool$max_size >= 1)
    })

    it("includes timestamp in ISO 8601 format", {
      skip_if_no_api()
      api_url <- Sys.getenv("API_URL", "http://localhost:7778")

      resp <- httr::GET(paste0(api_url, "/health/ready"))
      body <- httr::content(resp, as = "parsed")

      expect_true(!is.null(body$timestamp))
      # Should be ISO 8601 format ending in Z (UTC)
      expect_true(grepl("T.*Z$", body$timestamp))
    })
  })

  describe("health endpoint content type", {
    it("returns application/json content type", {
      skip_if_no_api()
      api_url <- Sys.getenv("API_URL", "http://localhost:7778")

      resp <- httr::GET(paste0(api_url, "/health/ready"))

      content_type <- httr::headers(resp)$`content-type`
      expect_true(grepl("application/json", content_type))
    })
  })
  ```

  These tests:
  - Skip gracefully when API is not running (allows CI without full stack)
  - Verify /health returns status, version, timestamp
  - Verify /health/ready returns database status, migrations, pool stats
  - Verify response format and content types
  - Use API_URL env var (default localhost:7778 for direct API access)
  </action>
  <verify>
  - `test -f api/tests/testthat/test-integration-health.R` confirms file exists
  - `grep -c "describe\\|it" api/tests/testthat/test-integration-health.R` shows test count (at least 6)
  - `grep "health/ready" api/tests/testthat/test-integration-health.R` shows endpoint tested
  </verify>
  <done>Integration tests verify /health and /health/ready endpoints return correct status, database connectivity, migration info, pool stats, and proper JSON format</done>
</task>

</tasks>

<verification>
1. Preflight target exists and works:
   - `make help | grep preflight` shows target
   - `grep "PREFLIGHT_TIMEOUT" Makefile` shows config

2. Integration tests exist:
   - `ls api/tests/testthat/test-integration-health.R` succeeds
   - Tests include describe blocks for /health and /health/ready

3. Code quality:
   - `cd api && Rscript -e "lintr::lint_dir('tests/testthat')"` passes
</verification>

<success_criteria>
1. `make preflight` exists with correct help documentation
2. Preflight builds production image, starts containers, validates health, cleans up
3. Preflight exits 0 on success, 1 on failure (CI-compatible)
4. Integration tests verify /health endpoint basic functionality
5. Integration tests verify /health/ready returns database status, migrations, pool stats
6. Tests skip gracefully when API not available
</success_criteria>

<output>
After completion, create `.planning/phases/53-production-docker-validation/53-02-SUMMARY.md`
</output>
