---
phase: 53-production-docker-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/start_sysndd_api.R
  - api/endpoints/health_endpoints.R
  - docker-compose.yml
autonomous: true

must_haves:
  truths:
    - "Pool has explicit maxSize limit (not Inf)"
    - "Pool size is configurable via DB_POOL_SIZE environment variable"
    - "/health/ready verifies actual database connectivity"
    - "/health/ready returns pool statistics"
    - "/health/ready returns 503 when database is unavailable"
  artifacts:
    - path: "api/start_sysndd_api.R"
      provides: "Pool creation with explicit sizing"
      contains: "DB_POOL_SIZE"
    - path: "api/endpoints/health_endpoints.R"
      provides: "Extended readiness check with DB ping"
      contains: "SELECT 1"
    - path: "docker-compose.yml"
      provides: "DB_POOL_SIZE environment variable"
      contains: "DB_POOL_SIZE"
  key_links:
    - from: "api/start_sysndd_api.R"
      to: "pool::dbPool"
      via: "maxSize parameter from env var"
      pattern: "maxSize.*pool_size"
    - from: "api/endpoints/health_endpoints.R"
      to: "db_execute_query"
      via: "database ping in readiness check"
      pattern: "db_execute_query.*SELECT 1"
---

<objective>
Configure explicit connection pool sizing and enhance the /health/ready endpoint to verify actual database connectivity.

Purpose: Production systems need bounded resource limits and proper health checks for load balancer integration.
Output: Pool with explicit maxSize (configurable via env var), health endpoint that verifies DB connectivity and reports pool stats.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/53-production-docker-validation/53-CONTEXT.md
@.planning/phases/53-production-docker-validation/53-RESEARCH.md
@api/start_sysndd_api.R
@api/endpoints/health_endpoints.R
@api/functions/db-helpers.R
@docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add explicit pool sizing with environment variable</name>
  <files>api/start_sysndd_api.R, docker-compose.yml</files>
  <action>
  Modify the pool creation in `api/start_sysndd_api.R` (around line 180) to use explicit sizing:

  1. Read pool size from environment variable with default:
     ```r
     pool_size <- as.integer(Sys.getenv("DB_POOL_SIZE", "5"))
     ```

  2. Update dbPool() call to include explicit parameters:
     ```r
     pool <<- dbPool(
       drv      = RMariaDB::MariaDB(),
       dbname   = dw$dbname,
       host     = dw$host,
       user     = dw$user,
       password = dw$password,
       server   = dw$server,
       port     = dw$port,
       minSize  = 1,
       maxSize  = pool_size,
       idleTimeout = 60,
       validationInterval = 60
     )
     ```

  3. Add a message after pool creation logging the pool size:
     ```r
     message(sprintf("[%s] Database pool created (minSize=1, maxSize=%d)", Sys.time(), pool_size))
     ```

  4. Add DB_POOL_SIZE to docker-compose.yml api service environment section (after SMTP_PASSWORD):
     ```yaml
     DB_POOL_SIZE: ${DB_POOL_SIZE:-5}
     ```

  Why explicit sizing: Default maxSize=Inf is risky in production - can exhaust MySQL connections.
  Why 5 as default: Single-threaded R process rarely needs more than 1-2 concurrent connections, but 5 allows burst for mirai workers.
  </action>
  <verify>
  - `grep -n "DB_POOL_SIZE" api/start_sysndd_api.R` shows pool size reading
  - `grep -n "maxSize" api/start_sysndd_api.R` shows explicit pool sizing
  - `grep -n "DB_POOL_SIZE" docker-compose.yml` shows env var in compose
  </verify>
  <done>Pool creation uses explicit minSize=1, maxSize from DB_POOL_SIZE env var (default 5), idleTimeout=60, validationInterval=60</done>
</task>

<task type="auto">
  <name>Task 2: Enhance /health/ready with database connectivity check and pool stats</name>
  <files>api/endpoints/health_endpoints.R</files>
  <action>
  Replace the existing `/health/ready` endpoint (lines 23-94) with an enhanced version:

  ```r
  #* Readiness check for Kubernetes probes
  #*
  #* Returns HTTP 200 when ready to serve traffic, HTTP 503 when not ready.
  #* Checks database connectivity and migration status for comprehensive readiness.
  #*
  #* # `Response Codes`
  #* - 200: API ready to serve traffic (database connected, migrations current)
  #* - 503: API not ready (database unavailable or migrations pending)
  #*
  #* # `Details`
  #* This endpoint performs three checks:
  #* 1. Database connectivity: Executes SELECT 1 to verify connection
  #* 2. Migration status: Verifies no pending migrations
  #* 3. Pool statistics: Reports active/idle connections
  #*
  #* Use this endpoint for Kubernetes readiness probes and load balancer health checks.
  #*
  #* @tag health
  #* @serializer json
  #*
  #* @response 200 OK. API ready to serve traffic with database connected.
  #* @response 503 Service Unavailable. Database unavailable or migrations pending.
  #*
  #* @get /ready
  function(req, res) {
    timestamp <- format(Sys.time(), "%Y-%m-%dT%H:%M:%SZ", tz = "UTC")

    # Check database connectivity with simple ping query
    db_ok <- tryCatch({
      result <- db_execute_query("SELECT 1 AS ok")
      !is.null(result) && nrow(result) == 1 && result$ok[1] == 1
    }, error = function(e) {
      log_warn("Health check database ping failed: {e$message}")
      FALSE
    })

    # Check migration status (variable set during API startup)
    migrations_ok <- FALSE
    migration_info <- list(pending = NA, applied = NA)

    if (exists("migration_status", where = .GlobalEnv) &&
        !is.null(.GlobalEnv$migration_status)) {
      status <- .GlobalEnv$migration_status
      pending <- status$pending_migrations
      migrations_ok <- !is.null(pending) && pending == 0
      migration_info <- list(
        pending = if (is.null(pending)) NA else pending,
        applied = if (is.null(status$total_migrations)) NA else status$total_migrations
      )
    }

    # Get pool statistics
    pool_stats <- tryCatch({
      # pool package stores counters internally
      # Use pool's internal state to get connection counts
      checkout_count <- pool$counters$free + pool$counters$taken
      list(
        max_size = as.integer(Sys.getenv("DB_POOL_SIZE", "5")),
        active = pool$counters$taken,
        idle = pool$counters$free,
        total = checkout_count
      )
    }, error = function(e) {
      list(
        max_size = as.integer(Sys.getenv("DB_POOL_SIZE", "5")),
        error = "Unable to read pool statistics"
      )
    })

    # Determine overall health
    if (db_ok && migrations_ok) {
      list(
        status = "healthy",
        database = "connected",
        migrations = migration_info,
        pool = pool_stats,
        timestamp = timestamp
      )
    } else {
      res$status <- 503L

      # Determine reason for unhealthy status
      reason <- if (!db_ok) {
        "database_unavailable"
      } else {
        "migrations_pending"
      }

      list(
        status = "unhealthy",
        reason = reason,
        database = if (db_ok) "connected" else "disconnected",
        migrations = migration_info,
        pool = pool_stats,
        timestamp = timestamp
      )
    }
  }
  ```

  Note: This uses db_execute_query from db-helpers.R which is already sourced in start_sysndd_api.R.
  The pool object and its counters are available as globals.
  </action>
  <verify>
  - `grep -n "SELECT 1" api/endpoints/health_endpoints.R` shows database ping
  - `grep -n "pool_stats" api/endpoints/health_endpoints.R` shows pool statistics
  - `grep -n "database_unavailable" api/endpoints/health_endpoints.R` shows proper error reason
  </verify>
  <done>/health/ready checks database connectivity via SELECT 1, reports migrations status, includes pool statistics, returns 503 with reason when unhealthy</done>
</task>

</tasks>

<verification>
1. Pool sizing applied:
   - `grep "DB_POOL_SIZE" api/start_sysndd_api.R` returns match
   - `grep "maxSize" api/start_sysndd_api.R` shows explicit sizing

2. Health endpoint enhanced:
   - `grep "SELECT 1" api/endpoints/health_endpoints.R` shows DB ping
   - `grep "pool_stats" api/endpoints/health_endpoints.R` shows pool reporting

3. Compose updated:
   - `grep "DB_POOL_SIZE" docker-compose.yml` shows env var

4. Code quality:
   - `cd api && Rscript -e "lintr::lint_dir('.')"` passes
</verification>

<success_criteria>
1. Pool creation uses explicit minSize=1, maxSize from env var (default 5)
2. /health/ready verifies database connectivity via SELECT 1
3. /health/ready returns pool statistics (max_size, active, idle)
4. /health/ready returns 503 with reason when database unavailable
5. DB_POOL_SIZE environment variable documented in docker-compose.yml
</success_criteria>

<output>
After completion, create `.planning/phases/53-production-docker-validation/53-01-SUMMARY.md`
</output>
