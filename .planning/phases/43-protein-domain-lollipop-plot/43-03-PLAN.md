---
phase: 43-protein-domain-lollipop-plot
plan: 03
type: execute
wave: 3
depends_on: ["43-02"]
files_modified:
  - app/src/components/gene/ProteinDomainLollipopCard.vue
  - app/src/views/pages/GeneView.vue
autonomous: true

must_haves:
  truths:
    - "Protein domain card appears on gene page when external data loads"
    - "Card shows loading spinner while UniProt/ClinVar data is fetching"
    - "Card shows error state with retry button when both data sources fail"
    - "Card shows 'No ClinVar variants mapped' when domains exist but no variants"
    - "Card shows plain backbone with lollipops when no domains but variants exist"
    - "GeneView fetches external data via useGeneExternalData and passes to card"
    - "Data processing transforms raw API variants into ProcessedVariant format"
  artifacts:
    - path: "app/src/components/gene/ProteinDomainLollipopCard.vue"
      provides: "Card wrapper with loading/error/empty states around lollipop plot"
      min_lines: 60
    - path: "app/src/views/pages/GeneView.vue"
      provides: "Updated gene page with protein domain card integrated"
  key_links:
    - from: "app/src/components/gene/ProteinDomainLollipopCard.vue"
      to: "app/src/components/gene/ProteinDomainLollipopPlot.vue"
      via: "child component"
      pattern: "ProteinDomainLollipopPlot"
    - from: "app/src/components/gene/ProteinDomainLollipopCard.vue"
      to: "app/src/types/protein.ts"
      via: "import types and processing functions"
      pattern: "import.*ProteinPlotData|ProcessedVariant|normalizeClassification|parseProteinPosition"
    - from: "app/src/views/pages/GeneView.vue"
      to: "app/src/components/gene/ProteinDomainLollipopCard.vue"
      via: "child component in template"
      pattern: "ProteinDomainLollipopCard"
    - from: "app/src/views/pages/GeneView.vue"
      to: "app/src/composables/useGeneExternalData.ts"
      via: "composable usage"
      pattern: "useGeneExternalData"
---

<objective>
Create the ProteinDomainLollipopCard.vue wrapper component (handles loading/error/empty states, data processing) and integrate it into GeneView.vue with external data fetching.

Purpose: Connects the visualization to real data from the backend proxy layer. The card handles the messy real-world states (loading, errors, empty data) while delegating rendering to the plot component. GeneView.vue gains external data fetching via useGeneExternalData composable.

Output: `app/src/components/gene/ProteinDomainLollipopCard.vue` (card wrapper), updated `app/src/views/pages/GeneView.vue` (integration).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-protein-domain-lollipop-plot/43-CONTEXT.md
@.planning/phases/43-protein-domain-lollipop-plot/43-RESEARCH.md
@.planning/phases/43-protein-domain-lollipop-plot/43-01-SUMMARY.md
@.planning/phases/43-protein-domain-lollipop-plot/43-02-SUMMARY.md

Key references:
@app/src/views/pages/GeneView.vue (current gene page -- needs integration)
@app/src/components/gene/ProteinDomainLollipopPlot.vue (plot component from Plan 02)
@app/src/types/protein.ts (types and helpers from Plan 01)
@app/src/composables/useD3Lollipop.ts (composable from Plan 01)
@app/src/components/gene/IdentifierCard.vue (card styling pattern -- BCard with drop shadow)
@.planning/phases/42-constraint-scores-variant-summaries/42-01-PLAN.md (useGeneExternalData composable specification -- data layer Phase 43 depends on)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProteinDomainLollipopCard wrapper component</name>
  <files>app/src/components/gene/ProteinDomainLollipopCard.vue</files>
  <action>
Create `app/src/components/gene/ProteinDomainLollipopCard.vue` as a Vue 3 SFC with `<script setup lang="ts">`:

**Props:**
- uniprotData: object | null (raw UniProt API response from useGeneExternalData -- { protein_length, accession, protein_name, domains: [...] })
- clinvarVariants: ClinVarVariant[] | null (raw ClinVar variants from useGeneExternalData)
- uniprotLoading: boolean (loading state for UniProt source)
- clinvarLoading: boolean (loading state for ClinVar source)
- uniprotError: string | null (error state for UniProt source)
- clinvarError: string | null (error state for ClinVar source)
- geneSymbol: string (required)

**Emits:**
- retry: () => void -- parent re-fetches external data
- variant-click: (variant: ProcessedVariant) => void -- bubbles up from plot

**Template structure:**
```html
<BCard
  class="shadow-sm border-0 mb-3"
  body-class="p-2"
  header-class="py-2 px-3"
>
  <template #header>
    <div class="d-flex justify-content-between align-items-center">
      <h6 class="mb-0 fw-bold">
        <i class="bi bi-diagram-3" /> Protein Domains & ClinVar Variants
      </h6>
      <!-- Reset zoom button (only shown when zoomed in) -->
      <BButton
        v-if="isZoomed"
        variant="outline-secondary"
        size="sm"
        @click="handleResetZoom"
      >
        <i class="bi bi-arrows-angle-expand" /> Reset Zoom
      </BButton>
    </div>
  </template>

  <!-- State 1: Both loading -->
  <div v-if="isLoading" class="d-flex justify-content-center py-4">
    <BSpinner label="Loading protein domain data..." />
  </div>

  <!-- State 2: Full failure (both sources errored) -->
  <div v-else-if="isFullError" class="text-center py-4">
    <p class="text-muted mb-2">
      <i class="bi bi-exclamation-triangle" /> Unable to load protein domain data
    </p>
    <BButton variant="outline-primary" size="sm" @click="$emit('retry')">
      <i class="bi bi-arrow-clockwise" /> Retry
    </BButton>
  </div>

  <!-- State 3: Data available (partial or full) -->
  <div v-else-if="plotData">
    <ProteinDomainLollipopPlot
      ref="plotRef"
      :data="plotData"
      :gene-symbol="geneSymbol"
      @variant-click="$emit('variant-click', $event)"
    />
    <!-- Partial error messages -->
    <div v-if="uniprotError" class="text-muted small text-center mt-1">
      <i class="bi bi-info-circle" /> Domain data unavailable -- showing variants only
    </div>
    <div v-if="clinvarError" class="text-muted small text-center mt-1">
      <i class="bi bi-info-circle" /> Variant data unavailable -- showing domains only
    </div>
  </div>

  <!-- State 4: No data at all (not error, just empty) -->
  <div v-else class="text-center py-4 text-muted">
    <i class="bi bi-diagram-3" /> No protein domain or variant data available for this gene
  </div>
</BCard>
```

**Script setup logic:**

1. **Computed: isLoading** -- true when either UniProt or ClinVar is still loading
   ```typescript
   const isLoading = computed(() => props.uniprotLoading || props.clinvarLoading);
   ```

2. **Computed: isFullError** -- true when both sources have errors and no data
   ```typescript
   const isFullError = computed(() =>
     !props.uniprotLoading && !props.clinvarLoading &&
     !!props.uniprotError && !!props.clinvarError
   );
   ```

3. **Computed: plotData** -- process raw API data into ProteinPlotData:
   ```typescript
   const plotData = computed<ProteinPlotData | null>(() => {
     // Need at least one data source
     const hasUniprot = props.uniprotData && !props.uniprotError;
     const hasClinvar = props.clinvarVariants && !props.clinvarError;

     if (!hasUniprot && !hasClinvar) return null;

     // Process domains from UniProt response
     const domains: ProteinDomain[] = hasUniprot
       ? (props.uniprotData.domains || []).map(d => ({
           type: d.type,
           description: d.description || '',
           begin: Number(d.begin),
           end: Number(d.end),
         }))
       : [];

     // Process variants from ClinVar response
     const variants: ProcessedVariant[] = hasClinvar
       ? props.clinvarVariants
           .map(v => {
             const parsed = parseProteinPosition(v.hgvsp, v.hgvsc);
             if (!parsed) return null;
             return {
               proteinPosition: parsed.position,
               proteinHGVS: v.hgvsp || 'N/A',
               codingHGVS: v.hgvsc || 'N/A',
               classification: normalizeClassification(v.clinical_significance),
               goldStars: v.gold_stars,
               reviewStatus: v.review_status,
               clinvarId: String(v.clinvar_variation_id),
               variantId: v.variant_id,
               majorConsequence: v.major_consequence,
               isSpliceVariant: parsed.isSplice,
               inGnomad: v.in_gnomad,
             } as ProcessedVariant;
           })
           .filter((v): v is ProcessedVariant => v !== null)
       : [];

     const proteinLength = hasUniprot ? Number(props.uniprotData.protein_length) : estimateProteinLength(variants);
     const proteinName = hasUniprot ? (props.uniprotData.protein_name || '') : '';
     const accession = hasUniprot ? (props.uniprotData.accession || '') : '';

     return {
       proteinLength,
       proteinName,
       accession,
       domains,
       variants,
     };
   });
   ```

   Helper function `estimateProteinLength(variants)`: When UniProt data is unavailable, estimate protein length from max variant position + 10% buffer. Fall back to 1000 if no variants.

4. **Zoom state:** Template ref to ProteinDomainLollipopPlot for accessing resetZoom. Expose isZoomed computed (from plot component or composable's currentZoomDomain).

5. **handleResetZoom:** Call plot component's exposed resetZoom method.

**Important: ClinVarVariant type dependency.**
This component uses `ClinVarVariant` from `app/src/types/external.ts` (created by Phase 42, Plan 01). If Phase 42 has not been executed yet, the type may not exist. In that case:
- Define a minimal `ClinVarVariant` interface locally or in `protein.ts` that matches the gnomAD ClinVar response fields (clinical_significance, clinvar_variation_id, gold_stars, hgvsc, hgvsp, in_gnomad, major_consequence, pos, review_status, variant_id).
- This avoids a hard compile-time dependency on Phase 42 being complete.
- When Phase 42 executes, the local type can be replaced with the canonical import from `types/external.ts`.

**Scoped styles:**
Follow existing card patterns (shadow-sm, border-0 from IdentifierCard/ClinicalResourcesCard).
  </action>
  <verify>
Run `cd /home/bernt-popp/development/sysndd/app && npx tsc --noEmit --pretty` -- zero type errors. Verify component handles all 4 states (loading, full error, data, empty).
  </verify>
  <done>
ProteinDomainLollipopCard.vue handles loading/error/empty states with graceful degradation, processes raw API data into ProteinPlotData format, renders ProteinDomainLollipopPlot when data available, shows partial error messages when one source fails, and exposes retry/variant-click events.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate protein domain card into GeneView.vue</name>
  <files>app/src/views/pages/GeneView.vue</files>
  <action>
Update `app/src/views/pages/GeneView.vue` to add external data fetching and the protein domain lollipop card:

1. **Add imports:**
   ```typescript
   import ProteinDomainLollipopCard from '@/components/gene/ProteinDomainLollipopCard.vue';
   import { useGeneExternalData } from '@/composables';
   ```

   **IMPORTANT dependency check:** The `useGeneExternalData` composable is defined in Phase 42 Plan 01. If it has not been implemented yet:
   - Create a minimal inline version directly in GeneView.vue (or a local `useGeneExternalData.ts` stub) that:
     - Fetches from `${import.meta.env.VITE_API_URL}/api/external/gene/${symbol}`
     - Returns per-source loading/error/data refs for at least: `uniprot` and `clinvar`
     - Can be replaced with the real composable when Phase 42 executes
   - OR skip the composable entirely and fetch external data inline with axios, distributing results to local refs

   The preferred approach: Check if `app/src/composables/useGeneExternalData.ts` exists. If yes, import and use it. If no, create inline data fetching in GeneView.vue that can be refactored later.

2. **Add external data state:**
   If using composable:
   ```typescript
   const { uniprot, clinvar, fetchData: fetchExternalData, retry: retryExternalData } = useGeneExternalData(geneSymbol);
   ```

   If using inline approach:
   ```typescript
   const externalLoading = ref(false);
   const uniprotData = ref(null);
   const uniprotError = ref<string | null>(null);
   const clinvarVariants = ref<ClinVarVariant[] | null>(null);
   const clinvarError = ref<string | null>(null);

   async function fetchExternalData() {
     if (!geneSymbol.value) return;
     externalLoading.value = true;
     uniprotError.value = null;
     clinvarError.value = null;
     try {
       const apiBase = import.meta.env.VITE_API_URL;
       const response = await axios.get(`${apiBase}/api/external/gene/${geneSymbol.value}`);
       const result = response.data;
       // Distribute per-source
       if (result.sources?.uniprot) uniprotData.value = result.sources.uniprot;
       if (result.errors?.uniprot) uniprotError.value = result.errors.uniprot.detail;
       if (result.sources?.gnomad_clinvar) clinvarVariants.value = result.sources.gnomad_clinvar.variants;
       if (result.errors?.gnomad_clinvar) clinvarError.value = result.errors.gnomad_clinvar.detail;
     } catch (e) {
       uniprotError.value = 'Network error';
       clinvarError.value = 'Network error';
     }
     externalLoading.value = false;
   }
   ```

3. **Trigger external data fetch:**
   In the existing `loadGeneInfo()` function, after the gene data loads successfully (after `geneData.value = ...`), call `fetchExternalData()`.
   Also in the route watcher, trigger `fetchExternalData()` after `loadGeneInfo()`.

4. **Add template for the protein domain card:**
   Place it below the gene information card and above the TablesEntities:
   ```html
   <!-- Protein Domain Lollipop Plot -->
   <ProteinDomainLollipopCard
     v-if="!loading && geneSymbol"
     :uniprot-data="uniprotData"
     :clinvar-variants="clinvarVariants"
     :uniprot-loading="uniprotLoading"
     :clinvar-loading="clinvarLoading"
     :uniprot-error="uniprotError"
     :clinvar-error="clinvarError"
     :gene-symbol="geneSymbol"
     @retry="fetchExternalData"
   />
   ```
   Prop names should match whatever data structure is used (composable or inline).

5. **Preserve existing layout:**
   - The gene info BCard stays at the top
   - ProteinDomainLollipopCard goes below it (full width -- cols="12")
   - TablesEntities stays at the bottom
   - The protein card renders independently and doesn't block the gene info or table from loading

**Key principle:** External data loading is NON-BLOCKING. The gene page shows gene info immediately. The protein card shows its own loading spinner while external data fetches. If external data fails, the rest of the page is unaffected.
  </action>
  <verify>
Run `cd /home/bernt-popp/development/sysndd/app && npx tsc --noEmit --pretty` -- zero type errors. Verify GeneView.vue imports ProteinDomainLollipopCard and has external data fetching logic. Run `cd /home/bernt-popp/development/sysndd/app && npx vite build --mode development 2>&1 | tail -5` to verify the build succeeds.
  </verify>
  <done>
GeneView.vue fetches external data (UniProt + ClinVar) after gene data loads, passes per-source data/loading/error state to ProteinDomainLollipopCard, and renders the protein domain visualization below gene info. External data loading is non-blocking. Build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `cd /home/bernt-popp/development/sysndd/app && npx tsc --noEmit --pretty` -- zero type errors
2. `cd /home/bernt-popp/development/sysndd/app && npx vite build --mode development 2>&1 | tail -5` -- build succeeds
3. ProteinDomainLollipopCard.vue exists with loading/error/data/empty state handling
4. GeneView.vue imports and renders ProteinDomainLollipopCard
5. GeneView.vue has external data fetching logic (composable or inline)
6. External data loading is non-blocking (gene info renders independently)
7. `grep "ProteinDomainLollipopCard" app/src/views/pages/GeneView.vue` -- component used
8. `grep "external/gene" app/src/views/pages/GeneView.vue` -- API call present (if inline)
</verification>

<success_criteria>
- Protein domain card appears on gene page when data loads
- Card handles all states: loading spinner, full error with retry, partial data, empty data
- Raw API data processed into ProteinPlotData format (domains + variants with parsed positions)
- GeneView.vue fetches external data non-blocking after gene data loads
- Variant position parsing works for both protein HGVS and coding HGVS (with splice variant detection)
- Error isolation: UniProt failure still shows variants, ClinVar failure still shows domains
- Build compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/43-protein-domain-lollipop-plot/43-03-SUMMARY.md`
</output>
