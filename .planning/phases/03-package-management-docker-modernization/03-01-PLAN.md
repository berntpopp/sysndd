---
phase: 03-package-management-docker-modernization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/renv.lock
  - api/renv/activate.R
  - api/renv/settings.json
  - api/.Rprofile
  - api/.gitignore
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Running renv::restore() on fresh clone installs identical package versions"
    - "R session auto-activates renv when started from api/ directory"
    - "renv cache is shared across projects via global cache location"
  artifacts:
    - path: "api/renv.lock"
      provides: "Package version lockfile"
      contains: "Packages"
    - path: "api/renv/activate.R"
      provides: "Auto-activation script"
      min_lines: 10
    - path: "api/.Rprofile"
      provides: "Session startup script sourcing renv"
      contains: "activate.R"
  key_links:
    - from: "api/.Rprofile"
      to: "api/renv/activate.R"
      via: "source() call on R startup"
      pattern: "source.*activate"
---

<objective>
Initialize renv for reproducible R package management in the API directory.

Purpose: Enable deterministic package installation across all development environments and Docker builds. Developers running `renv::restore()` will get identical package versions regardless of when or where they clone the repository.

Output:
- renv.lock file with all current package versions pinned
- renv/ directory with activation script
- .Rprofile that auto-activates renv on R startup
- Updated .gitignore to exclude renv cache but include lockfile
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-package-management-docker-modernization/03-RESEARCH.md

# Current Dockerfile shows all packages that need to be in lockfile
@api/Dockerfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize renv and create lockfile</name>
  <files>
    api/renv.lock
    api/renv/activate.R
    api/renv/settings.json
    api/.Rprofile
  </files>
  <action>
Initialize renv in the api/ directory with pak backend enabled:

1. Change to api/ directory and start R
2. Install renv if not present: `install.packages("renv")`
3. Configure renv to use pak for faster installation:
   ```r
   options(renv.config.pak.enabled = TRUE)
   ```
4. Initialize renv with explicit consent:
   ```r
   renv::init()
   ```
   This will:
   - Create renv/ directory with activate.R
   - Create renv.lock from currently installed packages
   - Create .Rprofile that sources renv/activate.R
   - Create renv/settings.json

5. Configure global cache location in settings.json:
   ```r
   renv::settings$cache.symlinks(TRUE)
   ```

6. Snapshot to ensure lockfile is complete:
   ```r
   renv::snapshot(type = "all")
   ```
   Use type="all" to capture both direct and implicit dependencies.

**Important:** Run this from the api/ directory where all packages are already installed. renv::init() will detect existing packages and create the lockfile from them.

**Do NOT** start from scratch - the existing Dockerfile shows 30+ packages that are currently used in production.
  </action>
  <verify>
Run in api/ directory:
```r
renv::status()
```
Should show "No issues found" or list packages to add.

Verify renv.lock exists and contains expected packages:
```bash
grep -c '"Package"' api/renv.lock
# Should be 30+ packages
```
  </verify>
  <done>
- renv.lock file exists with 30+ packages pinned
- renv/activate.R exists and is valid R code
- .Rprofile sources renv/activate.R
- renv::status() reports no synchronization issues
  </done>
</task>

<task type="auto">
  <name>Task 2: Update .gitignore for renv</name>
  <files>api/.gitignore</files>
  <action>
Update api/.gitignore to properly handle renv files:

**Must be tracked (NOT in .gitignore):**
- renv.lock (the lockfile - critical for reproducibility)
- renv/activate.R (auto-generated but needed for bootstrap)
- renv/settings.json (project-specific settings)
- .Rprofile (sources renv on startup)

**Must be ignored:**
- renv/library/ (local package cache - large, regenerated via restore)
- renv/local/ (local-only packages)
- renv/cellar/ (cellar packages)
- renv/lock/ (temporary lock files)
- renv/python/ (Python environment if any)
- renv/sandbox/ (sandbox directory)
- renv/staging/ (staging area)
- .Rprofile.user (user-specific overrides)

Add these patterns to api/.gitignore:
```
# renv library cache (regenerated via renv::restore())
renv/library/
renv/local/
renv/cellar/
renv/lock/
renv/python/
renv/sandbox/
renv/staging/

# User-specific R profile (not project config)
.Rprofile.user
```

**Do NOT ignore:**
- renv.lock
- renv/activate.R
- renv/settings.json
- .Rprofile
  </action>
  <verify>
```bash
# Verify renv.lock is NOT ignored
git check-ignore api/renv.lock && echo "ERROR: renv.lock should not be ignored" || echo "OK: renv.lock will be tracked"

# Verify library IS ignored
git check-ignore api/renv/library && echo "OK: library is ignored" || echo "ERROR: library should be ignored"
```
  </verify>
  <done>
- api/.gitignore includes renv exclusion patterns
- renv.lock is tracked by git (not ignored)
- renv/library/ is ignored by git
- renv/activate.R is tracked by git
  </done>
</task>

</tasks>

<verification>
Run from api/ directory:

1. **renv status check:**
   ```r
   renv::status()
   # Should show no issues
   ```

2. **Lockfile package count:**
   ```bash
   grep '"Package"' api/renv.lock | wc -l
   # Should be 30+ packages
   ```

3. **Activation test:**
   ```bash
   cd api && Rscript -e "print(renv::project())"
   # Should print the api/ directory path
   ```

4. **Git status:**
   ```bash
   git status api/renv.lock api/renv/activate.R
   # Both should be untracked or modified (ready to add)
   ```
</verification>

<success_criteria>
1. renv.lock exists with all current API packages version-pinned
2. renv/activate.R exists and auto-sources on R startup
3. .Rprofile contains `source("renv/activate.R")`
4. .gitignore properly excludes renv cache but tracks lockfile
5. `renv::status()` shows synchronized state
</success_criteria>

<output>
After completion, create `.planning/phases/03-package-management-docker-modernization/03-01-SUMMARY.md`
</output>
