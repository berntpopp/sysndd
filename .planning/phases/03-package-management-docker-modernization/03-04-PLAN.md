---
phase: 03-package-management-docker-modernization
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - api/tests/testthat/helper-mock-apis.R
  - api/tests/testthat/fixtures/pubmed/.gitkeep
  - api/tests/testthat/fixtures/pubtator/.gitkeep
  - api/tests/testthat/test-external-pubmed.R
  - api/tests/testthat/test-external-pubtator.R
autonomous: true
user_setup: []

must_haves:
  truths:
    - "PubMed API tests run without network calls when fixtures exist"
    - "PubTator API tests run without network calls when fixtures exist"
    - "Tests can record new fixtures from live API when needed"
    - "Sensitive data is redacted from fixture files"
  artifacts:
    - path: "api/tests/testthat/helper-mock-apis.R"
      provides: "httptest2 setup and mock helpers"
      contains: "httptest2"
      min_lines: 20
    - path: "api/tests/testthat/test-external-pubmed.R"
      provides: "PubMed API mock tests"
      contains: "with_pubmed_mock"
    - path: "api/tests/testthat/test-external-pubtator.R"
      provides: "PubTator API mock tests"
      contains: "with_pubtator_mock"
  key_links:
    - from: "api/tests/testthat/test-external-pubmed.R"
      to: "api/functions/publication-functions.R"
      via: "testing check_pmid and info_from_pmid"
      pattern: "check_pmid|info_from_pmid"
    - from: "api/tests/testthat/test-external-pubtator.R"
      to: "api/functions/pubtator-functions.R"
      via: "testing pubtator_v3 functions"
      pattern: "pubtator_v3"
---

<objective>
Implement httptest2-based mocking for external API calls (PubMed and PubTator).

Purpose: External API tests should be isolated from network availability and rate limits. The httptest2 package records real API responses to fixture files, then replays them in tests. This enables reliable CI/CD testing without external dependencies.

Output:
- helper-mock-apis.R with httptest2 setup and convenience wrappers
- Fixture directory structure for PubMed and PubTator responses
- Test files for PubMed API functions (check_pmid, info_from_pmid)
- Test files for PubTator API functions (pubtator_v3_* functions)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-package-management-docker-modernization/03-RESEARCH.md

# Existing test infrastructure
@api/tests/testthat/setup.R
@api/tests/testthat/helper-db.R
@api/tests/testthat/helper-auth.R

# Functions that call external APIs - need to understand their signatures
@api/functions/publication-functions.R
@api/functions/pubtator-functions.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create httptest2 helper and fixture directories</name>
  <files>
    api/tests/testthat/helper-mock-apis.R
    api/tests/testthat/fixtures/pubmed/.gitkeep
    api/tests/testthat/fixtures/pubtator/.gitkeep
  </files>
  <action>
**Part A: Install httptest2 package**

First, ensure httptest2 is installed:
```r
install.packages("httptest2")
```

**Part B: Create helper-mock-apis.R**

Create api/tests/testthat/helper-mock-apis.R:

```r
# helper-mock-apis.R
# httptest2 configuration and convenience functions for external API mocking
#
# Usage:
#   with_pubmed_mock({ ... })   - Run code with PubMed API mocked
#   with_pubtator_mock({ ... }) - Run code with PubTator API mocked
#
# First run with fixtures missing: Records live API responses
# Subsequent runs: Replays recorded responses (no network calls)

library(httptest2)

# Configure redactor to remove any sensitive data from fixtures
# PubMed and PubTator don't require API keys, but this is good practice
httptest2::set_redactor(function(resp) {
  # Redact any email addresses that might appear in responses
  resp <- httptest2::gsub_response(
    resp,
    "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}",
    "REDACTED@example.com"
  )
  # Redact any api_key parameters if they appear
  resp <- httptest2::gsub_response(
    resp,
    "api_key=[^&]+",
    "api_key=REDACTED"
  )
  resp
})

#' Run tests with PubMed API mocked
#'
#' Uses fixtures from tests/testthat/fixtures/pubmed/
#' First run records responses, subsequent runs replay them
#'
#' @param code Test code to run
#' @export
with_pubmed_mock <- function(code) {
  httptest2::with_mock_dir(
    testthat::test_path("fixtures", "pubmed"),
    code
  )
}

#' Run tests with PubTator API mocked
#'
#' Uses fixtures from tests/testthat/fixtures/pubtator/
#' First run records responses, subsequent runs replay them
#'
#' @param code Test code to run
#' @export
with_pubtator_mock <- function(code) {
  httptest2::with_mock_dir(
    testthat::test_path("fixtures", "pubtator"),
    code
  )
}

#' Skip test if network is unavailable and fixtures don't exist
#'
#' Use this for tests that need to record fixtures initially
#'
#' @param fixture_path Path to fixture directory
#' @export
skip_if_no_fixtures_or_network <- function(fixture_path) {
  fixtures_exist <- length(list.files(fixture_path)) > 0
  if (!fixtures_exist) {
    # Try a quick network check
    network_ok <- tryCatch({
      con <- url("https://www.ncbi.nlm.nih.gov", "rb")
      close(con)
      TRUE
    }, error = function(e) FALSE)

    if (!network_ok) {
      testthat::skip("No fixtures and no network access - cannot record or mock")
    }
  }
}
```

**Part C: Create fixture directories**

Create the fixture directory structure:
```bash
mkdir -p api/tests/testthat/fixtures/pubmed
mkdir -p api/tests/testthat/fixtures/pubtator
touch api/tests/testthat/fixtures/pubmed/.gitkeep
touch api/tests/testthat/fixtures/pubtator/.gitkeep
```

The .gitkeep files ensure the directories are tracked by git even when empty.
  </action>
  <verify>
```bash
# Check helper file exists
test -f api/tests/testthat/helper-mock-apis.R && echo "OK: helper-mock-apis.R exists"

# Check fixture directories exist
test -d api/tests/testthat/fixtures/pubmed && echo "OK: pubmed fixtures dir exists"
test -d api/tests/testthat/fixtures/pubtator && echo "OK: pubtator fixtures dir exists"

# Verify helper-mock-apis.R has required functions
grep -q "with_pubmed_mock" api/tests/testthat/helper-mock-apis.R && echo "OK: with_pubmed_mock defined"
grep -q "with_pubtator_mock" api/tests/testthat/helper-mock-apis.R && echo "OK: with_pubtator_mock defined"
```
  </verify>
  <done>
- api/tests/testthat/helper-mock-apis.R exists with httptest2 setup
- with_pubmed_mock() function defined
- with_pubtator_mock() function defined
- Redactor configured to remove sensitive data
- fixtures/pubmed/ directory created
- fixtures/pubtator/ directory created
- .gitkeep files in both fixture directories
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PubMed and PubTator API tests</name>
  <files>
    api/tests/testthat/test-external-pubmed.R
    api/tests/testthat/test-external-pubtator.R
  </files>
  <action>
**Part A: Create test-external-pubmed.R**

Create api/tests/testthat/test-external-pubmed.R:

```r
# test-external-pubmed.R
# Tests for PubMed API integration (publication-functions.R)
#
# These tests use httptest2 to mock external API calls.
# First run: Records live API responses to fixtures/pubmed/
# Subsequent runs: Replays recorded responses

# Source the publication functions
# Determine api directory path (handles testthat working directory changes)
api_dir <- if (basename(getwd()) == "testthat") {
  normalizePath(file.path(getwd(), "..", ".."))
} else if (basename(getwd()) == "tests") {
  normalizePath(file.path(getwd(), ".."))
} else if (file.exists("functions/publication-functions.R")) {
  getwd()
} else {
  normalizePath(file.path(getwd(), "api"))
}

# Source required files
source(file.path(api_dir, "functions/publication-functions.R"))

# Skip tests if required packages not available
skip_if_not_installed("httptest2")
skip_if_not_installed("easyPubMed")

test_that("check_pmid returns TRUE for valid PMID", {
  skip_if_no_fixtures_or_network(test_path("fixtures", "pubmed"))

  with_pubmed_mock({
    # PMID 12345678 - "The human genome" - well-known valid PMID
    # Note: The actual PMID tested may need adjustment based on easyPubMed behavior
    result <- tryCatch({
      check_pmid("33054928")  # Example PMID - adjust if needed
    }, error = function(e) {
      skip(paste("PubMed API error:", e$message))
    })

    expect_true(is.logical(result))
  })
})

test_that("check_pmid handles list of PMIDs", {
  skip_if_no_fixtures_or_network(test_path("fixtures", "pubmed"))

  with_pubmed_mock({
    result <- tryCatch({
      check_pmid(c("33054928", "33054929"))
    }, error = function(e) {
      skip(paste("PubMed API error:", e$message))
    })

    expect_true(is.logical(result))
  })
})

test_that("check_pmid handles PMID: prefix", {
  skip_if_no_fixtures_or_network(test_path("fixtures", "pubmed"))

  with_pubmed_mock({
    result <- tryCatch({
      # Function should strip PMID: prefix
      check_pmid("PMID:33054928")
    }, error = function(e) {
      skip(paste("PubMed API error:", e$message))
    })

    expect_true(is.logical(result))
  })
})

# Note: info_from_pmid() tests are more complex due to data transformation
# Adding basic structure test
test_that("info_from_pmid returns tibble with expected columns", {
  skip_if_no_fixtures_or_network(test_path("fixtures", "pubmed"))
  skip("info_from_pmid requires additional setup - to be expanded")

  with_pubmed_mock({
    result <- tryCatch({
      info_from_pmid("33054928")
    }, error = function(e) {
      skip(paste("PubMed API error:", e$message))
    })

    expect_s3_class(result, "tbl_df")
  })
})
```

**Part B: Create test-external-pubtator.R**

Create api/tests/testthat/test-external-pubtator.R:

```r
# test-external-pubtator.R
# Tests for PubTator API integration (pubtator-functions.R)
#
# These tests use httptest2 to mock external API calls.
# First run: Records live API responses to fixtures/pubtator/
# Subsequent runs: Replays recorded responses

# Source the pubtator functions
# Determine api directory path (handles testthat working directory changes)
api_dir <- if (basename(getwd()) == "testthat") {
  normalizePath(file.path(getwd(), "..", ".."))
} else if (basename(getwd()) == "tests") {
  normalizePath(file.path(getwd(), ".."))
} else if (file.exists("functions/pubtator-functions.R")) {
  getwd()
} else {
  normalizePath(file.path(getwd(), "api"))
}

# Source required files
source(file.path(api_dir, "functions/pubtator-functions.R"))

# Skip tests if required packages not available
skip_if_not_installed("httptest2")
skip_if_not_installed("jsonlite")

test_that("pubtator_v3_total_pages_from_query returns page count", {
  skip_if_no_fixtures_or_network(test_path("fixtures", "pubtator"))

  with_pubtator_mock({
    result <- tryCatch({
      # Simple query that should return results
      pubtator_v3_total_pages_from_query("BRCA1")
    }, error = function(e) {
      skip(paste("PubTator API error:", e$message))
    })

    # Should return a number (total pages)
    expect_true(is.numeric(result) || is.null(result))
    if (!is.null(result)) {
      expect_gt(result, 0)
    }
  })
})

test_that("pubtator_v3_total_pages_from_query handles empty results", {
  skip_if_no_fixtures_or_network(test_path("fixtures", "pubtator"))

  with_pubtator_mock({
    result <- tryCatch({
      # Nonsense query that should return no results
      pubtator_v3_total_pages_from_query("xyzzy12345nonexistent98765")
    }, error = function(e) {
      skip(paste("PubTator API error:", e$message))
    })

    # Should return NULL or 0 for no results
    expect_true(is.null(result) || result == 0)
  })
})

test_that("pubtator_v3_pmids_from_request returns tibble", {
  skip_if_no_fixtures_or_network(test_path("fixtures", "pubtator"))

  with_pubtator_mock({
    result <- tryCatch({
      pubtator_v3_pmids_from_request(
        query = "BRCA1",
        start_page = 1,
        max_pages = 1
      )
    }, error = function(e) {
      skip(paste("PubTator API error:", e$message))
    })

    # Should return tibble or NULL
    if (!is.null(result)) {
      expect_s3_class(result, "tbl_df")
      expect_true("pmid" %in% names(result))
    }
  })
})

test_that("pubtator_v3_parse_nonstandard_json handles empty input", {
  # This tests the JSON parser without network calls
  result <- pubtator_v3_parse_nonstandard_json(NULL)
  expect_null(result)

  result <- pubtator_v3_parse_nonstandard_json(character(0))
  expect_null(result)
})

test_that("generate_query_hash produces consistent hash", {
  # This tests the hash function without network calls
  hash1 <- generate_query_hash("test query")
  hash2 <- generate_query_hash("test query")
  hash3 <- generate_query_hash("different query")

  expect_equal(hash1, hash2)
  expect_false(hash1 == hash3)
  expect_equal(nchar(hash1), 64)  # SHA-256 produces 64 hex chars
})

# Note: pubtator_v3_data_from_pmids tests would require more complex fixtures
# due to non-standard JSON format. Adding structure test only.
test_that("pubtator_v3_data_from_pmids handles NULL input", {
  result <- pubtator_v3_data_from_pmids(NULL)
  expect_null(result)

  result <- pubtator_v3_data_from_pmids(character(0))
  expect_null(result)
})
```

**Notes on fixture recording:**
- First test run with network access will record API responses to fixtures/
- The recorded responses are JSON files that httptest2 manages automatically
- Subsequent runs use these fixtures - no network calls made
- If you need to update fixtures, delete the fixture files and re-run tests
  </action>
  <verify>
```bash
# Check test files exist
test -f api/tests/testthat/test-external-pubmed.R && echo "OK: test-external-pubmed.R exists"
test -f api/tests/testthat/test-external-pubtator.R && echo "OK: test-external-pubtator.R exists"

# Run tests (may skip if no network and no fixtures yet)
cd /mnt/c/development/sysndd/api && Rscript -e "testthat::test_file('tests/testthat/test-external-pubtator.R')"

# Check that non-network tests pass (hash, null handling)
cd /mnt/c/development/sysndd/api && Rscript -e "testthat::test_file('tests/testthat/test-external-pubtator.R', filter='hash|NULL')"
```
  </verify>
  <done>
- api/tests/testthat/test-external-pubmed.R exists with PubMed API tests
- api/tests/testthat/test-external-pubtator.R exists with PubTator API tests
- Tests use with_pubmed_mock() and with_pubtator_mock() wrappers
- Non-network tests (hash, null handling) pass immediately
- Network-dependent tests skip gracefully if no fixtures and no network
- Tests document expected behavior for check_pmid, pubtator_v3_* functions
  </done>
</task>

</tasks>

<verification>
1. **Run all tests including new external API tests:**
   ```bash
   cd /mnt/c/development/sysndd/api
   Rscript -e "testthat::test_dir('tests/testthat')"
   ```

2. **Verify helper functions are auto-sourced:**
   ```bash
   cd /mnt/c/development/sysndd/api
   Rscript -e "testthat::test_file('tests/testthat/test-external-pubtator.R')" 2>&1 | head -20
   # Should not show "could not find function with_pubtator_mock"
   ```

3. **Check fixture directory structure:**
   ```bash
   tree api/tests/testthat/fixtures/
   # pubmed/
   #   .gitkeep
   # pubtator/
   #   .gitkeep
   ```

4. **Verify non-network tests pass:**
   ```bash
   cd /mnt/c/development/sysndd/api
   Rscript -e "testthat::test_file('tests/testthat/test-external-pubtator.R')" 2>&1 | grep -E "OK|PASS|SKIP"
   # Should show OK/PASS for hash and null handling tests
   ```
</verification>

<success_criteria>
1. helper-mock-apis.R installed with httptest2 setup and convenience wrappers
2. fixtures/pubmed/ and fixtures/pubtator/ directories created
3. test-external-pubmed.R tests check_pmid function with mocked responses
4. test-external-pubtator.R tests pubtator_v3 functions with mocked responses
5. Non-network tests (hash generation, null handling) pass immediately
6. Network-dependent tests skip gracefully when fixtures unavailable
7. Redactor configured to remove sensitive data from recorded fixtures
</success_criteria>

<output>
After completion, create `.planning/phases/03-package-management-docker-modernization/03-04-SUMMARY.md`
</output>
