---
phase: 74-api-bug-fixes
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - api/functions/analyses-functions.R
  - api/endpoints/analysis_endpoints.R
  - api/tests/testthat/test-unit-clustering-empty-tibble.R
autonomous: true

must_haves:
  truths:
    - "Clustering endpoints return a valid empty response (200 OK with empty array) when gene sets produce zero STRING interactions"
    - "Clustering endpoints still return correct results for gene sets that DO have STRING interactions"
    - "All rowwise operations across the API are guarded against empty tibbles"
  artifacts:
    - path: "api/functions/analyses-functions.R"
      provides: "gen_string_clust_obj with defensive nrow checks before all rowwise operations"
      contains: "nrow(.) > 0"
    - path: "api/endpoints/analysis_endpoints.R"
      provides: "Clustering endpoints that handle empty clustering results gracefully"
    - path: "api/tests/testthat/test-unit-clustering-empty-tibble.R"
      provides: "Unit tests for empty tibble handling in clustering functions"
  key_links:
    - from: "api/endpoints/analysis_endpoints.R"
      to: "api/functions/analyses-functions.R"
      via: "gen_string_clust_obj_mem called from functional_clustering endpoint"
      pattern: "gen_string_clust_obj_mem"
    - from: "api/functions/analyses-functions.R"
      to: "STRINGdb"
      via: "string_db$get_graph() returns empty subgraph for genes with no interactions"
      pattern: "induced_subgraph"
---

<objective>
Fix clustering endpoints crashing on empty STRING interactions (API-03, GitHub issue #155).

Purpose: When clustering endpoints are called for gene sets that produce zero STRING protein-protein interactions (empty tibble after subgraph filtering), the rowwise operations in gen_string_clust_obj crash with "subscript out of bounds" error because dplyr's rowwise() on an empty tibble with list-columns tries to access elements that don't exist. The fix adds defensive nrow checks before all rowwise operations and ensures the endpoint returns 200 OK with empty array for valid queries that simply have no results.

Output: Fixed gen_string_clust_obj with empty tibble guards, updated clustering endpoints to handle empty results gracefully, plus unit tests and a scan of all rowwise patterns in the codebase.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/74-api-bug-fixes/74-CONTEXT.md
@.planning/phases/74-api-bug-fixes/74-RESEARCH.md
@api/functions/analyses-functions.R
@api/endpoints/analysis_endpoints.R
@api/tests/testthat/test-unit-analyses-functions.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add defensive empty tibble guards to clustering functions and scan for similar patterns</name>
  <files>api/functions/analyses-functions.R, api/endpoints/analysis_endpoints.R, api/endpoints/statistics_endpoints.R, api/endpoints/admin_endpoints.R, api/functions/comparisons-functions.R, api/functions/hgnc-functions.R, api/functions/ontology-functions.R</files>
  <action>
**Primary fix in gen_string_clust_obj (analyses-functions.R):**

1. After the `clusters_list <- split(...)` at line 141-144 and the creation of `clusters_tibble` at line 146, the tibble goes through a pipeline that includes `rowwise()` at line 157. If `genes_in_graph` is empty (no STRING interactions), `clusters_list` will be empty, and `clusters_tibble` will have 0 rows.

2. Add a defensive early return BEFORE the rowwise pipeline. After line 146 (where clusters_tibble is created from `tibble(clusters_list)`), check:
```r
# Early return if no clusters were formed (no STRING interactions for input genes)
if (nrow(clusters_tibble) == 0) {
  # Clean up and return empty tibble with expected column structure
  rm(string_db, subgraph, cluster_result, clusters_list)
  gc(verbose = FALSE)
  return(tibble(
    cluster = integer(),
    cluster_size = integer(),
    identifiers = list(),
    hash_filter = character()
  ))
}
```

3. The existing guards at lines 169-178 (enrichment) and lines 180-193 (subclusters) already check `nrow(.) > 0`. These are correct but only protect the enrichment/subcluster steps. The rowwise at line 157 + mutate at line 158 (`cluster_size = nrow(identifiers)`) is the actual crash point because it accesses `identifiers` which is a list-column -- on an empty tibble, this fails.

4. Also guard the rowwise section itself. Wrap lines 157-160 in a nrow check:
```r
{
  if (nrow(.) > 0) {
    rowwise(.) %>%
      mutate(cluster_size = nrow(identifiers)) %>%
      filter(cluster_size >= min_size) %>%
      select(cluster, cluster_size, identifiers, hash_filter)
  } else {
    select(., cluster, cluster_size = integer(), identifiers, hash_filter)
  }
}
```
Or more simply, add the early return at step 2 which handles this.

**Secondary fix in gen_mca_clust_obj (analyses-functions.R):**

5. Check `gen_mca_clust_obj` (line 239+). The rowwise at line 295 operates on `clusters_tibble` from HCPC output. HCPC with a valid input always produces clusters, but add a defensive check anyway for robustness.

**Fix in analysis_endpoints.R for empty clustering results:**

6. In the `functional_clustering` endpoint (line 51+), after `gen_string_clust_obj_mem` returns at line 121-124, check if `functional_clusters` has 0 rows. If so, return 200 OK with empty structure:
```r
if (nrow(functional_clusters) == 0) {
  return(list(
    categories = tibble(value = character(), text = character(), link = character()),
    clusters = functional_clusters,
    pagination = list(
      page_size = page_size_int,
      page_after = page_after_clean,
      next_cursor = NULL,
      total_count = 0L,
      has_more = FALSE
    ),
    meta = list(
      algorithm = algorithm_clean,
      elapsed_seconds = round(as.numeric(difftime(Sys.time(), start_time, units = "secs")), 2),
      gene_count = nrow(genes_from_entity_table),
      cluster_count = 0L
    )
  ))
}
```

7. In the `phenotype_functional_cluster_correlation` endpoint (line 332+), after functional_clusters is computed at line 395-398, check for empty results. If empty, skip the functional cluster portion or return empty correlation.

**Scan and fix all rowwise patterns across the codebase:**

8. Scan ALL rowwise() occurrences (already identified from codebase analysis):

- `api/functions/hgnc-functions.R` line 129: `rowwise() %>% mutate(response = hgnc_id_from_prevsymbol(value))`. This operates on a tibble filtered to `is.na(response)` rows. If all values have responses, this tibble is empty. Add guard: `if (nrow(.) > 0) { rowwise(.) %>% ... } else { . }`.

- `api/functions/ontology-functions.R` line 250: `rowwise() %>% mutate(mappings = list(...))`. This operates on `all_terms_tibble` which comes from `tidyr::as_tibble()` of an ontology query. Could be empty if no terms. Add nrow guard.

- `api/functions/comparisons-functions.R` line 606: `rowwise() %>% mutate(category = toString(category), version = toString(version))`. This is inside a comparison join pipeline. Could be empty if no matches. Add nrow guard.

- `api/endpoints/statistics_endpoints.R` lines 298 and 661: `rowwise() %>% mutate(date = max(review_date, status_date, na.rm = TRUE))`. This operates on re_review data. Could be empty if no re-reviews submitted. Add nrow guard.

- `api/endpoints/admin_endpoints.R` line 593: `dplyr::rowwise() %>% dplyr::mutate(mondo_info = ...)`. Operates on affected entities. Could be empty. Add nrow guard.

- `api/endpoints/entity_endpoints.R` line 272: `rowwise() %>% mutate(gr_check = ...)`. This is inside a `if (length(compact(create_data$review$literature)) > 0)` block, so the publications_received tibble has at least one row. This is already safe -- the guard is the if-block. Skip.

- `api/endpoints/review_endpoints.R` line 223: Same pattern as entity_endpoints.R line 272 -- inside a length check block. Already safe. Skip.

- `api/functions/publication-functions.R` lines 67, 104, 112, 304: These are inside function bodies that receive input data. Line 104 and 112 are inside `if (length(compact(...)) > 0)` guards. Line 67 receives `input_tibble` which is constructed from input -- should have rows. Line 304 is inside a batch processing function. Add nrow guards to lines 67 and 304 for robustness.

For each unguarded rowwise, wrap in: `{ if (nrow(.) > 0) { rowwise(.) %>% mutate(...) %>% ungroup() } else { . } }`

Do NOT change the behavior for non-empty tibbles -- the existing logic is correct.
Do NOT change function signatures or return types.
Do NOT cache empty results -- per research recommendation, empty results are fast and don't need caching.
  </action>
  <verify>
Run `cd /home/bernt-popp/development/sysndd && make lint-api` to verify no lintr issues.
Run `grep -rn "rowwise()" api/functions/ api/endpoints/ --include="*.R" | grep -v renv/` to verify all rowwise calls have been reviewed.
Manually inspect that each guarded rowwise preserves the original column structure when the tibble is empty.
  </verify>
  <done>
All rowwise operations in the API are guarded against empty tibbles. gen_string_clust_obj returns an empty tibble with correct column structure when no STRING interactions exist. The functional_clustering endpoint returns 200 OK with empty arrays for valid queries with no results.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for empty tibble handling in clustering</name>
  <files>api/tests/testthat/test-unit-clustering-empty-tibble.R</files>
  <action>
Create a new test file `api/tests/testthat/test-unit-clustering-empty-tibble.R` with unit tests for the empty tibble defensive guards. These tests verify the guard logic without requiring STRINGdb or database access.

Follow the existing test patterns in test-unit-analyses-functions.R.

Tests to write:

1. **Test empty clusters_tibble returns correct structure**: Create an empty tibble matching the structure after `tibble(clusters_list) %>% select(STRING_id = clusters_list) %>% ...` and verify the early return produces a tibble with columns: cluster (integer), cluster_size (integer), identifiers (list), hash_filter (character), with 0 rows.

2. **Test rowwise guard preserves column structure on empty tibble**: Create an empty tibble with columns `cluster`, `identifiers` (list-column), `hash_filter`. Apply the guarded rowwise pattern `{ if (nrow(.) > 0) { rowwise(.) %>% mutate(cluster_size = nrow(identifiers)) } else { mutate(., cluster_size = integer()) } }`. Verify result has 0 rows and correct columns.

3. **Test rowwise guard works correctly on non-empty tibble**: Create a tibble with 2 rows, each having a nested `identifiers` tibble. Apply the rowwise pattern. Verify cluster_size is computed correctly.

4. **Test empty functional_clustering response structure**: Construct the expected empty response from the functional_clustering endpoint (categories, clusters, pagination, meta). Verify it matches the expected JSON shape: categories is empty tibble, clusters is empty tibble, pagination.total_count is 0, pagination.has_more is FALSE.

5. **Test defensive guard pattern for hgnc/ontology/stats rowwise**: Create empty tibbles matching the input patterns for the guarded rowwise in hgnc-functions.R and statistics_endpoints.R. Verify the guard returns the tibble unchanged (no error).

6. **Test nrow guard on tibble with list-column**: Demonstrate that `rowwise() %>% mutate(x = data$col)` on an empty tibble with list-column DOES throw an error (the bug), and `{ if (nrow(.) > 0) { ... } else { . } }` does NOT throw (the fix).

Source helper functions:
```r
source_api_file("functions/helper-functions.R", local = FALSE, envir = globalenv())
```

Do NOT require STRINGdb, database, or igraph for these tests.
  </action>
  <verify>
Run `cd /home/bernt-popp/development/sysndd/api && Rscript -e "testthat::test_file('tests/testthat/test-unit-clustering-empty-tibble.R')"` -- all tests pass.
Run `cd /home/bernt-popp/development/sysndd && make lint-api` -- no lintr issues.
  </verify>
  <done>
Unit tests for empty tibble handling pass, demonstrating that the bug is fixed and the defensive guards produce correct output for both empty and non-empty tibbles.
  </done>
</task>

</tasks>

<verification>
1. `make lint-api` passes with 0 issues
2. `make test-api` passes (all existing tests still pass + new tests pass)
3. All rowwise() calls in api/functions/ and api/endpoints/ are guarded with nrow checks
4. gen_string_clust_obj returns empty tibble with correct columns when no STRING interactions
5. functional_clustering endpoint returns 200 with empty arrays for valid empty results
</verification>

<success_criteria>
- Clustering endpoints return valid empty responses (200 OK) when gene sets produce zero STRING interactions
- All rowwise operations across the API are guarded against empty tibbles (14 occurrences scanned, ~8 fixed)
- Clustering still works correctly for gene sets that have STRING interactions
- New unit tests validate the empty tibble guard pattern
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/74-api-bug-fixes/74-03-SUMMARY.md`
</output>
