---
phase: 67-migration-coordination
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/functions/migration-runner.R
  - api/start_sysndd_api.R
  - api/endpoints/health_endpoints.R
autonomous: true
must_haves:
  truths:
    - "Container starts instantly when schema is up-to-date (fast path, no lock acquisition)"
    - "Container acquires lock only when pending migrations exist"
    - "Container re-checks pending migrations after acquiring lock (handles race condition)"
    - "Health endpoint reports whether container used fast path or acquired lock"
    - "Four containers can start simultaneously without timeout errors"
  artifacts:
    - path: "api/functions/migration-runner.R"
      provides: "get_pending_migrations() helper function"
      contains: "get_pending_migrations"
    - path: "api/start_sysndd_api.R"
      provides: "Double-checked locking in section 7.5"
      contains: "Fast path"
    - path: "api/endpoints/health_endpoints.R"
      provides: "Lock status in /health/ready response"
      contains: "lock_acquired"
  key_links:
    - from: "api/start_sysndd_api.R"
      to: "api/functions/migration-runner.R"
      via: "get_pending_migrations() call before lock"
      pattern: "get_pending_migrations"
    - from: "api/endpoints/health_endpoints.R"
      to: ".GlobalEnv$migration_status"
      via: "reads fast_path and lock_acquired fields"
      pattern: "fast_path|lock_acquired"
---

<objective>
Implement double-checked locking for database migrations to enable parallel container startup without timeout.

Purpose: Fix issue #136 where `docker compose --scale api=4` causes all but one container to wait 30 seconds for migration lock, even when no migrations are needed. The common case (schema already current) should skip locking entirely.

Output: Modified startup sequence that checks schema before acquiring lock, plus enhanced health endpoint showing lock status.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/67-migration-coordination/67-RESEARCH.md

# Key existing code
@api/start_sysndd_api.R (section 7.5 is migration block)
@api/functions/migration-runner.R (has lock functions, needs get_pending_migrations)
@api/endpoints/health_endpoints.R (needs lock status in /ready)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement double-checked locking in startup sequence</name>
  <files>
    api/functions/migration-runner.R
    api/start_sysndd_api.R
  </files>
  <action>
**In api/functions/migration-runner.R:**

Add a new `get_pending_migrations()` helper function that combines `list_migration_files()` and `get_applied_migrations()` to return the list of pending migrations. This function will be called twice: once before lock acquisition (fast path check) and once after (race condition check).

```r
#' Get list of pending migrations
#'
#' Compares available migration files against applied migrations
#' to determine what needs to be run.
#'
#' @param migrations_dir Path to migrations directory. Default: "db/migrations"
#' @param conn Optional database connection or pool object. If NULL, uses global pool.
#'
#' @return Character vector of pending migration filenames (empty if up-to-date)
#'
#' @export
get_pending_migrations <- function(migrations_dir = "db/migrations", conn = NULL) {
  # Ensure tracking table exists (creates if needed, idempotent)
  ensure_schema_version_table(conn)

  # Get all migration files
  all_files <- list_migration_files(migrations_dir)
  if (length(all_files) == 0) {
    return(character(0))
  }

  # Get applied migrations
  applied <- get_applied_migrations(conn)

  # Return pending (those not yet applied)
  setdiff(all_files, applied)
}
```

**In api/start_sysndd_api.R section 7.5:**

Replace the current lock-first approach with double-checked locking pattern:

```r
## -------------------------------------------------------------------##
# 7.5) Run database migrations with double-checked locking
## -------------------------------------------------------------------##
source("functions/migration-runner.R", local = TRUE)

tryCatch(
  {
    # Step 1: Fast path check (no lock needed if schema current)
    pending_before_lock <- get_pending_migrations(migrations_dir = "db/migrations", conn = pool)

    if (length(pending_before_lock) == 0) {
      # Fast path: schema up to date, skip lock entirely
      message(sprintf("[%s] Fast path: schema up to date, no lock needed", Sys.time()))

      # Get total applied count for status
      applied_count <- length(get_applied_migrations(pool))

      migration_status <<- list(
        pending_migrations = 0,
        total_migrations = applied_count,
        last_run = Sys.time(),
        newly_applied = 0,
        filenames = character(0),
        fast_path = TRUE,
        lock_acquired = FALSE
      )
    } else {
      # Step 2: Migrations needed - acquire lock
      message(sprintf(
        "[%s] Pending migrations detected (%d): %s - acquiring lock",
        Sys.time(), length(pending_before_lock), paste(pending_before_lock, collapse = ", ")
      ))

      # Checkout connection for lock duration
      migration_conn <- pool::poolCheckout(pool)
      on.exit(pool::poolReturn(migration_conn), add = TRUE)

      # Acquire advisory lock (blocks until available or 30s timeout)
      acquire_migration_lock(migration_conn, timeout = 30)
      on.exit(release_migration_lock(migration_conn), add = TRUE)

      # Step 3: Re-check after lock (another container may have migrated)
      pending_after_lock <- get_pending_migrations(migrations_dir = "db/migrations", conn = pool)

      if (length(pending_after_lock) == 0) {
        # Race condition: another container applied migrations while we waited
        message(sprintf("[%s] Another container completed migrations while we waited", Sys.time()))

        applied_count <- length(get_applied_migrations(pool))

        migration_status <<- list(
          pending_migrations = 0,
          total_migrations = applied_count,
          last_run = Sys.time(),
          newly_applied = 0,
          filenames = character(0),
          fast_path = FALSE,
          lock_acquired = TRUE
        )
      } else {
        # Step 4: Apply migrations (we hold lock, migrations still needed)
        start_time <- Sys.time()
        result <- run_migrations(migrations_dir = "db/migrations", conn = pool)
        duration <- as.numeric(difftime(Sys.time(), start_time, units = "secs"))

        if (result$newly_applied > 0) {
          message(sprintf(
            "[%s] Migrations complete (%d applied in %.2fs): %s",
            Sys.time(), result$newly_applied, duration,
            paste(result$filenames, collapse = ", ")
          ))
        } else {
          message(sprintf(
            "[%s] Schema up to date (%d migrations applied)",
            Sys.time(), result$total_applied
          ))
        }

        migration_status <<- list(
          pending_migrations = 0,
          total_migrations = result$total_applied,
          last_run = Sys.time(),
          newly_applied = result$newly_applied,
          filenames = result$filenames,
          fast_path = FALSE,
          lock_acquired = TRUE
        )
      }
    }
  },
  error = function(e) {
    message(sprintf("[%s] FATAL: Migration failed - %s", Sys.time(), e$message))

    # Record failure state for health endpoint
    migration_status <<- list(
      pending_migrations = NA,
      total_migrations = NA,
      last_run = Sys.time(),
      newly_applied = 0,
      filenames = character(0),
      fast_path = FALSE,
      lock_acquired = FALSE,
      error = e$message
    )

    # Crash API - forces fix before deploy
    stop(paste("API startup aborted: migration failure -", e$message))
  }
)
```

Key changes from current implementation:
- Check `get_pending_migrations()` BEFORE acquiring lock
- If empty, skip lock entirely (fast path)
- If pending, acquire lock, then re-check (double-check)
- Track `fast_path` and `lock_acquired` in global status
- Handle race condition where another container migrated while waiting
  </action>
  <verify>
Run `make lint-api` to check for R syntax/style issues. Verify the migration-runner.R file has get_pending_migrations exported.
  </verify>
  <done>
Section 7.5 in start_sysndd_api.R implements double-checked locking:
1. Fast path check before lock acquisition
2. Lock acquired only when migrations pending
3. Re-check after lock for race condition handling
4. migration_status includes fast_path and lock_acquired fields
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance health endpoint with migration lock status</name>
  <files>
    api/endpoints/health_endpoints.R
  </files>
  <action>
Enhance the `/health/ready` endpoint to report additional migration coordination details.

**Update the migrations_ok check and migration_info extraction:**

```r
# Check migration status (variable set during API startup)
migrations_ok <- FALSE
migration_info <- list(pending = NA, applied = NA, fast_path = NA, lock_acquired = NA)

if (exists("migration_status", where = .GlobalEnv) &&
  !is.null(.GlobalEnv$migration_status)) {
  status <- .GlobalEnv$migration_status
  pending <- status$pending_migrations

  # Check if startup had an error
  if (!is.null(status$error)) {
    migrations_ok <- FALSE
  } else {
    migrations_ok <- !is.null(pending) && !is.na(pending) && pending == 0
  }

  migration_info <- list(
    pending = if (is.null(pending) || is.na(pending)) NA else pending,
    applied = if (is.null(status$total_migrations)) NA else status$total_migrations,
    fast_path = if (is.null(status$fast_path)) NA else status$fast_path,
    lock_acquired = if (is.null(status$lock_acquired)) NA else status$lock_acquired
  )
}
```

**Add a helper function to check current lock status (for debugging):**

Add this function near the top of health_endpoints.R:

```r
#' Check current migration lock status
#'
#' Queries MySQL to check if the migration advisory lock is currently held.
#' Used by health endpoint to report coordination state.
#'
#' @return List with locked (boolean) and holder (connection_id or NULL)
#'
#' @keywords internal
check_migration_lock_status <- function() {
  tryCatch(
    {
      result <- db_execute_query("SELECT IS_USED_LOCK('sysndd_migration') AS holder")

      if (is.null(result$holder) || is.na(result$holder)) {
        list(locked = FALSE, holder = NULL)
      } else {
        list(locked = TRUE, holder = as.integer(result$holder))
      }
    },
    error = function(e) {
      list(locked = NA, error = e$message)
    }
  )
}
```

**Update the healthy response to include lock status:**

In the healthy response block:
```r
if (db_ok && migrations_ok) {
  # Check current lock status (for debugging parallel startup issues)
  lock_status <- check_migration_lock_status()

  list(
    status = "healthy",
    database = "connected",
    migrations = list(
      pending = migration_info$pending,
      applied = migration_info$applied,
      startup = list(
        fast_path = migration_info$fast_path,
        lock_acquired = migration_info$lock_acquired
      ),
      lock = lock_status
    ),
    pool = pool_stats,
    timestamp = timestamp
  )
}
```

**Update the unhealthy response similarly:**

```r
} else {
  res$status <- 503L

  # Determine reason for unhealthy status
  reason <- if (!db_ok) {
    "database_unavailable"
  } else if (exists("migration_status", where = .GlobalEnv) &&
             !is.null(.GlobalEnv$migration_status$error)) {
    "migration_error"
  } else {
    "migrations_pending"
  }

  lock_status <- tryCatch(check_migration_lock_status(), error = function(e) list(locked = NA))

  list(
    status = "unhealthy",
    reason = reason,
    database = if (db_ok) "connected" else "disconnected",
    migrations = list(
      pending = migration_info$pending,
      applied = migration_info$applied,
      startup = list(
        fast_path = migration_info$fast_path,
        lock_acquired = migration_info$lock_acquired
      ),
      lock = lock_status,
      error = if (exists("migration_status", where = .GlobalEnv)) .GlobalEnv$migration_status$error else NULL
    ),
    pool = pool_stats,
    timestamp = timestamp
  )
}
```
  </action>
  <verify>
Run `make lint-api` to verify R syntax. The `/health/ready` endpoint should return JSON with the new structure including `migrations.startup.fast_path` and `migrations.lock` fields.
  </verify>
  <done>
Health endpoint `/health/ready` returns:
- `migrations.startup.fast_path`: true if container skipped lock
- `migrations.startup.lock_acquired`: true if container acquired lock
- `migrations.lock.locked`: current lock status (for debugging)
- `migrations.lock.holder`: connection ID if lock is held
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Lint check:**
   ```bash
   make lint-api
   ```
   Expect: 0 linting errors

2. **Startup logging (dev environment):**
   ```bash
   make docker-dev-db && sleep 5 && cd api && Rscript start_sysndd_api.R
   ```
   Watch for: `Fast path: schema up to date, no lock needed` message (since schema is current)

3. **Health endpoint structure:**
   ```bash
   curl -s http://localhost:3000/api/health/ready | jq '.migrations'
   ```
   Expect: Response includes `startup.fast_path`, `startup.lock_acquired`, and `lock.locked` fields

4. **Code review checklist:**
   - [ ] `get_pending_migrations()` is exported in migration-runner.R
   - [ ] Section 7.5 checks pending before lock
   - [ ] Section 7.5 re-checks pending after lock
   - [ ] `migration_status` has `fast_path` and `lock_acquired` fields
   - [ ] Health endpoint reads new fields correctly
</verification>

<success_criteria>
- `get_pending_migrations()` helper exists and is exported
- Startup sequence implements double-checked locking (check before lock, re-check after)
- `migration_status` global includes `fast_path` and `lock_acquired` fields
- Health endpoint `/health/ready` reports startup behavior and current lock status
- All linting passes (`make lint-api` returns 0)
- Container logs show "Fast path" message when schema is current
</success_criteria>

<output>
After completion, create `.planning/phases/67-migration-coordination/67-01-SUMMARY.md`
</output>
