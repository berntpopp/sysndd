---
phase: 19-security-hardening
plan: 04
type: execute
wave: 3
depends_on: ["19-01", "19-02", "19-03"]
files_modified:
  - api/start_sysndd_api.R
  - api/functions/logging-functions.R
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Error handler middleware returns RFC 9457 format for all errors"
    - "Classed errors (error_400, error_401, etc.) return correct HTTP status codes"
    - "Unhandled exceptions return 500 without exposing internal details"
    - "Logs are sanitized - no passwords, tokens, or sensitive data in logs"
    - "postroute hook uses sanitize_request before logging"
  artifacts:
    - path: "api/start_sysndd_api.R"
      provides: "Error handler middleware (pr_set_error) and sanitized logging"
      contains: "pr_set_error"
    - path: "api/functions/logging-functions.R"
      provides: "Sanitized log_message_to_db function"
      contains: "sanitize_"
  key_links:
    - from: "api/start_sysndd_api.R"
      to: "api/core/errors.R"
      via: "source"
      pattern: "source.*core/errors\\.R"
    - from: "api/start_sysndd_api.R"
      to: "api/core/logging_sanitizer.R"
      via: "source"
      pattern: "source.*core/logging_sanitizer\\.R"
---

<objective>
Integrate error handler middleware and log sanitization into the main API entry point.

Purpose: Install the RFC 9457 error handler middleware using pr_set_error, and ensure all logging sanitizes sensitive data before writing to files/database.

Output: start_sysndd_api.R with error handler middleware and sanitized logging; logging-functions.R with sanitization.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-security-hardening/19-RESEARCH.md
@.planning/phases/19-security-hardening/19-01-SUMMARY.md
@.planning/phases/19-security-hardening/19-02-SUMMARY.md
@.planning/phases/19-security-hardening/19-03-SUMMARY.md

# Files to modify
@api/start_sysndd_api.R
@api/functions/logging-functions.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add core module sources and error handler middleware to start_sysndd_api.R</name>
  <files>api/start_sysndd_api.R</files>
  <action>
**Add source statements for core modules after the existing function sources (around line ~118):**
```r
# Core security and error handling modules
source("core/security.R", local = TRUE)
source("core/errors.R", local = TRUE)
source("core/responses.R", local = TRUE)
source("core/logging_sanitizer.R", local = TRUE)
```

**Add httpproblems to library imports (around line ~27):**
```r
library(httpproblems)
```

**Create error handler function (before the root router creation, around line ~280):**
```r
#* @plumber
errorHandler <- function(req, res, err) {
  # Log all errors with sanitized request info (internal - full details)
  log_error(
    "API error",
    error_class = class(err)[1],
    error_message = conditionMessage(err),
    endpoint = req$PATH_INFO,
    request = sanitize_request(req)
  )

  # Handle HTTP problem errors (from httpproblems package)
  if (inherits(err, "http_problem_error")) {
    res$status <- err$status
    res$serializer <- plumber::serializer_unboxed_json()
    res$setHeader("Content-Type", "application/problem+json")
    return(err)
  }

  # Handle custom classed errors from core/errors.R
  if (inherits(err, "error_400")) {
    res$status <- 400
    res$serializer <- plumber::serializer_unboxed_json()
    res$setHeader("Content-Type", "application/problem+json")
    return(bad_request(detail = conditionMessage(err)))
  }

  if (inherits(err, "error_401")) {
    res$status <- 401
    res$serializer <- plumber::serializer_unboxed_json()
    res$setHeader("Content-Type", "application/problem+json")
    return(unauthorized(detail = conditionMessage(err)))
  }

  if (inherits(err, "error_403")) {
    res$status <- 403
    res$serializer <- plumber::serializer_unboxed_json()
    res$setHeader("Content-Type", "application/problem+json")
    return(forbidden(detail = conditionMessage(err)))
  }

  if (inherits(err, "error_404")) {
    res$status <- 404
    res$serializer <- plumber::serializer_unboxed_json()
    res$setHeader("Content-Type", "application/problem+json")
    return(not_found(detail = conditionMessage(err)))
  }

  # Unhandled exception = 500 Internal Server Error
  # Don't expose internal details to client
  res$status <- 500
  res$serializer <- plumber::serializer_unboxed_json()
  res$setHeader("Content-Type", "application/problem+json")
  return(internal_server_error(detail = "An unexpected error occurred"))
}
```

**Add pr_set_error to the root router chain (after pr() and before pr_set_api_spec):**
```r
root <- pr() %>%
  pr_set_error(errorHandler) %>%
  pr_set_api_spec(function(spec) {
    # ... existing spec configuration
  }) %>%
  # ... rest of chain
```
  </action>
  <verify>
start_sysndd_api.R sources core/security.R, core/errors.R, core/responses.R, core/logging_sanitizer.R
library(httpproblems) is in the imports
errorHandler function exists
pr_set_error(errorHandler) is in the router chain
  </verify>
  <done>
Error handler middleware is installed and returns RFC 9457 format for all error types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Sanitize logging in postroute hook and logging-functions.R</name>
  <files>api/start_sysndd_api.R, api/functions/logging-functions.R</files>
  <action>
**Update postroute hook in start_sysndd_api.R (around line ~363-398):**

The current postroute logs req$postBody which may contain passwords. Update to sanitize:

```r
pr_hook("postroute", function(req, res) {
    end <- tictoc::toc(quiet = TRUE)

    # Sanitize the request before logging
    safe_req <- sanitize_request(req)

    # For postBody, extract and sanitize if present
    safe_post_body <- if (!is.null(req$postBody) && nchar(req$postBody) > 0) {
      tryCatch({
        body_parsed <- jsonlite::fromJSON(req$postBody, simplifyVector = FALSE)
        body_sanitized <- sanitize_object(body_parsed)
        jsonlite::toJSON(body_sanitized, auto_unbox = TRUE)
      }, error = function(e) {
        "[PARSE_ERROR]"
      })
    } else {
      convert_empty(req$postBody)
    }

    log_entry <- paste(
      convert_empty(req$REMOTE_ADDR),
      convert_empty(req$HTTP_USER_AGENT),
      convert_empty(req$HTTP_HOST),
      convert_empty(req$REQUEST_METHOD),
      convert_empty(req$PATH_INFO),
      convert_empty(req$QUERY_STRING),
      safe_post_body,  # Use sanitized version
      convert_empty(res$status),
      round(end$toc - end$tic, digits = getOption("digits", 5)),
      sep = ";",
      collapse = ""
    )
    log_info(skip_formatter(log_entry))

    # Write log entry to DB with sanitized data
    log_message_to_db(
      address         = convert_empty(req$REMOTE_ADDR),
      agent           = convert_empty(req$HTTP_USER_AGENT),
      host            = convert_empty(req$HTTP_HOST),
      request_method  = convert_empty(req$REQUEST_METHOD),
      path            = convert_empty(req$PATH_INFO),
      query           = convert_empty(req$QUERY_STRING),
      post            = safe_post_body,  # Use sanitized version
      status          = convert_empty(res$status),
      duration        = round(end$toc - end$tic, digits = getOption("digits", 5)),
      file            = logging_temp_file,
      modified        = Sys.time()
    )
  })
```

**Update logging-functions.R:**

Read the current logging-functions.R and ensure log_message_to_db doesn't log raw sensitive data. If the function receives already-sanitized data from start_sysndd_api.R (as we do above), it should be fine. But add a safety check if the function accepts body content directly.

If the function builds queries with paste0, convert to parameterized queries as well.
  </action>
  <verify>
postroute hook uses sanitize_request and sanitize_object for postBody
safe_post_body is used instead of raw req$postBody
log_message_to_db receives sanitized data
grep for 'password' in log files would return "[REDACTED]" not actual passwords
  </verify>
  <done>
All logging sanitizes sensitive data - passwords, tokens, and authorization headers are redacted before writing to logs or database.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `grep 'pr_set_error' api/start_sysndd_api.R` returns matches
2. `grep 'sanitize_request' api/start_sysndd_api.R` returns matches (in postroute hook)
3. `grep 'source.*core/errors' api/start_sysndd_api.R` returns matches
4. Error handler returns RFC 9457 format (Content-Type: application/problem+json)
5. File parses without errors: `Rscript -e "source('api/start_sysndd_api.R')"`
</verification>

<success_criteria>
- Error handler middleware installed via pr_set_error
- All classed errors return correct HTTP status codes with RFC 9457 format
- Unhandled exceptions return 500 without exposing internal details
- postroute hook sanitizes request body before logging
- log_message_to_db receives sanitized data
- Logs contain "[REDACTED]" instead of actual passwords/tokens
</success_criteria>

<output>
After completion, create `.planning/phases/19-security-hardening/19-04-SUMMARY.md`
</output>
