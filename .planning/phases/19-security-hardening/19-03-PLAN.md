---
phase: 19-security-hardening
plan: 03
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - api/endpoints/user_endpoints.R
  - api/endpoints/authentication_endpoints.R
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User endpoints use parameterized queries for all SQL"
    - "Authentication uses verify_password from core/security.R"
    - "Plaintext passwords are upgraded to Argon2id on successful login"
    - "Password change endpoint supports both plaintext and hashed passwords"
    - "New user approval sets Argon2id-hashed passwords"
  artifacts:
    - path: "api/endpoints/user_endpoints.R"
      provides: "Secure user management with parameterized queries and password hashing"
      contains: "params = list("
    - path: "api/endpoints/authentication_endpoints.R"
      provides: "Secure authentication with progressive password migration"
      contains: "verify_password"
  key_links:
    - from: "api/endpoints/authentication_endpoints.R"
      to: "api/core/security.R"
      via: "source"
      pattern: "verify_password\\(|upgrade_password\\("
    - from: "api/endpoints/user_endpoints.R"
      to: "api/core/security.R"
      via: "source"
      pattern: "hash_password\\(|verify_password\\("
---

<objective>
Fix SQL injection vulnerabilities in user_endpoints.R and implement progressive password migration in authentication_endpoints.R.

Purpose: Secure user management endpoints with parameterized queries, implement Argon2id password hashing for new registrations, and enable progressive migration of existing plaintext passwords to Argon2id on login.

Output: Secure user_endpoints.R and authentication_endpoints.R with password hashing and parameterized queries.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-security-hardening/19-RESEARCH.md
@.planning/phases/19-security-hardening/19-01-SUMMARY.md

# Files to modify
@api/endpoints/user_endpoints.R
@api/endpoints/authentication_endpoints.R
@api/core/security.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix SQL injection in user_endpoints.R</name>
  <files>api/endpoints/user_endpoints.R</files>
  <action>
Add source statement at top of file to load core security modules:
```r
source("core/security.R", local = TRUE)
```

Fix all SQL injection vulnerabilities:

**Line ~180-203 (user approval - UPDATE statements):**
Convert three paste0 UPDATE statements:
```r
# Before
dbExecute(sysndd_db, paste0("UPDATE user SET approved = 1 WHERE user_id = ", user_id_approval, ";"))
dbExecute(sysndd_db, paste0("UPDATE user SET password = '", user_password, "' WHERE user_id = ", user_id_approval, ";"))
dbExecute(sysndd_db, paste0("UPDATE user SET abbreviation = '", user_initials, "' WHERE user_id = ", user_id_approval, ";"))

# After - combine into single UPDATE and use hash_password
hashed_password <- hash_password(user_password)
dbExecute(sysndd_db,
    "UPDATE user SET approved = 1, password = ?, abbreviation = ? WHERE user_id = ?",
    params = list(hashed_password, user_initials, user_id_approval))
```

**Line ~228-234 (user rejection - DELETE):**
```r
dbExecute(sysndd_db,
    "DELETE FROM user WHERE user_id = ?",
    params = list(user_id_approval))
```

**Line ~271-278 and ~297-304 (change role - UPDATE):**
```r
dbExecute(sysndd_db,
    "UPDATE user SET user_role = ? WHERE user_id = ?",
    params = list(role_assigned, user_id_role))
```

**Line ~478-486 (password update):**
Use hash_password before storing:
```r
hashed_new_password <- hash_password(new_pass_1)
dbExecute(sysndd_db,
    "UPDATE user SET password = ? WHERE user_id = ?",
    params = list(hashed_new_password, user_id_pass_change))
```

**Line ~542-550 (password reset date):**
```r
dbExecute(sysndd_db,
    "UPDATE user SET password_reset_date = ? WHERE user_id = ?",
    params = list(timestamp_request, user_id_from_email[1]))
```

**Line ~641-656 (password reset change):**
Use hash_password:
```r
hashed_new_password <- hash_password(new_pass_1)
dbExecute(sysndd_db,
    "UPDATE user SET password = ? WHERE user_id = ?",
    params = list(hashed_new_password, user_jwt$user_id))
dbExecute(sysndd_db,
    "UPDATE user SET password_reset_date = NULL WHERE user_id = ?",
    params = list(user_jwt$user_id))
```

**Line ~703 and ~713 (user delete):**
```r
exist_result <- dbGetQuery(sysndd_db,
    "SELECT COUNT(*) as count FROM user WHERE user_id = ?",
    params = list(user_id))
...
dbExecute(sysndd_db,
    "DELETE FROM user WHERE user_id = ?",
    params = list(user_id))
```

**Line ~794-848 (user update):**
The dynamic SET clause construction is complex. For each field, build parameterized version:
```r
# Build query with proper parameterization
fields_to_update <- names(user_details)[names(user_details) != "user_id"]
placeholders <- paste0(fields_to_update, " = ?", collapse = ", ")
query <- paste0("UPDATE user SET ", placeholders, " WHERE user_id = ?")
params <- c(as.list(user_details[fields_to_update]), list(user_details[["user_id"]]))
dbExecute(sysndd_db, query, params = params)
```
  </action>
  <verify>
grep for "paste0.*WHERE" in user_endpoints.R returns 0 matches
All dbExecute calls use params = list()
hash_password is called before storing passwords
  </verify>
  <done>
All SQL operations in user_endpoints.R use parameterized queries, and all password storage uses hash_password.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement progressive password migration in authentication_endpoints.R</name>
  <files>api/endpoints/authentication_endpoints.R</files>
  <action>
Add source statement at top of file:
```r
source("core/security.R", local = TRUE)
```

**Fix authentication endpoint (line ~134-182):**

The current code filters by password in the SQL query:
```r
filter(user_name == check_user & password == check_pass & approved == 1)
```

Change to:
1. Fetch user by username only (don't filter by password in query)
2. Use verify_password() from core/security.R
3. Call upgrade_password() if password was plaintext and verification succeeded

```r
# Fetch user by username only
user_filtered <- pool %>%
    tbl("user") %>%
    filter(user_name == check_user & approved == 1) %>%
    collect()

if (nrow(user_filtered) != 1) {
    res$status <- 401
    res$body <- "User or password wrong."
    return(res)
}

# Verify password (supports both plaintext and hashed)
authenticated <- verify_password(user_filtered$password[1], check_pass)

if (!authenticated) {
    res$status <- 401
    res$body <- "User or password wrong."
    return(res)
}

# Progressive password upgrade
if (needs_upgrade(user_filtered$password[1])) {
    upgrade_password(pool, user_filtered$user_id[1], check_pass)
}

# Remove password from user_filtered before creating JWT
user_filtered <- user_filtered %>%
    select(-password) %>%
    mutate(
        iat = as.numeric(Sys.time()),
        exp = as.numeric(Sys.time()) + dw$refresh
    )

# Continue with JWT creation...
```

**Also update old_pass_match check in user_endpoints.R line ~426:**
The password change endpoint needs to use verify_password:
```r
old_pass_match <- verify_password(user_table$password[1], old_pass)
```
  </action>
  <verify>
authentication_endpoints.R sources core/security.R
authenticate endpoint uses verify_password instead of SQL password comparison
upgrade_password is called after successful plaintext verification
user_endpoints.R line ~426 uses verify_password for old password check
  </verify>
  <done>
Authentication uses progressive password migration - plaintext passwords work and are automatically upgraded to Argon2id on successful login.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `grep -c 'paste0.*WHERE' api/endpoints/user_endpoints.R` returns 0
2. `grep 'verify_password' api/endpoints/authentication_endpoints.R` returns matches
3. `grep 'hash_password' api/endpoints/user_endpoints.R` returns matches
4. Both files parse without errors
5. Both files source core/security.R
</verification>

<success_criteria>
- All SQL injection patterns in user_endpoints.R fixed (3 total)
- Authentication endpoint uses verify_password for dual-hash support
- Progressive password migration implemented (upgrade on successful login)
- New passwords always stored as Argon2id hashes
- Password change endpoint supports both old plaintext and hashed passwords
- Code parses without syntax errors
</success_criteria>

<output>
After completion, create `.planning/phases/19-security-hardening/19-03-SUMMARY.md`
</output>
