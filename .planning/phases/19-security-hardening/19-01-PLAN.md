---
phase: 19-security-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/core/security.R
  - api/core/errors.R
  - api/core/responses.R
  - api/core/logging_sanitizer.R
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Password hashing functions exist and can hash/verify passwords"
    - "Error helpers create RFC 9457 compliant error objects"
    - "Response helpers create consistent success/error responses"
    - "Logging sanitizer removes sensitive fields from request objects"
  artifacts:
    - path: "api/core/security.R"
      provides: "Password hashing utilities (hash_password, verify_password, is_hashed, needs_upgrade, upgrade_password)"
      min_lines: 50
    - path: "api/core/errors.R"
      provides: "RFC 9457 error helpers (error_bad_request, error_unauthorized, error_forbidden, error_not_found, error_internal, stop_for_*)"
      min_lines: 60
    - path: "api/core/responses.R"
      provides: "Response builders (response_success, response_error)"
      min_lines: 30
    - path: "api/core/logging_sanitizer.R"
      provides: "Log sanitization (sanitize_request, sanitize_user, sanitize_object)"
      min_lines: 50
  key_links:
    - from: "api/core/security.R"
      to: "sodium::password_store"
      via: "library import"
      pattern: "sodium::password_store"
    - from: "api/core/errors.R"
      to: "httpproblems"
      via: "library import"
      pattern: "library\\(httpproblems\\)"
---

<objective>
Create the core security infrastructure modules for Phase 19 Security Hardening.

Purpose: Establish reusable security utilities (password hashing, error handling, response builders, log sanitization) that will be used across all endpoint files. These modules follow DRY principles and provide consistent security patterns.

Output: Four new files in api/core/ directory providing foundational security infrastructure.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-security-hardening/19-RESEARCH.md

# Existing API structure
@api/start_sysndd_api.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create api/core/ directory and security.R with Argon2id password utilities</name>
  <files>api/core/security.R</files>
  <action>
Create the api/core/ directory if it doesn't exist.

Create api/core/security.R with password hashing utilities following the research patterns:

1. `is_hashed(password_from_db)` - Check if password is Argon2id hashed (starts with `$argon2`)
2. `hash_password(password)` - Hash password using `sodium::password_store()`
3. `verify_password(password_from_db, password_attempt)` - Verify password supporting both plaintext and hashed
4. `needs_upgrade(password_from_db)` - Returns TRUE if password is plaintext (needs upgrade)
5. `upgrade_password(pool, user_id, password_plaintext)` - Upgrade plaintext password to Argon2id in database

Include proper roxygen documentation. Use tryCatch for error handling in verify_password to handle malformed hashes. Use parameterized queries with dbExecute for the upgrade_password function.

DO NOT use string concatenation for SQL - use params list with `?` placeholders.
  </action>
  <verify>
File exists at api/core/security.R
Contains functions: is_hashed, hash_password, verify_password, needs_upgrade, upgrade_password
Uses sodium::password_store and sodium::password_verify
Uses parameterized query in upgrade_password (params = list())
  </verify>
  <done>
api/core/security.R contains all 5 password utility functions with proper documentation, sodium integration, and parameterized queries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create api/core/errors.R with RFC 9457 error helpers</name>
  <files>api/core/errors.R</files>
  <action>
Create api/core/errors.R with RFC 9457 (Problem Details) error helpers:

1. Error condition constructors:
   - `error_bad_request(message, detail)` - 400 Bad Request
   - `error_unauthorized(message, detail)` - 401 Unauthorized
   - `error_forbidden(message, detail)` - 403 Forbidden
   - `error_not_found(message, detail)` - 404 Not Found
   - `error_internal(message, detail)` - 500 Internal Server Error

2. Convenience stop functions:
   - `stop_for_bad_request(message, detail)`
   - `stop_for_unauthorized(message, detail)`
   - `stop_for_forbidden(message, detail)`
   - `stop_for_not_found(message, detail)`

Use httpproblems package functions (bad_request, unauthorized, forbidden, not_found, internal_server_error). Add custom classes (error_400, error_401, etc.) for the error handler to detect.

Follow the pattern from 19-RESEARCH.md exactly. Include roxygen documentation.
  </action>
  <verify>
File exists at api/core/errors.R
Contains error constructor functions for 400, 401, 403, 404, 500
Contains stop_for_* convenience functions
Uses httpproblems package
  </verify>
  <done>
api/core/errors.R contains RFC 9457 compliant error helpers with httpproblems integration and classed error conditions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create api/core/responses.R and api/core/logging_sanitizer.R</name>
  <files>api/core/responses.R, api/core/logging_sanitizer.R</files>
  <action>
Create api/core/responses.R with response builder helpers:

1. `response_success(data, message)` - Build successful response with optional message
2. `response_error(message, status, detail)` - Build RFC 9457 compliant error object (fallback when not using httpproblems)

Create api/core/logging_sanitizer.R with log sanitization utilities:

1. Define SENSITIVE_FIELDS constant: password, old_pass, new_pass, new_pass_1, new_pass_2, token, jwt, api_key, secret, authorization

2. `sanitize_object(obj)` - Recursively sanitize sensitive fields in nested lists, replacing with "[REDACTED]"

3. `sanitize_request(req)` - Sanitize Plumber request object:
   - Keep safe fields: PATH_INFO, REQUEST_METHOD, QUERY_STRING, REMOTE_ADDR
   - Sanitize headers (especially Authorization)
   - Sanitize args and body

4. `sanitize_user(user)` - Sanitize user data (data.frame or list)

Follow patterns from 19-RESEARCH.md. Include roxygen documentation.
  </action>
  <verify>
Files exist at api/core/responses.R and api/core/logging_sanitizer.R
responses.R contains response_success and response_error functions
logging_sanitizer.R contains SENSITIVE_FIELDS, sanitize_object, sanitize_request, sanitize_user
  </verify>
  <done>
api/core/responses.R and api/core/logging_sanitizer.R contain all response builder and log sanitization utilities.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. All 4 files exist in api/core/ directory
2. Each file has proper roxygen documentation
3. security.R uses sodium package for Argon2id
4. errors.R uses httpproblems package
5. No syntax errors: `Rscript -e "source('api/core/security.R'); source('api/core/errors.R'); source('api/core/responses.R'); source('api/core/logging_sanitizer.R')"`
</verification>

<success_criteria>
- api/core/ directory exists with 4 new R files
- security.R provides complete password hashing utilities with Argon2id via sodium
- errors.R provides RFC 9457 compliant error helpers via httpproblems
- responses.R provides consistent response builder functions
- logging_sanitizer.R provides request/user/object sanitization for secure logging
- All functions have roxygen documentation
- No SQL injection in any utility functions (parameterized queries only)
</success_criteria>

<output>
After completion, create `.planning/phases/19-security-hardening/19-01-SUMMARY.md`
</output>
