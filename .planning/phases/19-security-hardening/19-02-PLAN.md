---
phase: 19-security-hardening
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - api/functions/database-functions.R
autonomous: true
user_setup: []

must_haves:
  truths:
    - "All SQL queries in database-functions.R use parameterized queries (dbBind or params=list())"
    - "No paste0/paste concatenation with user input for SQL WHERE/SET clauses"
    - "Database operations continue to work correctly after conversion"
  artifacts:
    - path: "api/functions/database-functions.R"
      provides: "Secure database operations with parameterized queries"
      contains: "params = list("
  key_links:
    - from: "api/functions/database-functions.R"
      to: "dbExecute"
      via: "parameterized query"
      pattern: "dbExecute.*params\\s*="
---

<objective>
Fix all SQL injection vulnerabilities in database-functions.R by converting paste0/paste SQL concatenation to parameterized queries.

Purpose: Eliminate the 22 SQL injection vulnerabilities identified in database-functions.R by using dbBind or params=list() for all user-provided values.

Output: database-functions.R with all queries converted to parameterized format.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-security-hardening/19-RESEARCH.md
@.planning/phases/19-security-hardening/19-01-SUMMARY.md

# File to modify
@api/functions/database-functions.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix SQL injection in put_db_entity_deactivation and put_post_db_review</name>
  <files>api/functions/database-functions.R</files>
  <action>
Fix SQL injection vulnerabilities in these functions:

**put_db_entity_deactivation (line ~145):**
Convert:
```r
dbExecute(sysndd_db, paste0("UPDATE ndd_entity SET ",
    "is_active = 0, ",
    "replaced_by = ",
    replacement,
    " WHERE entity_id = ",
    entity_id,
    ";"))
```
To:
```r
dbExecute(sysndd_db,
    "UPDATE ndd_entity SET is_active = 0, replaced_by = ? WHERE entity_id = ?",
    params = list(replacement, entity_id))
```

**put_post_db_review (lines ~252, ~297, ~306, ~314):**
For each dbExecute with paste0:
- Line ~252: UPDATE re_review_entity_connect - convert to params
- Line ~297: UPDATE ndd_entity_review SET update_query - for dynamic columns, use dbQuoteIdentifier for column names, params for values
- Line ~306: UPDATE ndd_entity_review SET review_approved - convert to params
- Line ~314: UPDATE ndd_entity_review SET approving_user_id - convert to params

For the dynamic update_query construction (line ~276-284), the pattern builds SET clause from column names. Since these column names come from the code itself (not user input), this is safe. But the values need parameterization.

Refactor the update_query pattern to:
1. Build column list from colnames (safe - internal)
2. Use params = list() for the actual values
  </action>
  <verify>
grep for "paste0.*WHERE" in database-functions.R returns 0 matches for lines 100-350
dbExecute calls in these functions use params = list()
  </verify>
  <done>
put_db_entity_deactivation and put_post_db_review use parameterized queries for all user-provided values.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix SQL injection in put_post_db_pub_con, put_post_db_phen_con, put_post_db_var_ont_con</name>
  <files>api/functions/database-functions.R</files>
  <action>
Fix SQL injection vulnerabilities in these functions:

**put_post_db_pub_con (line ~440):**
Convert:
```r
dbExecute(sysndd_db,
    paste0("DELETE FROM ndd_review_publication_join WHERE review_id = ",
    review_id,
    ";"))
```
To:
```r
dbExecute(sysndd_db,
    "DELETE FROM ndd_review_publication_join WHERE review_id = ?",
    params = list(review_id))
```

**put_post_db_phen_con (line ~564):**
Convert the DELETE statement similarly:
```r
dbExecute(sysndd_db,
    "DELETE FROM ndd_review_phenotype_connect WHERE review_id = ?",
    params = list(review_id))
```

**put_post_db_var_ont_con (line ~691):**
Convert the DELETE statement similarly:
```r
dbExecute(sysndd_db,
    "DELETE FROM ndd_review_variation_ontology_connect WHERE review_id = ?",
    params = list(review_id))
```
  </action>
  <verify>
grep for "paste0.*DELETE" in database-functions.R returns 0 matches
All DELETE statements use params = list()
  </verify>
  <done>
All DELETE operations in publication, phenotype, and variation ontology functions use parameterized queries.
  </done>
</task>

<task type="auto">
  <name>Task 3: Fix SQL injection in put_post_db_status, put_db_review_approve, put_db_status_approve</name>
  <files>api/functions/database-functions.R</files>
  <action>
Fix SQL injection vulnerabilities in these functions:

**put_post_db_status (lines ~797, ~848):**
- Line ~797: UPDATE re_review_entity_connect - use params
- Line ~848: UPDATE ndd_entity_status SET update_query - similar to put_post_db_review, build column names from code, parameterize values

**put_db_review_approve (lines ~1055-1095):**
These use str_c to build IN clauses with IDs. For IN clauses with multiple values:
- Option A: Use glue_sql with .con parameter
- Option B: Build parameterized query dynamically with correct number of placeholders

For these approval functions, the IDs come from internal database queries (not user input), so the risk is lower. However, best practice is still to parameterize.

Convert patterns like:
```r
dbExecute(sysndd_db, paste0("UPDATE ndd_entity_review SET is_primary = 0 ",
    "WHERE entity_id IN (",
    str_c(ndd_entity_review_data$entity_id, collapse = ", "),
    ");"))
```
To use glue_sql or build a parameterized IN clause. For simplicity with RMariaDB:
```r
# Build placeholder string for N values
n <- length(ndd_entity_review_data$entity_id)
placeholders <- paste(rep("?", n), collapse = ", ")
query <- paste0("UPDATE ndd_entity_review SET is_primary = 0 WHERE entity_id IN (", placeholders, ")")
dbExecute(sysndd_db, query, params = as.list(ndd_entity_review_data$entity_id))
```

Apply same pattern to all approval function dbExecute calls.

**put_db_status_approve (lines ~1177-1217):**
Apply same parameterization patterns as put_db_review_approve.
  </action>
  <verify>
grep for "paste0.*UPDATE.*WHERE" in database-functions.R returns 0 matches
All UPDATE statements use params = list() or parameterized IN clauses
Functions still work correctly (no syntax errors)
  </verify>
  <done>
All UPDATE operations in status and approval functions use parameterized queries.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `grep -c 'paste0.*WHERE\|paste0.*SET' api/functions/database-functions.R` returns 0
2. `grep -c 'params = list' api/functions/database-functions.R` returns at least 15 matches
3. File still parses: `Rscript -e "source('api/functions/database-functions.R')"`
</verification>

<success_criteria>
- All 22 SQL injection patterns in database-functions.R converted to parameterized queries
- No paste0/paste concatenation with WHERE or SET clauses containing variables
- All dbExecute calls use params = list() for user-provided values
- Code parses without syntax errors
- Existing function signatures unchanged (backward compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/19-security-hardening/19-02-SUMMARY.md`
</output>
