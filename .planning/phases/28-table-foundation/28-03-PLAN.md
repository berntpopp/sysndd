---
phase: 28-table-foundation
plan: 03
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - app/src/views/admin/ManageOntology.vue
autonomous: true

must_haves:
  truths:
    - "Admin can search ontology terms by name, ID, or definition with instant results (300ms debounce)"
    - "Admin can filter ontology by active/inactive status"
    - "Admin can filter ontology by obsolete/non-obsolete status"
    - "Admin can paginate through ontology with page size control (10/25/50/100)"
    - "Admin can bookmark filtered/sorted ontology table state via URL (refresh preserves state)"
    - "Admin can export current filtered ontology data to Excel/CSV"
    - "Result count visible: 'Showing 1-20 of 45 terms'"
  artifacts:
    - path: "app/src/views/admin/ManageOntology.vue"
      provides: "Modernized ontology management table with TablesEntities pattern"
      min_lines: 400
  key_links:
    - from: "app/src/views/admin/ManageOntology.vue"
      to: "/api/ontology/variant/table"
      via: "axios GET with filter/sort/pagination params"
      pattern: "api/ontology/variant/table"
    - from: "app/src/views/admin/ManageOntology.vue"
      to: "history.replaceState"
      via: "URL state sync after API success"
      pattern: "history\\.replaceState"
    - from: "app/src/views/admin/ManageOntology.vue"
      to: "useExcelExport"
      via: "composable import for CSV export"
      pattern: "useExcelExport"
---

<objective>
Modernize ManageOntology.vue with the TablesEntities pattern for search, pagination, filtering, and URL state sync.

Purpose: Transform the basic ontology table into a modern, feature-rich management interface matching the established Entities table UX.

Output: A fully modernized ManageOntology.vue with search, status filters, pagination, URL sync, and CSV export.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-table-foundation/28-RESEARCH.md
@.planning/phases/28-table-foundation/28-01-SUMMARY.md
@app/src/components/tables/TablesEntities.vue (reference pattern)
@app/src/views/admin/ManageOntology.vue
@app/src/composables/useTableData.ts
@app/src/composables/useTableMethods.ts
@app/src/composables/useUrlParsing.ts
@app/src/composables/useExcelExport.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add search, filter, and pagination infrastructure</name>
  <files>app/src/views/admin/ManageOntology.vue</files>
  <action>
Transform ManageOntology.vue to use the TablesEntities pattern:

1. **Add module-level caching** (CRITICAL - prevents duplicate API calls on remount):
```javascript
// Module-level variables outside export default
let moduleLastApiParams = null;
let moduleApiCallInProgress = false;
let moduleLastApiCallTime = 0;
let moduleLastApiResponse = null;
```

2. **Add setup() composables**:
```javascript
import { ref, inject } from 'vue';
import { useToast, useUrlParsing, useTableData, useExcelExport } from '@/composables';

setup() {
  const { makeToast } = useToast();
  const { filterObjToStr, filterStrToObj, sortStringToVariables } = useUrlParsing();
  const { isExporting, exportToExcel } = useExcelExport();

  const tableData = useTableData({
    pageSizeInput: 25,
    sortInput: '+vario_id',
    pageAfterInput: '0',
  });

  // Filter object structure for ontology table
  const filter = ref({
    any: { content: null, join_char: null, operator: 'contains' },
    vario_id: { content: null, join_char: null, operator: 'contains' },
    vario_name: { content: null, join_char: null, operator: 'contains' },
    definition: { content: null, join_char: null, operator: 'contains' },
    obsolete: { content: null, join_char: null, operator: 'equals' },
    is_active: { content: null, join_char: null, operator: 'equals' },
  });

  const axios = inject('axios');

  return {
    ...tableData,
    filter,
    makeToast,
    filterObjToStr,
    filterStrToObj,
    sortStringToVariables,
    isExporting,
    exportToExcel,
    axios,
  };
}
```

3. **Add data() with isInitializing flag**:
```javascript
data() {
  return {
    isInitializing: true,
    loadDataDebounceTimer: null,
    totalPages: 0,
    ontologies: [],
    fields: [
      { key: 'vario_id', label: 'ID', sortable: true, filterable: true, class: 'text-start' },
      { key: 'vario_name', label: 'Name', sortable: true, filterable: true, class: 'text-start' },
      { key: 'definition', label: 'Definition', sortable: true, filterable: true, class: 'text-start' },
      { key: 'obsolete', label: 'Obsolete', sortable: true, selectable: true, class: 'text-center' },
      { key: 'is_active', label: 'Active', sortable: true, selectable: true, class: 'text-center' },
      { key: 'sort', label: 'Sort', sortable: true, class: 'text-center' },
      { key: 'update_date', label: 'Updated', sortable: true, class: 'text-start' },
      { key: 'actions', label: 'Actions', class: 'text-center' },
    ],
    ontologyToUpdate: {},
    updateOntologyModal: { id: 'update-ontology-modal', title: '', content: [] },
  };
}
```

4. **Add watchers with initialization guard**:
```javascript
watch: {
  filter: {
    handler() {
      if (this.isInitializing) return;
      this.filtered();
    },
    deep: true,
  },
  sortBy: {
    handler() {
      if (this.isInitializing) return;
      this.handleSortByOrDescChange();
    },
    deep: true,
  },
}
```

5. **Update mounted() for URL state initialization**:
```javascript
mounted() {
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.get('sort')) {
    const sort_object = this.sortStringToVariables(urlParams.get('sort'));
    this.sortBy = sort_object.sortBy;
    this.sort = urlParams.get('sort');
  }
  if (urlParams.get('filter')) {
    this.filter = this.filterStrToObj(urlParams.get('filter'), this.filter);
    this.filter_string = urlParams.get('filter');
  }
  if (urlParams.get('page_after')) {
    this.currentItemID = parseInt(urlParams.get('page_after'), 10) || 0;
  }
  if (urlParams.get('page_size')) {
    this.perPage = parseInt(urlParams.get('page_size'), 10) || 25;
  }

  this.$nextTick(() => {
    this.loadData();
    this.$nextTick(() => {
      this.isInitializing = false;
    });
  });
}
```

6. **Add loadData() with debouncing and module-level cache**:
```javascript
loadData() {
  if (this.loadDataDebounceTimer) {
    clearTimeout(this.loadDataDebounceTimer);
  }
  this.loadDataDebounceTimer = setTimeout(() => {
    this.loadDataDebounceTimer = null;
    this.doLoadData();
  }, 50);
},

async doLoadData() {
  const urlParam = `sort=${this.sort}&filter=${this.filter_string}&page_after=${this.currentItemID}&page_size=${this.perPage}`;
  const now = Date.now();

  if (moduleLastApiParams === urlParam && (now - moduleLastApiCallTime) < 500) {
    if (moduleLastApiResponse) {
      this.applyApiResponse(moduleLastApiResponse);
    }
    return;
  }

  if (moduleApiCallInProgress && moduleLastApiParams === urlParam) return;

  moduleLastApiParams = urlParam;
  moduleLastApiCallTime = now;
  moduleApiCallInProgress = true;
  this.isBusy = true;

  const apiUrl = `${import.meta.env.VITE_API_URL}/api/ontology/variant/table?${urlParam}`;

  try {
    const response = await this.axios.get(apiUrl, {
      headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
    });
    moduleApiCallInProgress = false;
    moduleLastApiResponse = response.data;
    this.applyApiResponse(response.data);
    this.updateBrowserUrl();
    this.isBusy = false;
  } catch (e) {
    moduleApiCallInProgress = false;
    this.makeToast(e, 'Error', 'danger');
    this.isBusy = false;
  }
}
```

7. **Add updateBrowserUrl() and helper methods**:
```javascript
updateBrowserUrl() {
  if (this.isInitializing) return;
  const searchParams = new URLSearchParams();
  if (this.sort) searchParams.set('sort', this.sort);
  if (this.filter_string) searchParams.set('filter', this.filter_string);
  if (this.currentItemID > 0) searchParams.set('page_after', String(this.currentItemID));
  searchParams.set('page_size', String(this.perPage));

  const newUrl = `${window.location.pathname}?${searchParams.toString()}`;
  window.history.replaceState({ ...window.history.state }, '', newUrl);
},

filtered() {
  const filter_string_loc = this.filterObjToStr(this.filter);
  if (filter_string_loc !== this.filter_string) {
    this.filter_string = filter_string_loc;
  }
  this.currentItemID = 0; // Reset to first page on filter change
  this.loadData();
},

handlePageChange(value) {
  if (value === 1) {
    this.currentItemID = 0;
  } else if (value === this.totalPages) {
    this.currentItemID = Number(this.lastItemID) || 0;
  } else if (value > this.currentPage) {
    this.currentItemID = Number(this.nextItemID) || 0;
  } else if (value < this.currentPage) {
    this.currentItemID = Number(this.prevItemID) || 0;
  }
  this.filtered();
},

handlePerPageChange(newPerPage) {
  this.perPage = parseInt(newPerPage, 10);
  this.currentItemID = 0;
  this.filtered();
},

handleSortByOrDescChange() {
  this.currentItemID = 0;
  const sortColumn = this.sortBy.length > 0 ? this.sortBy[0].key : '';
  const sortOrder = this.sortBy.length > 0 ? this.sortBy[0].order : 'asc';
  const isDesc = sortOrder === 'desc';
  this.sort = (isDesc ? '-' : '+') + sortColumn;
  this.filtered();
},

removeFilters() {
  Object.keys(this.filter).forEach((key) => {
    if (this.filter[key] && typeof this.filter[key] === 'object' && 'content' in this.filter[key]) {
      this.filter[key].content = null;
    }
  });
  this.filtered();
},

applyApiResponse(data) {
  this.ontologies = data.data;
  this.totalRows = data.meta[0].totalItems;
  this.$nextTick(() => {
    this.currentPage = data.meta[0].currentPage;
  });
  this.totalPages = data.meta[0].totalPages;
  this.prevItemID = Number(data.meta[0].prevItemID) || 0;
  this.currentItemID = Number(data.meta[0].currentItemID) || 0;
  this.nextItemID = Number(data.meta[0].nextItemID) || 0;
  this.lastItemID = Number(data.meta[0].lastItemID) || 0;
  this.executionTime = data.meta[0].executionTime;

  const uiStore = useUiStore();
  uiStore.requestScrollbarUpdate();
}
```
  </action>
  <verify>
```bash
cd /home/bernt-popp/development/sysndd/app
npm run build 2>&1 | grep -E "(error|Error)" || echo "Build successful"
```
  </verify>
  <done>ManageOntology.vue has search/filter/pagination infrastructure with module-level caching and URL sync</done>
</task>

<task type="auto">
  <name>Task 2: Add filter UI controls and export functionality</name>
  <files>app/src/views/admin/ManageOntology.vue</files>
  <action>
Add the filter UI and export to ManageOntology.vue template:

1. **Update template with header controls**:
```vue
<template>
  <div class="container-fluid">
    <BContainer fluid>
      <BRow class="justify-content-md-center py-2">
        <BCol md="12">
          <BCard header-tag="header" body-class="p-0" header-class="p-1" border-variant="dark">
            <template #header>
              <BRow>
                <BCol>
                  <h5 class="mb-1 text-start">
                    <strong>Manage Variation Ontology</strong>
                    <BBadge variant="secondary" class="ms-2">{{ totalRows }} terms</BBadge>
                  </h5>
                </BCol>
                <BCol class="text-end">
                  <BButton
                    v-b-tooltip.hover
                    size="sm"
                    class="me-1"
                    :variant="isExporting ? 'secondary' : 'outline-primary'"
                    :disabled="isExporting"
                    title="Export to Excel"
                    @click="handleExport"
                  >
                    <BSpinner v-if="isExporting" small />
                    <i v-else class="bi bi-file-earmark-excel" />
                  </BButton>
                  <BButton
                    v-b-tooltip.hover
                    size="sm"
                    :variant="removeFiltersButtonVariant"
                    :title="removeFiltersButtonTitle"
                    @click="removeFilters"
                  >
                    <i class="bi bi-funnel" />
                  </BButton>
                </BCol>
              </BRow>
            </template>

            <!-- Search and Pagination Row -->
            <BRow class="px-2 py-2">
              <BCol sm="8">
                <BInputGroup>
                  <template #prepend>
                    <BInputGroupText><i class="bi bi-search" /></BInputGroupText>
                  </template>
                  <BFormInput
                    v-model="filter.any.content"
                    placeholder="Search by ID, name, or definition..."
                    debounce="300"
                    type="search"
                    @update:model-value="filtered()"
                  />
                </BInputGroup>
              </BCol>
              <BCol sm="4">
                <BContainer v-if="totalRows > perPage">
                  <TablePaginationControls
                    :total-rows="totalRows"
                    :initial-per-page="perPage"
                    :page-options="pageOptions"
                    :current-page="currentPage"
                    @page-change="handlePageChange"
                    @per-page-change="handlePerPageChange"
                  />
                </BContainer>
              </BCol>
            </BRow>

            <!-- Filter Row -->
            <BRow class="px-2 pb-2">
              <BCol sm="3">
                <BFormSelect
                  v-model="filter.is_active.content"
                  :options="activeFilterOptions"
                  size="sm"
                  @update:model-value="filtered()"
                >
                  <template #first>
                    <BFormSelectOption :value="null">All Status</BFormSelectOption>
                  </template>
                </BFormSelect>
              </BCol>
              <BCol sm="3">
                <BFormSelect
                  v-model="filter.obsolete.content"
                  :options="obsoleteFilterOptions"
                  size="sm"
                  @update:model-value="filtered()"
                >
                  <template #first>
                    <BFormSelectOption :value="null">All Terms</BFormSelectOption>
                  </template>
                </BFormSelect>
              </BCol>
              <BCol sm="6" class="text-end">
                <span class="text-muted small">
                  Showing {{ totalRows > 0 ? (currentPage - 1) * perPage + 1 : 0 }}-{{ Math.min(currentPage * perPage, totalRows) }} of {{ totalRows }}
                </span>
              </BCol>
            </BRow>

            <!-- Active Filter Pills -->
            <BRow v-if="hasActiveFilters" class="px-2 pb-2">
              <BCol>
                <BBadge
                  v-for="(activeFilter, index) in activeFilters"
                  :key="index"
                  variant="secondary"
                  class="me-2 mb-1"
                >
                  {{ activeFilter.label }}: {{ activeFilter.value }}
                  <BButton
                    size="sm"
                    variant="link"
                    class="p-0 ms-1 text-light"
                    @click="clearFilter(activeFilter.key)"
                  >
                    <i class="bi bi-x" />
                  </BButton>
                </BBadge>
                <BButton size="sm" variant="link" class="p-0" @click="removeFilters">
                  Clear all
                </BButton>
              </BCol>
            </BRow>

            <!-- Table with loading overlay -->
            <div class="position-relative">
              <BSpinner
                v-if="isBusy"
                class="position-absolute top-50 start-50 translate-middle"
                variant="primary"
                style="z-index: 10;"
              />

              <!-- Empty state -->
              <div v-if="!isBusy && ontologies.length === 0" class="text-center py-4">
                <i class="bi bi-journal-text fs-1 text-muted" />
                <p class="text-muted mt-2">No ontology terms found matching your filters</p>
                <BButton v-if="hasActiveFilters" variant="link" @click="removeFilters">
                  Clear filters
                </BButton>
              </div>

              <GenericTable
                v-else
                :items="ontologies"
                :fields="fields"
                :sort-by="sortBy"
                :class="{ 'opacity-50': isBusy }"
                @update:sort-by="handleSortUpdate"
              >
                <!-- Existing action slot -->
                <template v-slot:cell-actions="{ row }">
                  <div>
                    <BButton
                      v-b-tooltip.hover.top
                      size="sm"
                      class="me-1 btn-xs"
                      title="Edit ontology"
                      @click="editOntology(row, $event.target)"
                    >
                      <i class="bi bi-pen" />
                    </BButton>
                  </div>
                </template>

                <!-- Format obsolete as badge -->
                <template v-slot:cell-obsolete="{ row }">
                  <BBadge :variant="row.obsolete ? 'warning' : 'success'">
                    {{ row.obsolete ? 'Yes' : 'No' }}
                  </BBadge>
                </template>

                <!-- Format is_active as badge -->
                <template v-slot:cell-is_active="{ row }">
                  <BBadge :variant="row.is_active ? 'success' : 'secondary'">
                    {{ row.is_active ? 'Active' : 'Inactive' }}
                  </BBadge>
                </template>
              </GenericTable>
            </div>
          </BCard>
        </BCol>
      </BRow>

      <!-- Keep existing update modal -->
      <BModal ...>
        <!-- existing modal content -->
      </BModal>
    </BContainer>
  </div>
</template>
```

2. **Add computed properties**:
```javascript
computed: {
  editableFields() {
    return this.fields.filter(
      (field) => field.key !== 'actions' && field.key !== 'vario_id' && field.key !== 'update_date',
    );
  },
  activeFilterOptions() {
    return [
      { value: '1', text: 'Active' },
      { value: '0', text: 'Inactive' },
    ];
  },
  obsoleteFilterOptions() {
    return [
      { value: '0', text: 'Current' },
      { value: '1', text: 'Obsolete' },
    ];
  },
  hasActiveFilters() {
    return Object.values(this.filter).some(f => f.content !== null && f.content !== '');
  },
  activeFilters() {
    const filters = [];
    if (this.filter.any.content) {
      filters.push({ key: 'any', label: 'Search', value: this.filter.any.content });
    }
    if (this.filter.is_active.content !== null) {
      filters.push({ key: 'is_active', label: 'Status', value: this.filter.is_active.content === '1' ? 'Active' : 'Inactive' });
    }
    if (this.filter.obsolete.content !== null) {
      filters.push({ key: 'obsolete', label: 'Terms', value: this.filter.obsolete.content === '1' ? 'Obsolete' : 'Current' });
    }
    return filters;
  },
}
```

3. **Add helper methods**:
```javascript
clearFilter(key) {
  if (this.filter[key]) {
    this.filter[key].content = null;
  }
  this.filtered();
},

handleSortUpdate(newSortBy) {
  this.sortBy = newSortBy;
  this.handleSortByOrDescChange();
},

handleExport() {
  this.exportToExcel(this.ontologies, {
    filename: `ontology_export_${new Date().toISOString().split('T')[0]}`,
    sheetName: 'Ontology',
    headers: {
      vario_id: 'Vario ID',
      vario_name: 'Name',
      definition: 'Definition',
      obsolete: 'Obsolete',
      is_active: 'Active',
      sort: 'Sort Order',
      update_date: 'Last Updated',
    },
  });
}
```

4. **Add component import**:
```javascript
import TablePaginationControls from '@/components/small/TablePaginationControls.vue';

// In components:
components: {
  GenericTable,
  TablePaginationControls,
},
```
  </action>
  <verify>
```bash
cd /home/bernt-popp/development/sysndd/app
npm run build 2>&1 | grep -E "(error|Error)" || echo "Build successful"
npm run lint -- --fix
```

Manual verification:
1. Search filters ontology by ID, name, definition
2. Active/Inactive filter works
3. Obsolete/Current filter works
4. Pagination controls work
5. Export downloads Excel file
6. Empty state shows when no results
7. URL updates on filter/sort changes
  </verify>
  <done>ManageOntology.vue is fully modernized with search, filters, pagination, URL sync, and CSV export</done>
</task>

</tasks>

<verification>
Build and lint:
```bash
cd /home/bernt-popp/development/sysndd/app
npm run build
npm run lint
```

Manual testing checklist:
- [ ] Search filters ontology by name, ID, definition
- [ ] Active status dropdown filter works
- [ ] Obsolete status dropdown filter works
- [ ] Pagination controls work (page size, navigation)
- [ ] URL updates reflect current filter/sort/pagination state
- [ ] Page refresh restores filter/sort/pagination from URL
- [ ] Export downloads Excel with current filtered data
- [ ] Loading spinner during data fetch
- [ ] Empty state when no results
- [ ] Active filter pills display and are removable
- [ ] Obsolete/Active badges display correctly
- [ ] Edit modal still works
</verification>

<success_criteria>
- [ ] ManageOntology.vue uses TablesEntities pattern (module-level caching, URL sync, debounced search)
- [ ] Search input with 300ms debounce filters across ID, name, definition
- [ ] Active/Inactive status filter works
- [ ] Obsolete/Current filter works
- [ ] Active filters displayed as removable pills
- [ ] Pagination controls (10/25/50/100 page size, navigation)
- [ ] URL state sync (filter, sort, page_after, page_size in URL)
- [ ] Browser back/forward navigation works
- [ ] CSV export with current filters
- [ ] Loading spinner during API calls
- [ ] Empty state when no results
- [ ] Result count displayed ("Showing 1-20 of 45 terms")
- [ ] Status badges (Active/Inactive, Obsolete/Current) display correctly
- [ ] Edit modal functionality preserved
- [ ] Build passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/28-table-foundation/28-03-SUMMARY.md`
</output>
