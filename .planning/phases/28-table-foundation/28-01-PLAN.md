---
phase: 28-table-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/endpoints/user_endpoints.R
  - api/endpoints/ontology_endpoints.R
autonomous: true

must_haves:
  truths:
    - "GET /api/user/table accepts filter, sort, page_after, page_size parameters"
    - "GET /api/user/table returns { data, meta, links } with totalItems, currentPage, totalPages"
    - "GET /api/ontology/variant/table accepts filter, sort, page_after, page_size parameters"
    - "GET /api/ontology/variant/table returns { data, meta, links } with totalItems, currentPage, totalPages"
    - "API returns filtered results when filter parameter contains valid filter string"
    - "API returns sorted results when sort parameter is +column or -column"
  artifacts:
    - path: "api/endpoints/user_endpoints.R"
      provides: "User table endpoint with pagination, filter, sort"
      contains: "generate_cursor_pag_inf_safe"
    - path: "api/endpoints/ontology_endpoints.R"
      provides: "Ontology table endpoint with pagination, filter, sort"
      contains: "generate_cursor_pag_inf_safe"
  key_links:
    - from: "api/endpoints/user_endpoints.R"
      to: "generate_cursor_pag_inf_safe"
      via: "pagination helper function"
      pattern: "generate_cursor_pag_inf_safe"
    - from: "api/endpoints/ontology_endpoints.R"
      to: "generate_cursor_pag_inf_safe"
      via: "pagination helper function"
      pattern: "generate_cursor_pag_inf_safe"
---

<objective>
Add pagination, filtering, and sorting support to user and ontology table API endpoints.

Purpose: Enable frontend tables to implement server-side pagination and search, matching the TablesEntities pattern already used for entity tables.

Output: Two API endpoints that accept filter/sort/pagination parameters and return consistent { data, meta, links } response format.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-table-foundation/28-RESEARCH.md
@api/endpoints/user_endpoints.R
@api/endpoints/ontology_endpoints.R
@api/endpoints/entity_endpoints.R (reference for filter/pagination pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance user table endpoint with filter and sort support</name>
  <files>api/endpoints/user_endpoints.R</files>
  <action>
Modify the GET /api/user/table endpoint to support filter and sort parameters:

1. Add parameters: `filter = ""`, `sort = "+user_id"` (matching entity endpoint pattern)

2. Implement filter parsing using existing `filter_parser_str` helper:
   - Searchable fields: user_name, email, orcid, abbreviation, first_name, family_name, user_role, comment, approved
   - Use "contains" operator for text fields
   - Use "equals" operator for approved field
   - Support "any" field for global search across all text columns

3. Implement sort parsing:
   - Parse sort string like "+user_name" or "-email"
   - Apply dplyr::arrange with desc() for minus prefix

4. Apply filtering BEFORE pagination using filter expressions:
   - Build filter expressions from parsed filter string
   - Use filter() with the built expressions

5. Keep existing role-based access logic:
   - Admin sees all users
   - Curator sees only unapproved users (add filter on top of user filter)

6. Return consistent response format:
```r
list(
  links = pagination_info$links,
  meta = pagination_info$meta,
  data = pagination_info$data
)
```

Reference entity_endpoints.R lines ~50-150 for filter/sort implementation pattern.
  </action>
  <verify>
```bash
# Test pagination with filter
curl -s "http://localhost:7777/api/user/table?filter=user_role:contains:Admin&page_size=10" \
  -H "Authorization: Bearer $TOKEN" | jq '.meta[0].totalItems'

# Test sort
curl -s "http://localhost:7777/api/user/table?sort=-email&page_size=5" \
  -H "Authorization: Bearer $TOKEN" | jq '.data[0].email'
```
  </verify>
  <done>User table endpoint accepts filter/sort/pagination params and returns { data, meta, links } format</done>
</task>

<task type="auto">
  <name>Task 2: Add pagination and filter support to ontology variant table endpoint</name>
  <files>api/endpoints/ontology_endpoints.R</files>
  <action>
Modify the GET /api/ontology/variant/table endpoint to support filter, sort, and pagination:

1. Add parameters: `filter = ""`, `sort = "+vario_id"`, `page_after = 0`, `page_size = "all"`

2. Implement filter parsing for ontology fields:
   - Searchable fields: vario_id, vario_name, definition, obsolete, is_active, sort (column name)
   - Use "contains" operator for text fields
   - Use "equals" operator for boolean fields (obsolete, is_active)
   - Support "any" field for global search

3. Implement sort parsing:
   - Parse sort string like "+vario_name" or "-update_date"
   - Apply dplyr::arrange with desc() for minus prefix
   - Default sort: "+vario_id"

4. Apply filtering BEFORE pagination:
   - Build filter expressions from parsed filter string
   - Use filter() with the built expressions

5. Apply pagination using generate_cursor_pag_inf_safe:
   - Primary key: vario_id (numeric)
   - Pass page_after and page_size parameters

6. Return consistent response format matching user/entity endpoints:
```r
list(
  links = pagination_info$links,
  meta = list(list(
    totalItems = nrow(filtered_data),
    currentPage = pagination_info$meta[[1]]$currentPage,
    totalPages = pagination_info$meta[[1]]$totalPages,
    prevItemID = pagination_info$meta[[1]]$prevItemID,
    currentItemID = pagination_info$meta[[1]]$currentItemID,
    nextItemID = pagination_info$meta[[1]]$nextItemID,
    lastItemID = pagination_info$meta[[1]]$lastItemID,
    executionTime = execution_time
  )),
  data = pagination_info$data
)
```

7. Add execution time tracking (start_time at function start, calculate at end).
  </action>
  <verify>
```bash
# Test pagination
curl -s "http://localhost:7777/api/ontology/variant/table?page_size=5" \
  -H "Authorization: Bearer $TOKEN" | jq '.meta[0].totalPages'

# Test filter
curl -s "http://localhost:7777/api/ontology/variant/table?filter=is_active:equals:1" \
  -H "Authorization: Bearer $TOKEN" | jq '.meta[0].totalItems'

# Test sort
curl -s "http://localhost:7777/api/ontology/variant/table?sort=-update_date&page_size=3" \
  -H "Authorization: Bearer $TOKEN" | jq '.data[0].vario_name'
```
  </verify>
  <done>Ontology table endpoint accepts filter/sort/pagination params and returns { data, meta, links } format</done>
</task>

<task type="auto">
  <name>Task 3: Add fspec parameter for column selection</name>
  <files>api/endpoints/user_endpoints.R, api/endpoints/ontology_endpoints.R</files>
  <action>
Add fspec (field specification) parameter to both endpoints for consistent column metadata:

1. For user table endpoint:
   - Add parameter: `fspec = "user_id,user_name,email,user_role,approved,abbreviation,first_name,family_name,comment,created_at"`
   - Parse fspec and build field metadata array with key, label, sortable, filterable, class
   - Include fspec in meta response (like entity endpoint does)

2. For ontology table endpoint:
   - Add parameter: `fspec = "vario_id,vario_name,definition,obsolete,is_active,sort,update_date"`
   - Parse fspec and build field metadata array
   - Include fspec in meta response

3. Field metadata format (matching entity endpoint):
```r
fspec_parsed <- list(
  list(key = "user_name", label = "User Name", sortable = TRUE, filterable = TRUE, class = "text-start"),
  list(key = "email", label = "E-mail", sortable = TRUE, filterable = TRUE, class = "text-start"),
  # ... etc
)
```

4. Add fspec to meta in response:
```r
meta = list(list(
  totalItems = ...,
  fspec = fspec_parsed,
  ...
))
```

This enables the frontend to dynamically build table columns from API response.
  </action>
  <verify>
```bash
# Check user endpoint returns fspec in meta
curl -s "http://localhost:7777/api/user/table?page_size=1" \
  -H "Authorization: Bearer $TOKEN" | jq '.meta[0].fspec | length'

# Check ontology endpoint returns fspec in meta
curl -s "http://localhost:7777/api/ontology/variant/table?page_size=1" \
  -H "Authorization: Bearer $TOKEN" | jq '.meta[0].fspec[0].key'
```
  </verify>
  <done>Both endpoints return fspec metadata for dynamic table column generation</done>
</task>

</tasks>

<verification>
Run API integration tests:
```bash
cd /home/bernt-popp/development/sysndd
make test-api
```

Manual verification:
1. User endpoint returns paginated data with filter working
2. Ontology endpoint returns paginated data with filter working
3. Both endpoints return { data, meta, links } structure
4. fspec included in meta for both endpoints
</verification>

<success_criteria>
- [ ] User table API accepts filter, sort, page_after, page_size parameters
- [ ] Ontology table API accepts filter, sort, page_after, page_size parameters
- [ ] Both APIs return consistent { data, meta, links } response format
- [ ] Filter parameter filters results server-side
- [ ] Sort parameter sorts results server-side (+column/-column format)
- [ ] Pagination works with cursor-based navigation (page_after ID)
- [ ] fspec metadata included in both endpoint responses
- [ ] Existing role-based access control preserved
</success_criteria>

<output>
After completion, create `.planning/phases/28-table-foundation/28-01-SUMMARY.md`
</output>
