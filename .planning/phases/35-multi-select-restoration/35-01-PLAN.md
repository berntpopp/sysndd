---
phase: 35-multi-select-restoration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/package.json
  - app/src/main.ts
  - app/src/composables/useTreeSearch.ts
  - app/src/composables/useHierarchyPath.ts
  - app/src/components/forms/TreeMultiSelect.vue
autonomous: true

must_haves:
  truths:
    - "User can browse hierarchical phenotype/variation lists with visual hierarchy"
    - "User can search items by name or code and see matches in ancestor context"
    - "User can select multiple items via checkboxes"
    - "User sees selected items as chips below the selector"
    - "User sees full hierarchy path when hovering over a chip"
  artifacts:
    - path: "app/src/composables/useTreeSearch.ts"
      provides: "Tree search filtering with ancestor preservation"
      exports: ["useTreeSearch"]
    - path: "app/src/composables/useHierarchyPath.ts"
      provides: "Hierarchy path computation for tooltips"
      exports: ["useHierarchyPath"]
    - path: "app/src/components/forms/TreeMultiSelect.vue"
      provides: "Reusable hierarchical multi-select wrapper"
      min_lines: 100
  key_links:
    - from: "app/src/components/forms/TreeMultiSelect.vue"
      to: "primevue/treeselect"
      via: "import TreeSelect"
      pattern: "import TreeSelect from 'primevue/treeselect'"
    - from: "app/src/main.ts"
      to: "primevue/config"
      via: "app.use(PrimeVue)"
      pattern: "app\\.use\\(PrimeVue"
---

<objective>
Create TreeMultiSelect component foundation with PrimeVue TreeSelect

Purpose: Establish reusable hierarchical multi-select pattern that will replace vue3-treeselect across all curation forms. Uses PrimeVue TreeSelect in unstyled mode with Bootstrap PT styling to maintain visual consistency.

Output:
- PrimeVue installed and configured
- useTreeSearch composable for filtering
- useHierarchyPath composable for tooltips
- TreeMultiSelect wrapper component
- Verified working with sample data and compound keys
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-multi-select-restoration/35-CONTEXT.md
@.planning/phases/35-multi-select-restoration/35-RESEARCH.md
@.planning/phases/35-multi-select-restoration/35-REQUIREMENTS.md

# Existing composables pattern
@app/src/composables/useToast.ts
@app/src/composables/index.ts

# Current main.ts for PrimeVue integration pattern
@app/src/main.ts

# Bootstrap-Vue-Next BFormTag usage pattern
@app/src/views/review/Review.vue (lines 659-713)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install and configure PrimeVue</name>
  <files>
    app/package.json
    app/src/main.ts
  </files>
  <action>
Install PrimeVue:
```bash
cd app && npm install primevue@^4.5.4
```

Update main.ts to configure PrimeVue in unstyled mode. Add AFTER createBootstrap() registration:
```typescript
import PrimeVue from 'primevue/config';

// Configure PrimeVue in unstyled mode (no CSS, use Bootstrap via PT)
app.use(PrimeVue, {
  unstyled: true
});
```

IMPORTANT: Do NOT import any PrimeVue CSS files. The unstyled mode means we style entirely via PT (pass-through) props with Bootstrap classes.
  </action>
  <verify>
Run `cd /home/bernt-popp/development/sysndd/app && npm ls primevue` shows version 4.5.4+
Verify main.ts has PrimeVue import and app.use() call with unstyled: true
  </verify>
  <done>
PrimeVue 4.5.4+ installed in package.json
main.ts configures PrimeVue with unstyled: true
No PrimeVue CSS imports present
  </done>
</task>

<task type="auto">
  <name>Task 2: Create tree composables</name>
  <files>
    app/src/composables/useTreeSearch.ts
    app/src/composables/useHierarchyPath.ts
    app/src/composables/index.ts
  </files>
  <action>
Create useTreeSearch.ts - filters tree in place while preserving ancestor context:
```typescript
import { computed, type Ref } from 'vue';

export interface TreeNode {
  id: string;
  label: string;
  children?: TreeNode[];
  [key: string]: unknown;
}

interface UseTreeSearchOptions {
  matchFields?: string[];
}

export function useTreeSearch(
  options: Ref<TreeNode[]>,
  query: Ref<string>,
  config: UseTreeSearchOptions = {}
) {
  const { matchFields = ['label', 'id'] } = config;

  const filteredOptions = computed(() => {
    if (!query.value || query.value.trim() === '') {
      return options.value;
    }

    const lowerQuery = query.value.toLowerCase();

    function filterNode(node: TreeNode): TreeNode | null {
      // Check if node matches any of the specified fields
      const nodeMatches = matchFields.some((field) => {
        const value = node[field];
        return (
          typeof value === 'string' &&
          value.toLowerCase().includes(lowerQuery)
        );
      });

      // Recursively filter children
      const filteredChildren = node.children
        ?.map(filterNode)
        .filter((n): n is TreeNode => n !== null);

      // Include node if it matches OR if any children match (preserves ancestor context)
      if (nodeMatches || (filteredChildren && filteredChildren.length > 0)) {
        return {
          ...node,
          children: filteredChildren,
        };
      }

      return null;
    }

    return options.value
      .map(filterNode)
      .filter((n): n is TreeNode => n !== null);
  });

  return { filteredOptions };
}
```

Create useHierarchyPath.ts - computes full path for tooltips with memoization:
```typescript
import { type Ref, watch } from 'vue';

export interface TreeNode {
  id: string;
  label: string;
  children?: TreeNode[];
}

export function useHierarchyPath(options: Ref<TreeNode[]>) {
  const pathCache = new Map<string, TreeNode[]>();

  function buildCache() {
    pathCache.clear();

    function traverse(nodes: TreeNode[], ancestors: TreeNode[] = []) {
      for (const node of nodes) {
        const path = [...ancestors, node];
        pathCache.set(node.id, path);

        if (node.children) {
          traverse(node.children, path);
        }
      }
    }

    traverse(options.value);
  }

  // Rebuild cache when options change
  watch(options, buildCache, { immediate: true, deep: true });

  function getPath(nodeId: string): TreeNode[] {
    return pathCache.get(nodeId) || [];
  }

  function getPathString(nodeId: string): string {
    return getPath(nodeId)
      .map((n) => n.label)
      .join(' > ');
  }

  return { getPath, getPathString };
}
```

Update composables/index.ts to export new composables (add to existing exports):
```typescript
export { useTreeSearch } from './useTreeSearch';
export { useHierarchyPath } from './useHierarchyPath';
```
  </action>
  <verify>
Files exist: app/src/composables/useTreeSearch.ts, app/src/composables/useHierarchyPath.ts
Run `cd /home/bernt-popp/development/sysndd/app && npm run type-check` passes without errors on new files
  </verify>
  <done>
useTreeSearch composable filters tree while preserving ancestors
useHierarchyPath composable computes and caches hierarchy paths
Both exported from composables/index.ts
TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Create TreeMultiSelect wrapper component</name>
  <files>
    app/src/components/forms/TreeMultiSelect.vue
  </files>
  <action>
Create forms directory if needed, then create TreeMultiSelect.vue:

```vue
<!-- components/forms/TreeMultiSelect.vue -->
<template>
  <div class="tree-multi-select">
    <!-- Search input -->
    <BInputGroup size="sm" class="mb-2">
      <BFormInput
        v-model="searchQuery"
        :placeholder="searchPlaceholder"
        aria-label="Search items"
        type="search"
      />
      <template #append>
        <BButton
          v-if="searchQuery"
          size="sm"
          variant="outline-secondary"
          aria-label="Clear search"
          @click="searchQuery = ''"
        >
          <i class="bi bi-x-lg" />
        </BButton>
      </template>
    </BInputGroup>

    <!-- PrimeVue TreeSelect with Bootstrap PT styling -->
    <TreeSelect
      v-model="internalValue"
      :options="filteredOptions"
      selection-mode="checkbox"
      :placeholder="placeholder"
      :disabled="disabled"
      :pt="{
        root: { class: 'form-control p-0 h-auto' },
        label: { class: 'form-control-sm border-0 bg-transparent' },
        dropdown: { class: 'btn btn-sm btn-outline-secondary border-0' },
        panel: { class: 'dropdown-menu show p-2 shadow-sm', style: 'max-height: 300px; overflow-y: auto; min-width: 100%;' },
        wrapper: { class: '' },
        tree: { class: 'list-unstyled mb-0' },
        node: { class: 'py-1' },
        checkbox: { class: 'form-check-input me-2' },
        nodeLabel: { class: 'small' },
        nodeToggleButton: { class: 'btn btn-link btn-sm p-0 me-1 text-decoration-none' },
        emptyMessage: { class: 'text-muted small p-2' }
      }"
      option-label="label"
      option-value="id"
      @update:model-value="handleChange"
    />

    <!-- Selected items as chips below the selector -->
    <div v-if="selectedItems.length > 0" class="mt-2 d-flex flex-wrap gap-1">
      <BFormTag
        v-for="item in selectedItems"
        :key="item.id"
        variant="secondary"
        v-b-tooltip.hover
        :title="getFullPath(item.id)"
        @remove="removeItem(item.id)"
      >
        {{ item.label }}
      </BFormTag>
    </div>

    <!-- Validation error -->
    <div v-if="error" class="invalid-feedback d-block mt-1">
      {{ error }}
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, ref, watch } from 'vue';
import TreeSelect from 'primevue/treeselect';
import { useTreeSearch, useHierarchyPath } from '@/composables';
import type { TreeNode } from '@/composables/useTreeSearch';

interface Props {
  modelValue: string[] | null;
  options: TreeNode[];
  placeholder?: string;
  searchPlaceholder?: string;
  error?: string;
  disabled?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  placeholder: 'Select items...',
  searchPlaceholder: 'Search...',
  error: '',
  disabled: false,
});

const emit = defineEmits<{
  (e: 'update:modelValue', value: string[]): void;
}>();

const searchQuery = ref('');

// PrimeVue TreeSelect uses object format for checkbox mode: { nodeId: { checked: true, partialChecked: false } }
// We need to convert between our string[] format and PrimeVue's object format
const internalValue = ref<Record<string, { checked: boolean; partialChecked: boolean }> | null>(null);

// Convert our string[] to PrimeVue format
watch(
  () => props.modelValue,
  (newValue) => {
    if (!newValue || newValue.length === 0) {
      internalValue.value = null;
      return;
    }
    const result: Record<string, { checked: boolean; partialChecked: boolean }> = {};
    for (const id of newValue) {
      result[id] = { checked: true, partialChecked: false };
    }
    internalValue.value = result;
  },
  { immediate: true }
);

// Search filtering - preserves ancestor context
const { filteredOptions } = useTreeSearch(
  computed(() => props.options),
  searchQuery,
  { matchFields: ['label', 'id'] } // Match both name and code (HP:0001250)
);

// Compute full hierarchy path for tooltips
const { getPathString } = useHierarchyPath(computed(() => props.options));

// Find selected nodes from tree
const selectedItems = computed(() => {
  if (!props.modelValue?.length) return [];
  return findNodesByIds(props.options, props.modelValue);
});

function getFullPath(itemId: string): string {
  return getPathString(itemId);
}

function handleChange(value: Record<string, { checked: boolean; partialChecked: boolean }> | null) {
  if (!value) {
    emit('update:modelValue', []);
    return;
  }
  // Extract only fully checked items (not partialChecked)
  const selectedIds = Object.entries(value)
    .filter(([_, state]) => state.checked && !state.partialChecked)
    .map(([id]) => id);
  emit('update:modelValue', selectedIds);
}

function removeItem(id: string) {
  const updated = props.modelValue?.filter((v) => v !== id) || [];
  emit('update:modelValue', updated);
}

function findNodesByIds(nodes: TreeNode[], ids: string[]): TreeNode[] {
  const result: TreeNode[] = [];

  function search(nodes: TreeNode[]) {
    for (const node of nodes) {
      if (ids.includes(node.id)) {
        result.push(node);
      }
      if (node.children) {
        search(node.children);
      }
    }
  }

  search(nodes);
  return result;
}
</script>

<style scoped>
/* Ensure dropdown panel displays correctly */
.tree-multi-select :deep(.p-treeselect-panel) {
  position: absolute;
  z-index: 1050;
}

/* Style the tree node toggle icons */
.tree-multi-select :deep(.p-treeselect-tree-toggler) {
  color: var(--bs-secondary);
}

.tree-multi-select :deep(.p-treeselect-tree-toggler:hover) {
  color: var(--bs-primary);
}
</style>
```

IMPORTANT NOTES:
- PrimeVue TreeSelect in checkbox mode uses object format `{ nodeId: { checked, partialChecked } }` not string[]
- The component converts between our simple string[] v-model and PrimeVue's object format
- PT (pass-through) props apply Bootstrap classes without any PrimeVue CSS
- chips display below the selector (per CONTEXT.md requirements)
- BFormTag from Bootstrap-Vue-Next handles removal with X button
  </action>
  <verify>
File exists: app/src/components/forms/TreeMultiSelect.vue
Run `cd /home/bernt-popp/development/sysndd/app && npm run type-check` passes
Run `cd /home/bernt-popp/development/sysndd/app && npm run lint` passes (may need --fix)
  </verify>
  <done>
TreeMultiSelect.vue created in components/forms/
Component wraps PrimeVue TreeSelect with Bootstrap PT styling
v-model binding converts between string[] and PrimeVue object format
Search input with clear button
Chips display with tooltips showing full path
Validation error display
TypeScript and lint pass
  </done>
</task>

<task type="auto">
  <name>Task 4: Runtime verification with sample data and compound keys</name>
  <files>
    app/src/components/forms/TreeMultiSelectTest.vue
  </files>
  <action>
Create a temporary test component to verify TreeMultiSelect works correctly at runtime with sample hierarchical data AND compound key format matching the production API.

Create app/src/components/forms/TreeMultiSelectTest.vue:

```vue
<!-- Temporary test component - delete after verification -->
<template>
  <div class="p-4">
    <h5>TreeMultiSelect Runtime Test</h5>

    <div class="mb-4">
      <h6>Test 1: Basic Hierarchical Tree</h6>
      <TreeMultiSelect
        v-model="selectedBasic"
        :options="basicOptions"
        placeholder="Select items..."
        search-placeholder="Search..."
      />
      <pre class="mt-2 small">Selected: {{ selectedBasic }}</pre>
    </div>

    <div class="mb-4">
      <h6>Test 2: Compound Keys (modifier_id-phenotype_id format)</h6>
      <TreeMultiSelect
        v-model="selectedCompound"
        :options="compoundKeyOptions"
        placeholder="Select phenotypes..."
        search-placeholder="Search phenotypes (name or HP:ID)..."
      />
      <pre class="mt-2 small">Selected: {{ selectedCompound }}</pre>
    </div>

    <div class="mb-4">
      <h6>Test 3: Pre-selected Values with Compound Keys</h6>
      <TreeMultiSelect
        v-model="preselectedCompound"
        :options="compoundKeyOptions"
        placeholder="Select phenotypes..."
      />
      <pre class="mt-2 small">Selected: {{ preselectedCompound }}</pre>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import TreeMultiSelect from './TreeMultiSelect.vue';

// Test 1: Basic hierarchical tree
const selectedBasic = ref<string[]>([]);
const basicOptions = ref([
  {
    id: 'category-1',
    label: 'Category 1',
    children: [
      { id: 'item-1-1', label: 'Item 1.1' },
      { id: 'item-1-2', label: 'Item 1.2' },
    ],
  },
  {
    id: 'category-2',
    label: 'Category 2',
    children: [
      { id: 'item-2-1', label: 'Item 2.1' },
      {
        id: 'subcategory-2-2',
        label: 'Subcategory 2.2',
        children: [
          { id: 'item-2-2-1', label: 'Item 2.2.1' },
          { id: 'item-2-2-2', label: 'Item 2.2.2' },
        ],
      },
    ],
  },
]);

// Test 2: Compound keys matching production format (modifier_id-phenotype_id)
const selectedCompound = ref<string[]>([]);
const compoundKeyOptions = ref([
  {
    id: 'phenotypic-abnormality',
    label: 'Phenotypic abnormality',
    children: [
      {
        id: 'nervous-system',
        label: 'Abnormality of the nervous system',
        children: [
          // Compound key format: present-HP:0001250
          { id: 'present-HP:0001250', label: 'Seizure (present)' },
          { id: 'absent-HP:0001250', label: 'Seizure (absent)' },
          { id: 'present-HP:0001249', label: 'Intellectual disability (present)' },
        ],
      },
      {
        id: 'musculoskeletal',
        label: 'Abnormality of the musculoskeletal system',
        children: [
          { id: 'present-HP:0001371', label: 'Flexion contracture (present)' },
          { id: 'present-HP:0001290', label: 'Generalized hypotonia (present)' },
        ],
      },
    ],
  },
]);

// Test 3: Pre-selected values to verify v-model initialization
const preselectedCompound = ref<string[]>([
  'present-HP:0001250',
  'present-HP:0001249',
]);
</script>
```

Then start the dev server and verify the component works:

```bash
cd /home/bernt-popp/development/sysndd/app && npm run dev
```

In a browser, temporarily import and render the test component (e.g., add to App.vue or a test route).

**Verification checklist:**
1. Basic tree: Can expand/collapse, select items, see chips
2. Compound keys: IDs like "present-HP:0001250" are stored correctly
3. Pre-selected: Initial values display as chips immediately
4. Search: Typing "HP:0001250" filters to show that term
5. Chip removal: X button removes item from selection
6. Tooltip: Hovering chip shows full path like "Phenotypic abnormality > Abnormality of the nervous system > Seizure (present)"

After verification, delete the test component.
  </action>
  <verify>
1. Start dev server: `cd /home/bernt-popp/development/sysndd/app && npm run dev`
2. Navigate to test component (add temporary route or import)
3. Verify all 3 tests pass (basic tree, compound keys, pre-selected)
4. Verify search works with HP:IDs
5. Verify chip tooltips show hierarchy path
6. Delete test component after verification
  </verify>
  <done>
TreeMultiSelect renders hierarchical data correctly
Compound key format (present-HP:0001250) handled properly
v-model initialization with pre-selected values works
Search filtering works with HP:IDs
Chip display with tooltips works
Test component deleted after verification
  </done>
</task>

</tasks>

<verification>
1. `cd /home/bernt-popp/development/sysndd/app && npm ls primevue` shows 4.5.4+
2. `cd /home/bernt-popp/development/sysndd/app && npm run type-check` passes
3. `cd /home/bernt-popp/development/sysndd/app && npm run lint` passes
4. main.ts contains `app.use(PrimeVue, { unstyled: true })`
5. All new files exist with correct exports
6. Runtime test verified compound key handling with sample data
</verification>

<success_criteria>
- PrimeVue 4.5.4+ installed with unstyled mode configured
- useTreeSearch composable filters tree preserving ancestor context
- useHierarchyPath composable computes hierarchy paths with caching
- TreeMultiSelect.vue wrapper component created with Bootstrap PT styling
- Runtime verification confirms component works with compound keys
- All TypeScript type checks pass
- All lint checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/35-multi-select-restoration/35-01-SUMMARY.md`
</output>
