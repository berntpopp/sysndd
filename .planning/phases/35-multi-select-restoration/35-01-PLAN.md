---
phase: 35-multi-select-restoration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/package.json
  - app/src/main.ts
  - app/src/composables/useTreeSearch.ts
  - app/src/composables/useHierarchyPath.ts
  - app/src/components/forms/TreeMultiSelect.vue
autonomous: true

must_haves:
  truths:
    - "PrimeVue is installed and configured in unstyled mode"
    - "TreeMultiSelect component renders hierarchical tree with checkboxes"
    - "Search filters tree in place, preserving ancestor context"
    - "Selected items display as chips with X removal button"
    - "Full hierarchy path shown on chip hover via tooltip"
  artifacts:
    - path: "app/src/composables/useTreeSearch.ts"
      provides: "Tree search filtering with ancestor preservation"
      exports: ["useTreeSearch"]
    - path: "app/src/composables/useHierarchyPath.ts"
      provides: "Hierarchy path computation for tooltips"
      exports: ["useHierarchyPath"]
    - path: "app/src/components/forms/TreeMultiSelect.vue"
      provides: "Reusable hierarchical multi-select wrapper"
      min_lines: 100
  key_links:
    - from: "app/src/components/forms/TreeMultiSelect.vue"
      to: "primevue/treeselect"
      via: "import TreeSelect"
      pattern: "import TreeSelect from 'primevue/treeselect'"
    - from: "app/src/main.ts"
      to: "primevue/config"
      via: "app.use(PrimeVue)"
      pattern: "app\\.use\\(PrimeVue"
---

<objective>
Create TreeMultiSelect component foundation with PrimeVue TreeSelect

Purpose: Establish reusable hierarchical multi-select pattern that will replace vue3-treeselect across all curation forms. Uses PrimeVue TreeSelect in unstyled mode with Bootstrap PT styling to maintain visual consistency.

Output:
- PrimeVue installed and configured
- useTreeSearch composable for filtering
- useHierarchyPath composable for tooltips
- TreeMultiSelect wrapper component
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-multi-select-restoration/35-CONTEXT.md
@.planning/phases/35-multi-select-restoration/35-RESEARCH.md

# Existing composables pattern
@app/src/composables/useToast.ts
@app/src/composables/index.ts

# Current main.ts for PrimeVue integration pattern
@app/src/main.ts

# Bootstrap-Vue-Next BFormTag usage pattern
@app/src/views/review/Review.vue (lines 659-713)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install and configure PrimeVue</name>
  <files>
    app/package.json
    app/src/main.ts
  </files>
  <action>
Install PrimeVue:
```bash
cd app && npm install primevue@^4.5.4
```

Update main.ts to configure PrimeVue in unstyled mode. Add AFTER createBootstrap() registration:
```typescript
import PrimeVue from 'primevue/config';

// Configure PrimeVue in unstyled mode (no CSS, use Bootstrap via PT)
app.use(PrimeVue, {
  unstyled: true
});
```

IMPORTANT: Do NOT import any PrimeVue CSS files. The unstyled mode means we style entirely via PT (pass-through) props with Bootstrap classes.
  </action>
  <verify>
Run `cd /home/bernt-popp/development/sysndd/app && npm ls primevue` shows version 4.5.4+
Verify main.ts has PrimeVue import and app.use() call with unstyled: true
  </verify>
  <done>
PrimeVue 4.5.4+ installed in package.json
main.ts configures PrimeVue with unstyled: true
No PrimeVue CSS imports present
  </done>
</task>

<task type="auto">
  <name>Task 2: Create tree composables</name>
  <files>
    app/src/composables/useTreeSearch.ts
    app/src/composables/useHierarchyPath.ts
    app/src/composables/index.ts
  </files>
  <action>
Create useTreeSearch.ts - filters tree in place while preserving ancestor context:
```typescript
import { computed, type Ref } from 'vue';

export interface TreeNode {
  id: string;
  label: string;
  children?: TreeNode[];
  [key: string]: unknown;
}

interface UseTreeSearchOptions {
  matchFields?: string[];
}

export function useTreeSearch(
  options: Ref<TreeNode[]>,
  query: Ref<string>,
  config: UseTreeSearchOptions = {}
) {
  const { matchFields = ['label', 'id'] } = config;

  const filteredOptions = computed(() => {
    if (!query.value || query.value.trim() === '') {
      return options.value;
    }

    const lowerQuery = query.value.toLowerCase();

    function filterNode(node: TreeNode): TreeNode | null {
      // Check if node matches any of the specified fields
      const nodeMatches = matchFields.some((field) => {
        const value = node[field];
        return (
          typeof value === 'string' &&
          value.toLowerCase().includes(lowerQuery)
        );
      });

      // Recursively filter children
      const filteredChildren = node.children
        ?.map(filterNode)
        .filter((n): n is TreeNode => n !== null);

      // Include node if it matches OR if any children match (preserves ancestor context)
      if (nodeMatches || (filteredChildren && filteredChildren.length > 0)) {
        return {
          ...node,
          children: filteredChildren,
        };
      }

      return null;
    }

    return options.value
      .map(filterNode)
      .filter((n): n is TreeNode => n !== null);
  });

  return { filteredOptions };
}
```

Create useHierarchyPath.ts - computes full path for tooltips with memoization:
```typescript
import { type Ref, watch } from 'vue';

export interface TreeNode {
  id: string;
  label: string;
  children?: TreeNode[];
}

export function useHierarchyPath(options: Ref<TreeNode[]>) {
  const pathCache = new Map<string, TreeNode[]>();

  function buildCache() {
    pathCache.clear();

    function traverse(nodes: TreeNode[], ancestors: TreeNode[] = []) {
      for (const node of nodes) {
        const path = [...ancestors, node];
        pathCache.set(node.id, path);

        if (node.children) {
          traverse(node.children, path);
        }
      }
    }

    traverse(options.value);
  }

  // Rebuild cache when options change
  watch(options, buildCache, { immediate: true, deep: true });

  function getPath(nodeId: string): TreeNode[] {
    return pathCache.get(nodeId) || [];
  }

  function getPathString(nodeId: string): string {
    return getPath(nodeId)
      .map((n) => n.label)
      .join(' > ');
  }

  return { getPath, getPathString };
}
```

Update composables/index.ts to export new composables (add to existing exports):
```typescript
export { useTreeSearch } from './useTreeSearch';
export { useHierarchyPath } from './useHierarchyPath';
```
  </action>
  <verify>
Files exist: app/src/composables/useTreeSearch.ts, app/src/composables/useHierarchyPath.ts
Run `cd /home/bernt-popp/development/sysndd/app && npm run type-check` passes without errors on new files
  </verify>
  <done>
useTreeSearch composable filters tree while preserving ancestors
useHierarchyPath composable computes and caches hierarchy paths
Both exported from composables/index.ts
TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Create TreeMultiSelect wrapper component</name>
  <files>
    app/src/components/forms/TreeMultiSelect.vue
  </files>
  <action>
Create forms directory if needed, then create TreeMultiSelect.vue:

```vue
<!-- components/forms/TreeMultiSelect.vue -->
<template>
  <div class="tree-multi-select">
    <!-- Search input -->
    <BInputGroup size="sm" class="mb-2">
      <BFormInput
        v-model="searchQuery"
        :placeholder="searchPlaceholder"
        aria-label="Search items"
        type="search"
      />
      <template #append>
        <BButton
          v-if="searchQuery"
          size="sm"
          variant="outline-secondary"
          aria-label="Clear search"
          @click="searchQuery = ''"
        >
          <i class="bi bi-x-lg" />
        </BButton>
      </template>
    </BInputGroup>

    <!-- PrimeVue TreeSelect with Bootstrap PT styling -->
    <TreeSelect
      v-model="internalValue"
      :options="filteredOptions"
      selection-mode="checkbox"
      :placeholder="placeholder"
      :disabled="disabled"
      :pt="{
        root: { class: 'form-control p-0 h-auto' },
        label: { class: 'form-control-sm border-0 bg-transparent' },
        dropdown: { class: 'btn btn-sm btn-outline-secondary border-0' },
        panel: { class: 'dropdown-menu show p-2 shadow-sm', style: 'max-height: 300px; overflow-y: auto; min-width: 100%;' },
        wrapper: { class: '' },
        tree: { class: 'list-unstyled mb-0' },
        node: { class: 'py-1' },
        checkbox: { class: 'form-check-input me-2' },
        nodeLabel: { class: 'small' },
        nodeToggleButton: { class: 'btn btn-link btn-sm p-0 me-1 text-decoration-none' },
        emptyMessage: { class: 'text-muted small p-2' }
      }"
      option-label="label"
      option-value="id"
      @update:model-value="handleChange"
    />

    <!-- Selected items as chips below the selector -->
    <div v-if="selectedItems.length > 0" class="mt-2 d-flex flex-wrap gap-1">
      <BFormTag
        v-for="item in selectedItems"
        :key="item.id"
        variant="secondary"
        v-b-tooltip.hover
        :title="getFullPath(item.id)"
        @remove="removeItem(item.id)"
      >
        {{ item.label }}
      </BFormTag>
    </div>

    <!-- Validation error -->
    <div v-if="error" class="invalid-feedback d-block mt-1">
      {{ error }}
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, ref, watch } from 'vue';
import TreeSelect from 'primevue/treeselect';
import { useTreeSearch, useHierarchyPath } from '@/composables';
import type { TreeNode } from '@/composables/useTreeSearch';

interface Props {
  modelValue: string[] | null;
  options: TreeNode[];
  placeholder?: string;
  searchPlaceholder?: string;
  error?: string;
  disabled?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  placeholder: 'Select items...',
  searchPlaceholder: 'Search...',
  error: '',
  disabled: false,
});

const emit = defineEmits<{
  (e: 'update:modelValue', value: string[]): void;
}>();

const searchQuery = ref('');

// PrimeVue TreeSelect uses object format for checkbox mode: { nodeId: { checked: true, partialChecked: false } }
// We need to convert between our string[] format and PrimeVue's object format
const internalValue = ref<Record<string, { checked: boolean; partialChecked: boolean }> | null>(null);

// Convert our string[] to PrimeVue format
watch(
  () => props.modelValue,
  (newValue) => {
    if (!newValue || newValue.length === 0) {
      internalValue.value = null;
      return;
    }
    const result: Record<string, { checked: boolean; partialChecked: boolean }> = {};
    for (const id of newValue) {
      result[id] = { checked: true, partialChecked: false };
    }
    internalValue.value = result;
  },
  { immediate: true }
);

// Search filtering - preserves ancestor context
const { filteredOptions } = useTreeSearch(
  computed(() => props.options),
  searchQuery,
  { matchFields: ['label', 'id'] } // Match both name and code (HP:0001250)
);

// Compute full hierarchy path for tooltips
const { getPathString } = useHierarchyPath(computed(() => props.options));

// Find selected nodes from tree
const selectedItems = computed(() => {
  if (!props.modelValue?.length) return [];
  return findNodesByIds(props.options, props.modelValue);
});

function getFullPath(itemId: string): string {
  return getPathString(itemId);
}

function handleChange(value: Record<string, { checked: boolean; partialChecked: boolean }> | null) {
  if (!value) {
    emit('update:modelValue', []);
    return;
  }
  // Extract only fully checked items (not partialChecked)
  const selectedIds = Object.entries(value)
    .filter(([_, state]) => state.checked && !state.partialChecked)
    .map(([id]) => id);
  emit('update:modelValue', selectedIds);
}

function removeItem(id: string) {
  const updated = props.modelValue?.filter((v) => v !== id) || [];
  emit('update:modelValue', updated);
}

function findNodesByIds(nodes: TreeNode[], ids: string[]): TreeNode[] {
  const result: TreeNode[] = [];

  function search(nodes: TreeNode[]) {
    for (const node of nodes) {
      if (ids.includes(node.id)) {
        result.push(node);
      }
      if (node.children) {
        search(node.children);
      }
    }
  }

  search(nodes);
  return result;
}
</script>

<style scoped>
/* Ensure dropdown panel displays correctly */
.tree-multi-select :deep(.p-treeselect-panel) {
  position: absolute;
  z-index: 1050;
}

/* Style the tree node toggle icons */
.tree-multi-select :deep(.p-treeselect-tree-toggler) {
  color: var(--bs-secondary);
}

.tree-multi-select :deep(.p-treeselect-tree-toggler:hover) {
  color: var(--bs-primary);
}
</style>
```

IMPORTANT NOTES:
- PrimeVue TreeSelect in checkbox mode uses object format `{ nodeId: { checked, partialChecked } }` not string[]
- The component converts between our simple string[] v-model and PrimeVue's object format
- PT (pass-through) props apply Bootstrap classes without any PrimeVue CSS
- chips display below the selector (per CONTEXT.md requirements)
- BFormTag from Bootstrap-Vue-Next handles removal with X button
  </action>
  <verify>
File exists: app/src/components/forms/TreeMultiSelect.vue
Run `cd /home/bernt-popp/development/sysndd/app && npm run type-check` passes
Run `cd /home/bernt-popp/development/sysndd/app && npm run lint` passes (may need --fix)
  </verify>
  <done>
TreeMultiSelect.vue created in components/forms/
Component wraps PrimeVue TreeSelect with Bootstrap PT styling
v-model binding converts between string[] and PrimeVue object format
Search input with clear button
Chips display with tooltips showing full path
Validation error display
TypeScript and lint pass
  </done>
</task>

</tasks>

<verification>
1. `cd /home/bernt-popp/development/sysndd/app && npm ls primevue` shows 4.5.4+
2. `cd /home/bernt-popp/development/sysndd/app && npm run type-check` passes
3. `cd /home/bernt-popp/development/sysndd/app && npm run lint` passes
4. main.ts contains `app.use(PrimeVue, { unstyled: true })`
5. All new files exist with correct exports
</verification>

<success_criteria>
- PrimeVue 4.5.4+ installed with unstyled mode configured
- useTreeSearch composable filters tree preserving ancestor context
- useHierarchyPath composable computes hierarchy paths with caching
- TreeMultiSelect.vue wrapper component created with Bootstrap PT styling
- All TypeScript type checks pass
- All lint checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/35-multi-select-restoration/35-01-SUMMARY.md`
</output>
