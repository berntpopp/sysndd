---
phase: 35-multi-select-restoration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/src/components/forms/TreeNode.vue
  - app/src/components/forms/TreeMultiSelect.vue
  - app/src/composables/useTreeSearch.ts
  - app/src/composables/useHierarchyPath.ts
  - app/src/composables/index.ts
autonomous: true

must_haves:
  truths:
    - "User can browse hierarchical phenotype/variation lists with visual hierarchy"
    - "User can search items by name or code and see matches in ancestor context"
    - "User can select multiple items via checkboxes on leaf nodes"
    - "User sees selected items as chips below the selector"
    - "User sees full hierarchy path when hovering over a chip"
  artifacts:
    - path: "app/src/components/forms/TreeNode.vue"
      provides: "Recursive tree node component for hierarchical display"
      min_lines: 60
    - path: "app/src/components/forms/TreeMultiSelect.vue"
      provides: "Reusable hierarchical multi-select wrapper"
      min_lines: 150
    - path: "app/src/composables/useTreeSearch.ts"
      provides: "Tree search filtering with ancestor preservation"
      exports: ["useTreeSearch"]
    - path: "app/src/composables/useHierarchyPath.ts"
      provides: "Hierarchy path computation for tooltips"
      exports: ["useHierarchyPath"]
  key_links:
    - from: "app/src/components/forms/TreeMultiSelect.vue"
      to: "app/src/components/forms/TreeNode.vue"
      via: "import TreeNode"
      pattern: "import TreeNode from './TreeNode.vue'"
    - from: "app/src/components/forms/TreeMultiSelect.vue"
      to: "app/src/composables/useTreeSearch.ts"
      via: "import useTreeSearch"
      pattern: "import.*useTreeSearch"
---

<objective>
Create TreeMultiSelect component foundation with Bootstrap-Vue-Next ONLY

Purpose: Build custom hierarchical multi-select using ONLY Bootstrap-Vue-Next primitives (BFormTags, BDropdown, BCollapse, BFormCheckbox). NO PrimeVue. This restores multi-select capability while staying within the Bootstrap-Vue-Next ecosystem.

Output:
- TreeNode.vue recursive component (BCollapse + BFormCheckbox)
- TreeMultiSelect.vue wrapper component (BFormTags + BDropdown + TreeNode)
- useTreeSearch composable for filtering with ancestor preservation
- useHierarchyPath composable for chip tooltips
- NO new npm dependencies required
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-multi-select-restoration/35-CONTEXT.md
@.planning/phases/35-multi-select-restoration/35-RESEARCH.md

# Existing composables pattern
@app/src/composables/useToast.ts
@app/src/composables/index.ts

# Bootstrap-Vue-Next BFormTag usage pattern (PMID tags)
@app/src/views/review/Review.vue (lines 659-713)

# Bootstrap-Vue-Next components already registered
@app/src/bootstrap-vue-next-components.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tree composables</name>
  <files>
    app/src/composables/useTreeSearch.ts
    app/src/composables/useHierarchyPath.ts
    app/src/composables/index.ts
  </files>
  <action>
Create useTreeSearch.ts - filters tree in place while preserving ancestor context:
```typescript
import { computed, type Ref } from 'vue';

export interface TreeNode {
  id: string;
  label: string;
  children?: TreeNode[];
  [key: string]: unknown;
}

interface UseTreeSearchOptions {
  matchFields?: string[];
}

export function useTreeSearch(
  options: Ref<TreeNode[]>,
  query: Ref<string>,
  config: UseTreeSearchOptions = {}
) {
  const { matchFields = ['label', 'id'] } = config;

  const filteredOptions = computed(() => {
    if (!query.value || query.value.trim() === '') {
      return options.value;
    }

    const lowerQuery = query.value.toLowerCase();

    function filterNode(node: TreeNode): TreeNode | null {
      // Check if node matches any of the specified fields
      const nodeMatches = matchFields.some((field) => {
        const value = node[field];
        return (
          typeof value === 'string' &&
          value.toLowerCase().includes(lowerQuery)
        );
      });

      // Recursively filter children
      const filteredChildren = node.children
        ?.map(filterNode)
        .filter((n): n is TreeNode => n !== null);

      // Include node if it matches OR if any children match (preserves ancestor context)
      if (nodeMatches || (filteredChildren && filteredChildren.length > 0)) {
        return {
          ...node,
          children: filteredChildren,
        };
      }

      return null;
    }

    return options.value
      .map(filterNode)
      .filter((n): n is TreeNode => n !== null);
  });

  return { filteredOptions };
}
```

Create useHierarchyPath.ts - computes full path for tooltips with memoization:
```typescript
import { type Ref, watch } from 'vue';

export interface TreeNode {
  id: string;
  label: string;
  children?: TreeNode[];
}

export function useHierarchyPath(options: Ref<TreeNode[]>) {
  const pathCache = new Map<string, TreeNode[]>();

  function buildCache() {
    pathCache.clear();

    function traverse(nodes: TreeNode[], ancestors: TreeNode[] = []) {
      for (const node of nodes) {
        const path = [...ancestors, node];
        pathCache.set(node.id, path);

        if (node.children) {
          traverse(node.children, path);
        }
      }
    }

    traverse(options.value);
  }

  // Rebuild cache when options change
  watch(options, buildCache, { immediate: true, deep: true });

  function getPath(nodeId: string): TreeNode[] {
    return pathCache.get(nodeId) || [];
  }

  function getPathString(nodeId: string): string {
    return getPath(nodeId)
      .map((n) => n.label)
      .join(' > ');
  }

  return { getPath, getPathString };
}
```

Update composables/index.ts to export new composables (add to existing exports):
```typescript
export { useTreeSearch } from './useTreeSearch';
export type { TreeNode } from './useTreeSearch';
export { useHierarchyPath } from './useHierarchyPath';
```
  </action>
  <verify>
Files exist: app/src/composables/useTreeSearch.ts, app/src/composables/useHierarchyPath.ts
Run `cd /home/bernt-popp/development/sysndd/app && npm run type-check` passes without errors on new files
  </verify>
  <done>
useTreeSearch composable filters tree while preserving ancestors
useHierarchyPath composable computes and caches hierarchy paths
Both exported from composables/index.ts
TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TreeNode recursive component</name>
  <files>
    app/src/components/forms/TreeNode.vue
  </files>
  <action>
Create forms directory if needed, then create TreeNode.vue - recursive component using `name` property for self-reference.

CRITICAL: Must use Options API with `name: 'TreeNode'` for recursive self-reference. Script setup does NOT support self-referencing components.

```vue
<!-- components/forms/TreeNode.vue -->
<!-- Recursive tree node component for hierarchical display -->
<template>
  <div class="tree-node">
    <!-- Parent node with children (navigation only - no checkbox) -->
    <div v-if="hasChildren" class="parent-node">
      <BButton
        v-b-toggle="`collapse-${node.id}`"
        variant="link"
        size="sm"
        class="text-start w-100 d-flex align-items-center px-2 py-1 text-decoration-none"
        :class="{ 'text-primary': hasSelectedDescendants }"
      >
        <i class="bi bi-chevron-right me-2 collapse-icon" />
        <span class="flex-grow-1">{{ node.label }}</span>
        <BBadge v-if="selectedDescendantCount > 0" variant="primary" pill class="ms-2">
          {{ selectedDescendantCount }}
        </BBadge>
        <BBadge variant="secondary" pill class="ms-1">
          {{ leafCount }}
        </BBadge>
      </BButton>

      <BCollapse
        :id="`collapse-${node.id}`"
        :lazy="true"
        class="ms-3"
      >
        <TreeNode
          v-for="child in node.children"
          :key="child.id"
          :node="child"
          :selected="selected"
          @toggle="$emit('toggle', $event)"
        />
      </BCollapse>
    </div>

    <!-- Leaf node with checkbox (selectable) -->
    <div v-else class="leaf-node ps-4 py-1">
      <BFormCheckbox
        :model-value="selected.includes(node.id)"
        :id="`checkbox-${node.id}`"
        @update:model-value="$emit('toggle', node.id)"
      >
        <span>{{ node.label }}</span>
        <small class="text-muted ms-2">({{ extractCode(node.id) }})</small>
      </BFormCheckbox>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, type PropType } from 'vue';

interface TreeNodeType {
  id: string;
  label: string;
  children?: TreeNodeType[];
}

export default defineComponent({
  name: 'TreeNode', // Critical: enables self-reference for recursion
  props: {
    node: {
      type: Object as PropType<TreeNodeType>,
      required: true,
    },
    selected: {
      type: Array as PropType<string[]>,
      default: () => [],
    },
  },
  emits: ['toggle'],
  computed: {
    hasChildren(): boolean {
      return Boolean(this.node.children && this.node.children.length > 0);
    },
    leafCount(): number {
      return this.countLeaves(this.node);
    },
    selectedDescendantCount(): number {
      return this.countSelectedDescendants(this.node);
    },
    hasSelectedDescendants(): boolean {
      return this.selectedDescendantCount > 0;
    },
  },
  methods: {
    extractCode(id: string): string {
      // Extract HP:XXXXXXX or similar code from compound key like "present-HP:0001250"
      const match = id.match(/(HP:\d+|[A-Z]+:\d+)/);
      return match ? match[1] : id;
    },
    countLeaves(node: TreeNodeType): number {
      if (!node.children || node.children.length === 0) {
        return 1;
      }
      return node.children.reduce((sum, child) => sum + this.countLeaves(child), 0);
    },
    countSelectedDescendants(node: TreeNodeType): number {
      if (!node.children || node.children.length === 0) {
        return this.selected.includes(node.id) ? 1 : 0;
      }
      return node.children.reduce(
        (sum, child) => sum + this.countSelectedDescendants(child),
        0
      );
    },
  },
});
</script>

<style scoped>
/* Rotate chevron when expanded */
.collapse-icon {
  transition: transform 0.2s ease;
}

.not-collapsed .collapse-icon {
  transform: rotate(90deg);
}

/* Style parent node button */
.parent-node .btn-link {
  color: var(--bs-body-color);
}

.parent-node .btn-link:hover {
  color: var(--bs-primary);
  background-color: var(--bs-gray-100);
}

/* Leaf node hover */
.leaf-node:hover {
  background-color: var(--bs-gray-100);
}
</style>
```

Key implementation details:
- Uses `name: 'TreeNode'` in Options API for recursive self-reference
- Parent nodes are navigation only (BButton with v-b-toggle, no checkbox)
- Only leaf nodes get BFormCheckbox
- BCollapse with `lazy` prop for performance with large trees
- Shows badge with selected count and total leaf count
- Emits 'toggle' event with node ID when checkbox clicked
  </action>
  <verify>
File exists: app/src/components/forms/TreeNode.vue
Run `cd /home/bernt-popp/development/sysndd/app && npm run type-check` passes
Run `cd /home/bernt-popp/development/sysndd/app && npm run lint -- --fix` passes
  </verify>
  <done>
TreeNode.vue created with recursive self-reference via name property
Parent nodes are navigation only (BButton + BCollapse)
Leaf nodes have BFormCheckbox for selection
BCollapse uses lazy prop for performance
Selected count badges show on parent nodes
TypeScript and lint pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Create TreeMultiSelect wrapper component</name>
  <files>
    app/src/components/forms/TreeMultiSelect.vue
  </files>
  <action>
Create TreeMultiSelect.vue - wraps BFormTags (chips) + BDropdown (selector with TreeNode inside).

```vue
<!-- components/forms/TreeMultiSelect.vue -->
<!-- Hierarchical multi-select using Bootstrap-Vue-Next primitives only -->
<template>
  <div class="tree-multi-select">
    <!-- Dropdown selector -->
    <BDropdown
      v-model="dropdownOpen"
      :auto-close="false"
      variant="outline-secondary"
      size="sm"
      block
      menu-class="tree-dropdown-menu"
      :disabled="disabled"
    >
      <template #button-content>
        <span v-if="!modelValue?.length" class="text-muted">
          {{ placeholder }}
        </span>
        <span v-else>
          {{ modelValue.length }} item{{ modelValue.length === 1 ? '' : 's' }} selected
        </span>
      </template>

      <!-- Search input -->
      <BDropdownForm @submit.prevent>
        <BFormInput
          v-model="searchQuery"
          :placeholder="searchPlaceholder"
          size="sm"
          debounce="300"
          type="search"
          aria-label="Search items"
        />
        <small v-if="searchQuery" class="text-muted d-block mt-1">
          {{ filteredLeafCount }} matching items
        </small>
      </BDropdownForm>

      <BDropdownDivider />

      <!-- Scrollable tree area -->
      <div class="tree-scroll-area">
        <div v-if="filteredOptions.length === 0" class="text-muted text-center py-3">
          <template v-if="searchQuery">
            No items match "{{ searchQuery }}"
          </template>
          <template v-else>
            No options available
          </template>
        </div>
        <TreeNode
          v-for="node in filteredOptions"
          :key="node.id"
          :node="node"
          :selected="modelValue || []"
          @toggle="toggleSelection"
        />
      </div>

      <BDropdownDivider />

      <!-- Action buttons -->
      <div class="d-flex justify-content-between px-3 py-2">
        <BButton
          variant="link"
          size="sm"
          class="text-decoration-none p-0"
          :disabled="!modelValue?.length"
          @click="clearAll"
        >
          <i class="bi bi-x-circle me-1" />
          Clear All
        </BButton>
        <BButton
          variant="primary"
          size="sm"
          @click="dropdownOpen = false"
        >
          Done
        </BButton>
      </div>
    </BDropdown>

    <!-- Selected items as chips below selector (matches PMID pattern) -->
    <div v-if="modelValue?.length" class="mt-2">
      <BFormTag
        v-for="id in modelValue"
        :key="id"
        variant="secondary"
        class="me-1 mb-1"
        v-b-tooltip.hover.top
        :title="getFullPath(id)"
        @remove="removeSelection(id)"
      >
        {{ getLabel(id) }}
      </BFormTag>
    </div>

    <!-- Validation error -->
    <div v-if="error" class="invalid-feedback d-block mt-1">
      {{ error }}
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import TreeNode from './TreeNode.vue';
import { useTreeSearch, useHierarchyPath, type TreeNode as TreeNodeType } from '@/composables';

interface Props {
  modelValue: string[] | null;
  options: TreeNodeType[];
  placeholder?: string;
  searchPlaceholder?: string;
  error?: string;
  disabled?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  placeholder: 'Select items...',
  searchPlaceholder: 'Search by name or code...',
  error: '',
  disabled: false,
});

const emit = defineEmits<{
  (e: 'update:modelValue', value: string[]): void;
}>();

const dropdownOpen = ref(false);
const searchQuery = ref('');

// Search filtering - preserves ancestor context
const { filteredOptions } = useTreeSearch(
  computed(() => props.options),
  searchQuery,
  { matchFields: ['label', 'id'] }
);

// Compute full hierarchy path for tooltips
const { getPathString } = useHierarchyPath(computed(() => props.options));

// Count filtered leaf nodes for search feedback
const filteredLeafCount = computed(() => {
  function countLeaves(nodes: TreeNodeType[]): number {
    return nodes.reduce((sum, node) => {
      if (!node.children || node.children.length === 0) {
        return sum + 1;
      }
      return sum + countLeaves(node.children);
    }, 0);
  }
  return countLeaves(filteredOptions.value);
});

// Build node lookup map for fast label retrieval
const nodeMap = computed(() => {
  const map = new Map<string, TreeNodeType>();

  function traverse(nodes: TreeNodeType[]) {
    for (const node of nodes) {
      map.set(node.id, node);
      if (node.children) {
        traverse(node.children);
      }
    }
  }

  traverse(props.options);
  return map;
});

function getLabel(id: string): string {
  const node = nodeMap.value.get(id);
  return node?.label || id;
}

function getFullPath(id: string): string {
  const path = getPathString(id);
  return path || id;
}

function toggleSelection(id: string) {
  const current = props.modelValue || [];
  const updated = current.includes(id)
    ? current.filter((v) => v !== id)
    : [...current, id];
  emit('update:modelValue', updated);
}

function removeSelection(id: string) {
  const updated = (props.modelValue || []).filter((v) => v !== id);
  emit('update:modelValue', updated);
}

function clearAll() {
  emit('update:modelValue', []);
}
</script>

<style scoped>
/* Dropdown menu styling */
.tree-multi-select :deep(.tree-dropdown-menu) {
  min-width: 350px;
  max-width: 500px;
}

/* Scrollable tree area */
.tree-scroll-area {
  max-height: 300px;
  overflow-y: auto;
  padding: 0 0.5rem;
}

/* Ensure dropdown stays above other content */
.tree-multi-select :deep(.dropdown-menu) {
  z-index: 1050;
}
</style>
```

Key implementation details:
- Uses BDropdown with `auto-close="false"` so it stays open for multi-select
- Search input with 300ms debounce for performance
- TreeNode components render hierarchical tree inside dropdown
- BFormTag chips display below selector (matches existing PMID pattern in Review.vue)
- Chips have tooltips showing full hierarchy path on hover
- "Done" button to close dropdown, "Clear All" to reset selection
- All Bootstrap-Vue-Next components - NO PrimeVue
  </action>
  <verify>
File exists: app/src/components/forms/TreeMultiSelect.vue
Run `cd /home/bernt-popp/development/sysndd/app && npm run type-check` passes
Run `cd /home/bernt-popp/development/sysndd/app && npm run lint -- --fix` passes
  </verify>
  <done>
TreeMultiSelect.vue created in components/forms/
Uses only Bootstrap-Vue-Next components (BDropdown, BFormTag, BFormInput, BButton)
BDropdown with auto-close="false" for multi-select UX
Search input with debounce for filtering
Chips display with tooltips showing hierarchy path
v-model binding with string[] format
TypeScript and lint pass
  </done>
</task>

</tasks>

<verification>
1. `cd /home/bernt-popp/development/sysndd/app && npm run type-check` passes
2. `cd /home/bernt-popp/development/sysndd/app && npm run lint` passes
3. All new files exist:
   - app/src/composables/useTreeSearch.ts
   - app/src/composables/useHierarchyPath.ts
   - app/src/components/forms/TreeNode.vue
   - app/src/components/forms/TreeMultiSelect.vue
4. No PrimeVue imports in any new files: `grep -r "primevue" app/src/components/forms/` returns nothing
5. package.json unchanged (no new dependencies needed)
</verification>

<success_criteria>
- useTreeSearch composable filters tree preserving ancestor context
- useHierarchyPath composable computes hierarchy paths with caching
- TreeNode.vue recursive component with BCollapse and BFormCheckbox
- TreeMultiSelect.vue wrapper using BFormTags, BDropdown, and TreeNode
- All components use ONLY Bootstrap-Vue-Next (no PrimeVue)
- No new npm dependencies required
- All TypeScript type checks pass
- All lint checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/35-multi-select-restoration/35-01-SUMMARY.md`
</output>
