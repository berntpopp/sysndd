---
phase: 33-logging-analytics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/src/components/tables/TablesLogs.vue
autonomous: true

must_haves:
  truths:
    - "Admin can bookmark filtered log view via URL (refresh preserves state)"
    - "Page navigation does not trigger duplicate API calls"
    - "Filter changes reset to first page and update URL"
  artifacts:
    - path: "app/src/components/tables/TablesLogs.vue"
      provides: "Module-level caching, initialization guards, URL sync"
      contains: "moduleLastApiParams"
  key_links:
    - from: "TablesLogs.vue"
      to: "window.history.replaceState"
      via: "updateBrowserUrl method"
      pattern: "history\\.replaceState"
    - from: "TablesLogs.vue watch"
      to: "isInitializing guard"
      via: "early return in handler"
      pattern: "if.*isInitializing.*return"
---

<objective>
Add module-level caching, initialization guards, and URL state sync to TablesLogs

Purpose: Establish TablesEntities-compatible foundation patterns for ViewLogs, preventing duplicate API calls on component remount and enabling bookmarkable filtered views.

Output: TablesLogs.vue with module-level caching pattern, initialization guards, and URL sync via history.replaceState
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-logging-analytics/33-CONTEXT.md
@.planning/phases/33-logging-analytics/33-RESEARCH.md
@app/src/components/tables/TablesLogs.vue
@app/src/components/tables/TablesEntities.vue
@app/src/views/admin/ManageUser.vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add module-level caching and initialization guard</name>
  <files>app/src/components/tables/TablesLogs.vue</files>
  <action>
Add module-level variables before the component definition (same pattern as TablesEntities lines 266-271):

```javascript
// Module-level variables to track API calls across component remounts
let moduleLastApiParams = null;
let moduleApiCallInProgress = false;
let moduleLastApiCallTime = 0;
let moduleLastApiResponse = null;
```

In data(), add:
```javascript
isInitializing: true,
loadDataDebounceTimer: null,
```

Refactor watch handlers to check isInitializing:
```javascript
watch: {
  filter: {
    handler() {
      if (this.isInitializing) return;
      this.filtered();
    },
    deep: true,
  },
  sortBy: {
    handler() {
      if (this.isInitializing) return;
      this.handleSortByOrDescChange();
    },
    deep: true,
  },
},
```

Refactor mounted() to parse URL params BEFORE initial load:
```javascript
mounted() {
  const urlParams = new URLSearchParams(window.location.search);

  // Parse sort from URL
  if (urlParams.get('sort')) {
    const sort_object = this.sortStringToVariables(urlParams.get('sort'));
    this.sortBy = sort_object.sortBy;
    this.sort = urlParams.get('sort');
  } else {
    const sort_object = this.sortStringToVariables(this.sortInput);
    this.sortBy = sort_object.sortBy;
  }

  // Parse filter from URL
  if (urlParams.get('filter')) {
    this.filter = this.filterStrToObj(urlParams.get('filter'), this.filter);
    this.filter_string = urlParams.get('filter');
  }

  // Parse pagination from URL
  if (urlParams.get('page_after')) {
    this.currentItemID = parseInt(urlParams.get('page_after'), 10) || 0;
  }
  if (urlParams.get('page_size')) {
    this.perPage = parseInt(urlParams.get('page_size'), 10) || 10;
  }

  this.$nextTick(() => {
    this.loadData();
    this.$nextTick(() => {
      this.isInitializing = false;
    });
  });

  setTimeout(() => {
    this.loading = false;
  }, 500);
},
```
  </action>
  <verify>Component initializes without errors. Check browser console for no duplicate mounted() calls or API requests.</verify>
  <done>Module-level cache variables defined. isInitializing guard in data() and watch handlers. mounted() parses URL params before loadData().</done>
</task>

<task type="auto">
  <name>Task 2: Implement doLoadData with caching and URL sync</name>
  <files>app/src/components/tables/TablesLogs.vue</files>
  <action>
Replace loadData() method with debounced version that calls doLoadData():

```javascript
loadData() {
  if (this.loadDataDebounceTimer) {
    clearTimeout(this.loadDataDebounceTimer);
  }
  this.loadDataDebounceTimer = setTimeout(() => {
    this.loadDataDebounceTimer = null;
    this.doLoadData();
  }, 50);
},
```

Add new doLoadData() method with module-level caching (following TablesEntities pattern):

```javascript
async doLoadData() {
  const urlParam = `sort=${this.sort}&filter=${this.filter_string}&page_after=${this.currentItemID}&page_size=${this.perPage}`;
  const now = Date.now();

  // Prevent duplicate API calls using module-level tracking
  if (moduleLastApiParams === urlParam && (now - moduleLastApiCallTime) < 500) {
    if (moduleLastApiResponse) {
      this.applyApiResponse(moduleLastApiResponse);
      this.isBusy = false;
    }
    return;
  }

  if (moduleApiCallInProgress && moduleLastApiParams === urlParam) return;

  moduleLastApiParams = urlParam;
  moduleLastApiCallTime = now;
  moduleApiCallInProgress = true;
  this.isBusy = true;

  try {
    const response = await this.axios.get(`${import.meta.env.VITE_API_URL}/api/logs`, {
      params: {
        sort: this.sort,
        filter: this.filter_string,
        page_after: this.currentItemID,
        page_size: this.perPage,
      },
      headers: {
        Authorization: `Bearer ${localStorage.getItem('token')}`,
      },
    });

    moduleApiCallInProgress = false;
    moduleLastApiResponse = response.data;
    this.applyApiResponse(response.data);
    this.updateBrowserUrl();
    this.isBusy = false;
  } catch (error) {
    moduleApiCallInProgress = false;
    this.makeToast(`Error: ${error.message}`, 'Error loading logs', 'danger');
    this.isBusy = false;
  }
},
```

Add applyApiResponse() method:

```javascript
applyApiResponse(data) {
  this.items = data.data;
  this.totalRows = data.meta[0].totalItems;
  this.$nextTick(() => {
    this.currentPage = data.meta[0].currentPage;
  });
  this.totalPages = data.meta[0].totalPages;
  this.prevItemID = data.meta[0].prevItemID;
  this.currentItemID = data.meta[0].currentItemID;
  this.nextItemID = data.meta[0].nextItemID;
  this.lastItemID = data.meta[0].lastItemID;
  this.executionTime = data.meta[0].executionTime;
  this.fields = data.meta[0].fspec;

  const uiStore = useUiStore();
  uiStore.requestScrollbarUpdate();
},
```

Add updateBrowserUrl() method:

```javascript
updateBrowserUrl() {
  if (this.isInitializing) return;
  const searchParams = new URLSearchParams();
  if (this.sort) searchParams.set('sort', this.sort);
  if (this.filter_string) searchParams.set('filter', this.filter_string);
  if (this.currentItemID > 0) searchParams.set('page_after', String(this.currentItemID));
  searchParams.set('page_size', String(this.perPage));

  const newUrl = `${window.location.pathname}?${searchParams.toString()}`;
  window.history.replaceState({ ...window.history.state }, '', newUrl);
},
```

Add totalPages to data():
```javascript
totalPages: 0,
```
  </action>
  <verify>
1. Open ViewLogs page, check Network tab for single API call
2. Change page size, verify URL updates with page_size param
3. Refresh page, verify same view loads (URL preserved state)
4. Navigate away and back, verify no duplicate API calls in Network tab
  </verify>
  <done>doLoadData() with module-level caching prevents duplicate calls. applyApiResponse() extracts response handling. updateBrowserUrl() syncs state to URL via history.replaceState.</done>
</task>

<task type="auto">
  <name>Task 3: Add relative timestamps and improved status badges</name>
  <files>app/src/components/tables/TablesLogs.vue</files>
  <action>
Add formatRelativeTime() method for relative timestamps with absolute tooltip:

```javascript
formatRelativeTime(dateStr) {
  if (!dateStr) return '';
  const now = new Date();
  const date = new Date(dateStr);
  const diffMs = now - date;
  const diffMins = Math.round(diffMs / 60000);
  const diffHours = Math.round(diffMs / 3600000);
  const diffDays = Math.round(diffMs / 86400000);

  const rtf = new Intl.RelativeTimeFormat('en', { numeric: 'auto' });
  if (Math.abs(diffMins) < 60) return rtf.format(-diffMins, 'minute');
  if (Math.abs(diffHours) < 24) return rtf.format(-diffHours, 'hour');
  return rtf.format(-diffDays, 'day');
},

formatAbsoluteTime(dateStr) {
  if (!dateStr) return '';
  return new Date(dateStr).toLocaleString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    timeZoneName: 'short',
  });
},
```

Update the timestamp cell template to use relative time with absolute tooltip:

```vue
<template #cell-timestamp="{ row }">
  <div
    v-b-tooltip.hover.top
    :title="formatAbsoluteTime(row.timestamp)"
  >
    {{ formatRelativeTime(row.timestamp) }}
  </div>
</template>
```

Add getStatusVariant() method for improved status badge coloring:

```javascript
getStatusVariant(status) {
  if (status >= 200 && status < 300) return 'success';  // 2xx OK
  if (status >= 400 && status < 500) return 'warning';  // 4xx client error
  if (status >= 500) return 'danger';                   // 5xx server error
  return 'secondary';
},
```

Update status cell template:

```vue
<template #cell-status="{ row }">
  <BBadge :variant="getStatusVariant(row.status)">
    {{ row.status }}
  </BBadge>
</template>
```

Ensure method variants are consistent:
- GET: success (green)
- POST: primary (blue)
- PUT: warning (yellow)
- DELETE: danger (red)
- OPTIONS: info (light blue)
  </action>
  <verify>
1. View logs table, verify timestamps show "2 hours ago" style format
2. Hover over timestamp, verify tooltip shows full date/time with timezone
3. Check status badges: 200 = green, 404 = yellow, 500 = red
4. Check method badges maintain existing color scheme
  </verify>
  <done>formatRelativeTime() with Intl.RelativeTimeFormat. formatAbsoluteTime() for tooltip. getStatusVariant() for color-coded status. Timestamp template updated.</done>
</task>

</tasks>

<verification>
1. `npm run dev` starts without errors
2. Navigate to /admin/logs (ViewLogs page)
3. Open Network tab, verify single API call on load
4. Change page size from 10 to 25, verify:
   - URL updates to include `page_size=25`
   - Single API call in Network tab
5. Apply a search filter, verify URL updates with `filter=` param
6. Copy URL, open in new tab, verify same filtered view loads
7. Navigate to another page, then back to logs, verify no duplicate API calls
8. Check timestamps display relative format with absolute tooltips
9. Check status badges are color-coded by response code range
</verification>

<success_criteria>
- Module-level caching prevents duplicate API calls on component remount
- Initialization guards prevent watchers from triggering during setup
- URL state sync via history.replaceState enables bookmarkable filtered views
- Relative timestamps with absolute tooltips improve readability
- Status badges are color-coded (green 2xx, yellow 4xx, red 5xx)
</success_criteria>

<output>
After completion, create `.planning/phases/33-logging-analytics/33-01-SUMMARY.md`
</output>
