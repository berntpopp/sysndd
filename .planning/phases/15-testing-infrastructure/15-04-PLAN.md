---
phase: 15-testing-infrastructure
plan: 04
type: execute
wave: 2
depends_on: ["15-01", "15-02", "15-03"]
files_modified:
  - app/src/composables/useColorAndSymbols.spec.ts
  - app/src/composables/useText.spec.ts
  - app/src/composables/useUrlParsing.spec.ts
  - app/src/composables/useToast.spec.ts
  - app/src/composables/useModalControls.spec.ts
autonomous: true

must_haves:
  truths:
    - "Composable tests pass with npm run test:unit"
    - "Tests demonstrate both direct testing and withSetup patterns"
    - "Tests show mocking of external dependencies (bootstrap-vue-next)"
  artifacts:
    - path: "app/src/composables/useColorAndSymbols.spec.ts"
      provides: "Example test for stateless composable"
      contains: "describe"
    - path: "app/src/composables/useUrlParsing.spec.ts"
      provides: "Example test for pure function composable"
      contains: "filterObjToStr"
    - path: "app/src/composables/useToast.spec.ts"
      provides: "Example test with mocked dependencies"
      contains: "vi.mock"
  key_links:
    - from: "app/src/composables/useUrlParsing.spec.ts"
      to: "app/src/composables/useUrlParsing.ts"
      via: "import and test"
      pattern: "import.*useUrlParsing"
---

<objective>
Create example composable tests demonstrating different testing patterns.

Purpose: Provide learning examples for testing composables with varying complexity.
Output: 5 composable test files showing stateless, pure function, and mocked dependency patterns.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-testing-infrastructure/15-CONTEXT.md
@.planning/phases/15-testing-infrastructure/15-RESEARCH.md
@app/src/composables/useColorAndSymbols.ts
@app/src/composables/useText.ts
@app/src/composables/useUrlParsing.ts
@app/src/composables/useToast.ts
@app/src/composables/useModalControls.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test Stateless Composables (useColorAndSymbols, useText)</name>
  <files>app/src/composables/useColorAndSymbols.spec.ts, app/src/composables/useText.spec.ts</files>
  <action>
Create tests for stateless composables that return constant mappings.

Create `app/src/composables/useColorAndSymbols.spec.ts`:

```typescript
// useColorAndSymbols.spec.ts
/**
 * Tests for useColorAndSymbols composable
 *
 * Pattern: Stateless composable testing
 * This composable returns constant mappings with no reactive state or lifecycle hooks.
 * Can be tested directly without Vue context.
 */

import { describe, it, expect } from 'vitest';
import useColorAndSymbols from './useColorAndSymbols';

describe('useColorAndSymbols', () => {
  describe('stoplights_style', () => {
    it('maps numeric category to Bootstrap variant', () => {
      const { stoplights_style } = useColorAndSymbols();

      expect(stoplights_style[1]).toBe('success');
      expect(stoplights_style[2]).toBe('primary');
      expect(stoplights_style[3]).toBe('warning');
      expect(stoplights_style[4]).toBe('danger');
    });

    it('maps string category to Bootstrap variant', () => {
      const { stoplights_style } = useColorAndSymbols();

      expect(stoplights_style['Definitive']).toBe('success');
      expect(stoplights_style['Moderate']).toBe('primary');
      expect(stoplights_style['Limited']).toBe('warning');
      expect(stoplights_style['Refuted']).toBe('danger');
      expect(stoplights_style['not applicable']).toBe('secondary');
    });
  });

  describe('ndd_icon', () => {
    it('provides correct icons for NDD status', () => {
      const { ndd_icon } = useColorAndSymbols();

      expect(ndd_icon['Yes']).toBe('check');
      expect(ndd_icon['No']).toBe('x');
    });
  });

  describe('user_style', () => {
    it('maps user roles to Bootstrap variants', () => {
      const { user_style } = useColorAndSymbols();

      expect(user_style['Viewer']).toBe('secondary');
      expect(user_style['Reviewer']).toBe('primary');
      expect(user_style['Curator']).toBe('dark');
      expect(user_style['Administrator']).toBe('danger');
    });
  });

  describe('category_style', () => {
    it('provides color mappings for all categories', () => {
      const { category_style } = useColorAndSymbols();

      // Verify key categories have color mappings
      expect(category_style['HPO']).toBeDefined();
      expect(category_style['KEGG']).toBeDefined();
      expect(category_style['PMID']).toBeDefined();
    });
  });
});
```

Create `app/src/composables/useText.spec.ts`:

```typescript
// useText.spec.ts
/**
 * Tests for useText composable
 *
 * Pattern: Stateless composable testing
 * Returns constant text mappings, no reactive state.
 */

import { describe, it, expect } from 'vitest';
import useText from './useText';

describe('useText', () => {
  describe('modifier_text', () => {
    it('maps modifier IDs to text labels', () => {
      const { modifier_text } = useText();

      expect(modifier_text[1]).toBe('present');
      expect(modifier_text[2]).toBe('uncertain');
      expect(modifier_text[3]).toBe('variable');
      expect(modifier_text[4]).toBe('rare');
      expect(modifier_text[5]).toBe('absent');
    });
  });

  describe('inheritance_short_text', () => {
    it('abbreviates inheritance types correctly', () => {
      const { inheritance_short_text } = useText();

      expect(inheritance_short_text['Autosomal dominant inheritance']).toBe('AD');
      expect(inheritance_short_text['Autosomal recessive inheritance']).toBe('AR');
      expect(inheritance_short_text['X-linked recessive inheritance']).toBe('XR');
      expect(inheritance_short_text['Mitochondrial inheritance']).toBe('Mit');
    });
  });

  describe('data_age_text', () => {
    it('provides review priority text based on data age', () => {
      const { data_age_text } = useText();

      expect(data_age_text[0]).toContain('no priority');
      expect(data_age_text[6]).toContain('medium priority');
      expect(data_age_text[12]).toContain('highest priority');
    });
  });

  describe('ndd_icon_text', () => {
    it('provides descriptive text for NDD status', () => {
      const { ndd_icon_text } = useText();

      expect(ndd_icon_text['Yes']).toContain('associated with NDD');
      expect(ndd_icon_text['No']).toContain('NOT associated with NDD');
    });
  });
});
```
  </action>
  <verify>
Run `npm run test:unit -- --filter=useColorAndSymbols` - all tests pass.
Run `npm run test:unit -- --filter=useText` - all tests pass.
  </verify>
  <done>Tests created for useColorAndSymbols and useText composables</done>
</task>

<task type="auto">
  <name>Task 2: Test Pure Function Composable (useUrlParsing)</name>
  <files>app/src/composables/useUrlParsing.spec.ts</files>
  <action>
Create comprehensive tests for useUrlParsing - a composable with pure functions.

Create `app/src/composables/useUrlParsing.spec.ts`:

```typescript
// useUrlParsing.spec.ts
/**
 * Tests for useUrlParsing composable
 *
 * Pattern: Pure function composable testing
 * This composable returns pure functions with clear input/output contracts.
 * Good candidate for TDD-style testing with edge cases.
 */

import { describe, it, expect } from 'vitest';
import useUrlParsing from './useUrlParsing';

describe('useUrlParsing', () => {
  describe('filterObjToStr', () => {
    it('converts filter object to URL string', () => {
      const { filterObjToStr } = useUrlParsing();

      const filterObj = {
        symbol: { content: 'BRCA1', operator: 'equals', join_char: null },
      };

      const result = filterObjToStr(filterObj);
      expect(result).toBe('equals(symbol,BRCA1)');
    });

    it('handles multiple filters', () => {
      const { filterObjToStr } = useUrlParsing();

      const filterObj = {
        symbol: { content: 'BRCA1', operator: 'equals', join_char: null },
        category: { content: '1', operator: 'equals', join_char: null },
      };

      const result = filterObjToStr(filterObj);
      expect(result).toContain('equals(symbol,BRCA1)');
      expect(result).toContain('equals(category,1)');
    });

    it('filters out null content', () => {
      const { filterObjToStr } = useUrlParsing();

      const filterObj = {
        symbol: { content: null, operator: 'equals', join_char: null },
        category: { content: '1', operator: 'equals', join_char: null },
      };

      const result = filterObjToStr(filterObj);
      expect(result).toBe('equals(category,1)');
      expect(result).not.toContain('symbol');
    });

    it('filters out empty string content', () => {
      const { filterObjToStr } = useUrlParsing();

      const filterObj = {
        symbol: { content: '', operator: 'equals', join_char: null },
      };

      const result = filterObjToStr(filterObj);
      expect(result).toBe('');
    });

    it('handles array content with any operator', () => {
      const { filterObjToStr } = useUrlParsing();

      const filterObj = {
        categories: { content: ['1', '2', '3'], operator: 'any', join_char: ',' },
      };

      const result = filterObjToStr(filterObj);
      expect(result).toBe('any(categories,1,2,3)');
    });
  });

  describe('filterStrToObj', () => {
    it('parses filter string to object', () => {
      const { filterStrToObj } = useUrlParsing();

      const standard = {
        symbol: { content: null, operator: 'equals', join_char: null },
      };

      const result = filterStrToObj('equals(symbol,BRCA1)', standard);
      expect(result.symbol.content).toBe('BRCA1');
      expect(result.symbol.operator).toBe('equals');
    });

    it('returns standard object for null input', () => {
      const { filterStrToObj } = useUrlParsing();

      const standard = {
        symbol: { content: null, operator: 'equals', join_char: null },
      };

      const result = filterStrToObj(null, standard);
      expect(result).toEqual(standard);
    });

    it('returns standard object for empty string', () => {
      const { filterStrToObj } = useUrlParsing();

      const standard = {
        symbol: { content: null, operator: 'equals', join_char: null },
      };

      const result = filterStrToObj('', standard);
      expect(result).toEqual(standard);
    });

    it('handles any operator with multiple values', () => {
      const { filterStrToObj } = useUrlParsing();

      const standard = {
        categories: { content: null, operator: 'any', join_char: ',' },
      };

      const result = filterStrToObj('any(categories,1,2,3)', standard);
      expect(result.categories.content).toEqual(['1', '2', '3']);
      expect(result.categories.operator).toBe('any');
    });
  });

  describe('sortStringToVariables', () => {
    it('parses ascending sort string', () => {
      const { sortStringToVariables } = useUrlParsing();

      const result = sortStringToVariables('+entity_id');

      expect(result.sortBy).toEqual([{ key: 'entity_id', order: 'asc' }]);
      expect(result.sortDesc).toBe(false);
      expect(result.sortColumn).toBe('entity_id');
    });

    it('parses descending sort string', () => {
      const { sortStringToVariables } = useUrlParsing();

      const result = sortStringToVariables('-symbol');

      expect(result.sortBy).toEqual([{ key: 'symbol', order: 'desc' }]);
      expect(result.sortDesc).toBe(true);
      expect(result.sortColumn).toBe('symbol');
    });

    it('handles string with spaces', () => {
      const { sortStringToVariables } = useUrlParsing();

      const result = sortStringToVariables('  +entity_id  ');

      expect(result.sortColumn).toBe('entity_id');
    });
  });
});
```
  </action>
  <verify>
Run `npm run test:unit -- --filter=useUrlParsing` - all tests pass.
  </verify>
  <done>Comprehensive tests created for useUrlParsing composable</done>
</task>

<task type="auto">
  <name>Task 3: Test Composables with External Dependencies (useToast, useModalControls)</name>
  <files>app/src/composables/useToast.spec.ts, app/src/composables/useModalControls.spec.ts</files>
  <action>
Create tests for composables that depend on bootstrap-vue-next.

Create `app/src/composables/useToast.spec.ts`:

```typescript
// useToast.spec.ts
/**
 * Tests for useToast composable
 *
 * Pattern: Mocked dependency testing with withSetup
 * This composable uses bootstrap-vue-next's useToast, which must be mocked.
 * Demonstrates the medical app requirement: danger toasts don't auto-hide.
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { withSetup } from '@/test-utils';

// Mock bootstrap-vue-next
const mockCreate = vi.fn();
vi.mock('bootstrap-vue-next', () => ({
  useToast: () => ({
    create: mockCreate,
  }),
}));

// Import after mock is set up
import useToast from './useToast';

describe('useToast', () => {
  beforeEach(() => {
    mockCreate.mockClear();
  });

  it('provides makeToast method', () => {
    const [result, app] = withSetup(() => useToast());

    expect(result.makeToast).toBeDefined();
    expect(typeof result.makeToast).toBe('function');

    app.unmount();
  });

  it('creates toast with string message', () => {
    const [result, app] = withSetup(() => useToast());

    result.makeToast('Test message', 'Test Title', 'success');

    expect(mockCreate).toHaveBeenCalledWith(
      expect.objectContaining({
        body: 'Test message',
        title: 'Test Title',
        variant: 'success',
        pos: 'top-end',
      })
    );

    app.unmount();
  });

  it('extracts message from object with message property', () => {
    const [result, app] = withSetup(() => useToast());

    result.makeToast({ message: 'Object message' }, 'Title', 'info');

    expect(mockCreate).toHaveBeenCalledWith(
      expect.objectContaining({
        body: 'Object message',
      })
    );

    app.unmount();
  });

  describe('medical app requirements', () => {
    it('danger toasts do not auto-hide (critical for error visibility)', () => {
      const [result, app] = withSetup(() => useToast());

      result.makeToast('Critical error', 'Error', 'danger');

      // modelValue: 0 means no auto-hide
      expect(mockCreate).toHaveBeenCalledWith(
        expect.objectContaining({
          variant: 'danger',
          modelValue: 0, // No auto-hide for danger
        })
      );

      app.unmount();
    });

    it('non-danger toasts auto-hide after delay', () => {
      const [result, app] = withSetup(() => useToast());

      result.makeToast('Success message', 'Success', 'success');

      // Default autoHideDelay is 3000
      expect(mockCreate).toHaveBeenCalledWith(
        expect.objectContaining({
          variant: 'success',
          modelValue: 3000, // Auto-hide after 3s
        })
      );

      app.unmount();
    });

    it('respects custom autoHideDelay for non-danger toasts', () => {
      const [result, app] = withSetup(() => useToast());

      result.makeToast('Custom delay', 'Info', 'info', true, 5000);

      expect(mockCreate).toHaveBeenCalledWith(
        expect.objectContaining({
          modelValue: 5000,
        })
      );

      app.unmount();
    });
  });
});
```

Create `app/src/composables/useModalControls.spec.ts`:

```typescript
// useModalControls.spec.ts
/**
 * Tests for useModalControls composable
 *
 * Pattern: Mocked dependency testing with withSetup
 * This composable wraps bootstrap-vue-next's useModal.
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { withSetup } from '@/test-utils';

// Mock bootstrap-vue-next
const mockShow = vi.fn();
const mockHide = vi.fn();
const mockConfirm = vi.fn().mockResolvedValue(true);

vi.mock('bootstrap-vue-next', () => ({
  useModal: () => ({
    show: mockShow,
    hide: mockHide,
    confirm: mockConfirm,
  }),
}));

// Import after mock is set up
import useModalControls from './useModalControls';

describe('useModalControls', () => {
  beforeEach(() => {
    mockShow.mockClear();
    mockHide.mockClear();
    mockConfirm.mockClear();
  });

  it('provides modal control methods', () => {
    const [result, app] = withSetup(() => useModalControls());

    expect(result.showModal).toBeDefined();
    expect(result.hideModal).toBeDefined();
    expect(result.confirm).toBeDefined();

    app.unmount();
  });

  describe('showModal', () => {
    it('calls modal.show with provided ID', () => {
      const [result, app] = withSetup(() => useModalControls());

      result.showModal('my-modal-id');

      expect(mockShow).toHaveBeenCalledWith('my-modal-id');

      app.unmount();
    });
  });

  describe('hideModal', () => {
    it('calls modal.hide with provided ID', () => {
      const [result, app] = withSetup(() => useModalControls());

      result.hideModal('my-modal-id');

      expect(mockHide).toHaveBeenCalledWith('my-modal-id');

      app.unmount();
    });
  });

  describe('confirm', () => {
    it('returns a promise that resolves with user choice', async () => {
      const [result, app] = withSetup(() => useModalControls());

      const confirmed = await result.confirm({ title: 'Confirm?' });

      expect(confirmed).toBe(true);
      expect(mockConfirm).toHaveBeenCalledWith({ title: 'Confirm?' });

      app.unmount();
    });

    it('handles rejection', async () => {
      mockConfirm.mockResolvedValueOnce(false);
      const [result, app] = withSetup(() => useModalControls());

      const confirmed = await result.confirm({ title: 'Cancel?' });

      expect(confirmed).toBe(false);

      app.unmount();
    });
  });
});
```
  </action>
  <verify>
Run `npm run test:unit -- --filter=useToast` - all tests pass.
Run `npm run test:unit -- --filter=useModalControls` - all tests pass.
  </verify>
  <done>Tests created for useToast and useModalControls with mocked dependencies</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run test:unit` - all composable tests pass
2. Coverage includes composables: `npm run test:coverage` shows composable files
3. Each test file demonstrates its pattern clearly with comments
4. No TypeScript errors in test files
</verification>

<success_criteria>
- 5 composable test files created (co-located with source)
- Tests demonstrate:
  - Direct testing for stateless composables (useColorAndSymbols, useText)
  - Pure function testing with edge cases (useUrlParsing)
  - Mocked dependency testing with withSetup (useToast, useModalControls)
- All tests pass with `npm run test:unit`
- Medical app requirement tested (danger toasts don't auto-hide)
</success_criteria>

<output>
After completion, create `.planning/phases/15-testing-infrastructure/15-04-SUMMARY.md`
</output>
