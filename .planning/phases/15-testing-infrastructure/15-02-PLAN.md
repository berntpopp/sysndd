---
phase: 15-testing-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/package.json
  - app/src/test-utils/index.ts
  - app/src/test-utils/with-setup.ts
  - app/src/test-utils/mount-helpers.ts
autonomous: true

must_haves:
  truths:
    - "Vue Test Utils can mount components"
    - "withSetup helper allows testing composables with lifecycle hooks"
    - "Mount helpers provide consistent plugin configuration"
  artifacts:
    - path: "app/src/test-utils/index.ts"
      provides: "Barrel export for all test utilities"
      contains: "export"
    - path: "app/src/test-utils/with-setup.ts"
      provides: "withSetup helper for composable testing"
      contains: "createApp"
    - path: "app/src/test-utils/mount-helpers.ts"
      provides: "Component mounting helpers with plugins"
      contains: "mount"
  key_links:
    - from: "app/src/test-utils/index.ts"
      to: "app/src/test-utils/with-setup.ts"
      via: "re-export"
      pattern: "export.*from.*with-setup"
---

<objective>
Install Vue Test Utils and create test utility helpers for component and composable testing.

Purpose: Provide reusable testing utilities that standardize how components and composables are tested.
Output: @vue/test-utils installed, test-utils directory with withSetup and mount helpers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-testing-infrastructure/15-CONTEXT.md
@.planning/phases/15-testing-infrastructure/15-RESEARCH.md
@app/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Vue Test Utils and Testing Library</name>
  <files>app/package.json</files>
  <action>
Install Vue Test Utils and Testing Library packages:

```bash
cd app && npm install --save-dev @vue/test-utils @testing-library/vue @testing-library/user-event
```

Packages to install:
- @vue/test-utils@2: Official Vue component testing library (low-level API)
- @testing-library/vue@8: User-centric testing (queries by role/label/text)
- @testing-library/user-event: Realistic user event simulation

Both testing approaches are valuable:
- Vue Test Utils for lower-level component testing
- Testing Library for user-behavior focused tests
  </action>
  <verify>
Run `npm list @vue/test-utils @testing-library/vue @testing-library/user-event` to confirm installation.
  </verify>
  <done>Vue Test Utils and Testing Library packages installed</done>
</task>

<task type="auto">
  <name>Task 2: Create withSetup Helper for Composable Testing</name>
  <files>app/src/test-utils/with-setup.ts</files>
  <action>
Create `app/src/test-utils/with-setup.ts`:

```typescript
// test-utils/with-setup.ts
/**
 * Helper for testing composables that use Vue lifecycle hooks.
 * Creates a mini Vue app to provide the lifecycle context.
 *
 * Use this for composables that use:
 * - onMounted, onUnmounted, onBeforeMount, etc.
 * - provide/inject
 * - getCurrentInstance
 *
 * For composables using only ref/computed/watch, test them directly.
 *
 * @example
 * import { withSetup } from '@/test-utils';
 * import useModalControls from '@/composables/useModalControls';
 *
 * describe('useModalControls', () => {
 *   it('provides modal methods', () => {
 *     const [result, app] = withSetup(() => useModalControls());
 *     expect(result.showModal).toBeDefined();
 *     app.unmount();
 *   });
 * });
 */

import { createApp, type App } from 'vue';

type ComposableResult<T> = [T, App<Element>];

/**
 * Wraps a composable call in a Vue app context for testing.
 *
 * @param composable - Function that calls the composable
 * @returns Tuple of [composable result, Vue app instance]
 */
export function withSetup<T>(composable: () => T): ComposableResult<T> {
  let result: T;

  const app = createApp({
    setup() {
      result = composable();
      // Return empty render function - we only need the setup context
      return () => {};
    },
  });

  app.mount(document.createElement('div'));

  // @ts-expect-error - result is assigned in setup before mount completes
  return [result, app];
}

export default withSetup;
```

Key design decisions:
- Returns tuple [result, app] so tests can call app.unmount() for cleanup
- Uses document.createElement('div') for DOM attachment
- Generic type T preserves composable return type
- @ts-expect-error for result since TS can't know it's assigned during mount
  </action>
  <verify>
Run `npx tsc --noEmit -p tsconfig.json` - no TypeScript errors.
  </verify>
  <done>withSetup helper created with proper TypeScript types</done>
</task>

<task type="auto">
  <name>Task 3: Create Mount Helpers for Component Testing</name>
  <files>app/src/test-utils/mount-helpers.ts</files>
  <action>
Create `app/src/test-utils/mount-helpers.ts`:

```typescript
// test-utils/mount-helpers.ts
/**
 * Mount helpers for consistent component testing.
 * Provides pre-configured mounting with common plugins and stubs.
 */

import { mount, type MountingOptions, type VueWrapper } from '@vue/test-utils';
import { createRouter, createWebHistory, type RouteRecordRaw } from 'vue-router';
import { createPinia } from 'pinia';
import type { Component } from 'vue';

/**
 * Default route for tests that need vue-router
 */
const defaultRoutes: RouteRecordRaw[] = [
  { path: '/', name: 'Home', component: { template: '<div>Home</div>' } },
  { path: '/test', name: 'Test', component: { template: '<div>Test</div>' } },
];

/**
 * Creates a router instance for testing
 */
export function createTestRouter(routes: RouteRecordRaw[] = defaultRoutes) {
  return createRouter({
    history: createWebHistory(),
    routes,
  });
}

/**
 * Mount a component with router plugin
 *
 * @example
 * const wrapper = await mountWithRouter(Navbar);
 * expect(wrapper.find('nav').exists()).toBe(true);
 */
export async function mountWithRouter<T extends Component>(
  component: T,
  options: MountingOptions<T> = {}
): Promise<VueWrapper<InstanceType<T>>> {
  const router = createTestRouter();
  await router.push('/');
  await router.isReady();

  return mount(component, {
    global: {
      plugins: [router],
      ...options.global,
    },
    ...options,
  }) as VueWrapper<InstanceType<T>>;
}

/**
 * Mount a component with Pinia store plugin
 *
 * @example
 * const wrapper = mountWithStore(MyComponent);
 */
export function mountWithStore<T extends Component>(
  component: T,
  options: MountingOptions<T> = {}
): VueWrapper<InstanceType<T>> {
  const pinia = createPinia();

  return mount(component, {
    global: {
      plugins: [pinia],
      ...options.global,
    },
    ...options,
  }) as VueWrapper<InstanceType<T>>;
}

/**
 * Mount a component with both router and store
 *
 * @example
 * const wrapper = await mountWithPlugins(MyComponent, {
 *   props: { foo: 'bar' }
 * });
 */
export async function mountWithPlugins<T extends Component>(
  component: T,
  options: MountingOptions<T> = {}
): Promise<VueWrapper<InstanceType<T>>> {
  const router = createTestRouter();
  const pinia = createPinia();

  await router.push('/');
  await router.isReady();

  return mount(component, {
    global: {
      plugins: [router, pinia],
      ...options.global,
    },
    ...options,
  }) as VueWrapper<InstanceType<T>>;
}

/**
 * Common stubs for Bootstrap-Vue-Next components
 * Use when you don't need actual Bootstrap component behavior
 */
export const bootstrapStubs = {
  BNavbar: { template: '<nav><slot /></nav>' },
  BNavbarBrand: { template: '<a><slot /></a>' },
  BNavbarToggle: { template: '<button />' },
  BNavbarNav: { template: '<ul><slot /></ul>' },
  BNavItem: { template: '<li><slot /></li>' },
  BCollapse: { template: '<div><slot /></div>' },
  BDropdown: { template: '<div class="dropdown"><slot /><slot name="button-content" /></div>' },
  BDropdownItem: { template: '<a><slot /></a>' },
  BButton: { template: '<button><slot /></button>' },
  BAlert: { template: '<div role="alert"><slot /></div>' },
  BContainer: { template: '<div><slot /></div>' },
  BRow: { template: '<div><slot /></div>' },
  BCol: { template: '<div><slot /></div>' },
  BLink: { template: '<a><slot /></a>' },
};

export default {
  withSetup: () => {
    throw new Error('Import withSetup from @/test-utils/with-setup');
  },
  createTestRouter,
  mountWithRouter,
  mountWithStore,
  mountWithPlugins,
  bootstrapStubs,
};
```

Key design decisions:
- Async mountWithRouter because router.isReady() is async
- Bootstrap stubs for isolating component behavior from Bootstrap
- Pinia created fresh per test to avoid state leakage
  </action>
  <verify>
Run `npx tsc --noEmit -p tsconfig.json` - no TypeScript errors.
  </verify>
  <done>Mount helpers created with router, store, and bootstrap stub support</done>
</task>

<task type="auto">
  <name>Task 4: Create Test Utils Barrel Export</name>
  <files>app/src/test-utils/index.ts</files>
  <action>
Create `app/src/test-utils/index.ts` as the barrel export:

```typescript
// test-utils/index.ts
/**
 * Test utilities barrel export
 *
 * Import all test utilities from here:
 * import { withSetup, mountWithRouter, bootstrapStubs } from '@/test-utils';
 */

export { withSetup } from './with-setup';
export {
  createTestRouter,
  mountWithRouter,
  mountWithStore,
  mountWithPlugins,
  bootstrapStubs,
} from './mount-helpers';

// Re-export common testing utilities for convenience
export { mount, shallowMount } from '@vue/test-utils';
export { render, screen, fireEvent, waitFor } from '@testing-library/vue';
export { default as userEvent } from '@testing-library/user-event';
```

This provides a single import point for all test utilities.
  </action>
  <verify>
Run `npx tsc --noEmit -p tsconfig.json` - no TypeScript errors.
Verify the file exists with exports.
  </verify>
  <done>Test utils barrel export created with all helpers</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. All packages installed: `npm list @vue/test-utils @testing-library/vue`
2. No TypeScript errors: `cd app && npx tsc --noEmit`
3. test-utils directory exists with index.ts, with-setup.ts, mount-helpers.ts
4. All exports work: imports should resolve without errors
</verification>

<success_criteria>
- @vue/test-utils@2 and @testing-library/vue@8 installed
- test-utils/with-setup.ts created with composable testing helper
- test-utils/mount-helpers.ts created with router/store/plugin helpers
- test-utils/index.ts barrel export created
- All files have proper TypeScript types
</success_criteria>

<output>
After completion, create `.planning/phases/15-testing-infrastructure/15-02-SUMMARY.md`
</output>
