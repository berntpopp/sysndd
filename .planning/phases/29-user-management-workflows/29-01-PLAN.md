---
phase: 29-user-management-workflows
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/endpoints/user_endpoints.R
  - api/services/user-service.R
autonomous: true

must_haves:
  truths:
    - "Bulk approve endpoint accepts array of user_ids and approves all atomically"
    - "Bulk delete endpoint accepts array of user_ids and deletes all atomically"
    - "Bulk role assignment endpoint accepts user_ids and role, assigns atomically"
    - "All bulk endpoints validate max 20 users per request"
    - "Bulk delete rejects requests containing admin users"
  artifacts:
    - path: "api/endpoints/user_endpoints.R"
      provides: "bulk_approve, bulk_delete, bulk_assign_role endpoints"
      contains: "bulk_approve"
    - path: "api/services/user-service.R"
      provides: "user_bulk_approve, user_bulk_delete, user_bulk_assign_role functions"
      contains: "user_bulk_approve"
  key_links:
    - from: "api/endpoints/user_endpoints.R"
      to: "api/services/user-service.R"
      via: "service function calls"
      pattern: "user_bulk_approve|user_bulk_delete|user_bulk_assign_role"
---

<objective>
Add three bulk user management endpoints with ATOMIC transaction semantics

Purpose: Enable frontend to perform bulk operations (approve, delete, role assignment) on multiple users in a single API call with all-or-nothing guarantees.

Output: Three new POST endpoints - /api/user/bulk_approve, /api/user/bulk_delete, /api/user/bulk_assign_role
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-user-management-workflows/29-CONTEXT.md
@.planning/phases/29-user-management-workflows/29-RESEARCH.md

@api/endpoints/user_endpoints.R
@api/services/user-service.R
@api/functions/user-repository.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add bulk service functions to user-service.R</name>
  <files>api/services/user-service.R</files>
  <action>
Add three new service functions following existing patterns:

1. `user_bulk_approve(user_ids, approving_user_id, pool)`:
   - Validates array length <= 20, returns error if exceeded
   - Wraps all operations in database transaction (use pool %>% dbBegin/dbCommit/dbRollback pattern)
   - For each user_id: call existing user_approve logic (sets approved=1, generates password, sends email)
   - If ANY user fails (not found, already approved), rollback ALL and return error
   - Return { processed: N, message: "..." } on success

2. `user_bulk_delete(user_ids, requesting_user_id, pool)`:
   - Validates array length <= 20
   - First, query all user_ids to get their roles
   - If ANY user has role="Administrator", reject entire request with clear message: "Cannot delete: selection contains admin users"
   - Wrap deletions in transaction - all or nothing
   - Return { processed: N, message: "..." } on success

3. `user_bulk_assign_role(user_ids, new_role, requesting_role, pool)`:
   - Validates array length <= 20
   - Validates new_role is valid (Administrator, Curator, Reviewer, Viewer)
   - If requesting_role is Curator and new_role is Administrator, reject
   - Wrap role updates in transaction
   - Return { processed: N, message: "..." } on success

Use existing patterns from user_approve, user_update_role. Transaction pattern:
```r
con <- poolCheckout(pool)
tryCatch({
  DBI::dbBegin(con)
  # ... operations ...
  DBI::dbCommit(con)
  result
}, error = function(e) {
  DBI::dbRollback(con)
  stop(e$message)
}, finally = {
  poolReturn(con)
})
```
  </action>
  <verify>Check file syntax: `R -e "parse('api/services/user-service.R')"`</verify>
  <done>Three bulk service functions exist with transaction semantics and validation</done>
</task>

<task type="auto">
  <name>Task 2: Add bulk endpoints to user_endpoints.R</name>
  <files>api/endpoints/user_endpoints.R</files>
  <action>
Add three new POST endpoints after existing endpoints:

1. `#* @post bulk_approve` endpoint:
   - Requires Curator role or higher (use require_role)
   - Accepts JSON body with user_ids array
   - Calls user_bulk_approve service function
   - Returns 200 with { processed: N, message: "..." } on success
   - Returns 400 if validation fails (>20 users, empty array)
   - Returns 409 if any user operation fails (with rollback)

2. `#* @post bulk_delete` endpoint:
   - Requires Administrator role (only admins can bulk delete)
   - Accepts JSON body with user_ids array
   - Calls user_bulk_delete service function
   - Returns 200 with { processed: N, message: "..." } on success
   - Returns 400 if >20 users or empty array
   - Returns 403 if selection contains admin users (with clear message)

3. `#* @post bulk_assign_role` endpoint:
   - Requires Curator role or higher
   - Accepts JSON body with { user_ids: [...], role: "Curator" }
   - Calls user_bulk_assign_role service function
   - Returns 200 with { processed: N, message: "..." } on success
   - Returns 400 for invalid role or >20 users
   - Returns 403 if Curator tries to assign Administrator role

Follow existing endpoint patterns in file. Use @serializer json list(na="null").
Add @tag user for OpenAPI grouping.
  </action>
  <verify>Check file syntax: `R -e "parse('api/endpoints/user_endpoints.R')"`</verify>
  <done>Three bulk endpoints exist with proper role requirements and error handling</done>
</task>

<task type="auto">
  <name>Task 3: Verify API loads without errors</name>
  <files>api/endpoints/user_endpoints.R, api/services/user-service.R</files>
  <action>
Run a syntax check on both modified files to ensure no R parsing errors.

Check that:
1. Both files parse without errors
2. Function definitions are complete (matching braces)
3. Required packages are available (DBI, pool already in renv.lock)

If Docker is available, optionally start the API container to verify it loads:
```bash
docker compose -f docker-compose.dev.yml up -d api
docker compose -f docker-compose.dev.yml logs api | head -50
```
Look for successful startup message, not "Error loading endpoints".
  </action>
  <verify>`R -e "parse('api/endpoints/user_endpoints.R'); parse('api/services/user-service.R'); cat('Syntax OK\n')"`</verify>
  <done>Both R files parse successfully, API can start</done>
</task>

</tasks>

<verification>
- [ ] `R -e "parse('api/services/user-service.R')"` succeeds
- [ ] `R -e "parse('api/endpoints/user_endpoints.R')"` succeeds
- [ ] user_bulk_approve function exists with transaction wrapper
- [ ] user_bulk_delete function validates no admin users in selection
- [ ] user_bulk_assign_role respects Curator permission restrictions
- [ ] All endpoints require appropriate role (Curator+ for approve/role, Admin for delete)
- [ ] All endpoints validate max 20 users per request
</verification>

<success_criteria>
- Three bulk service functions in user-service.R with ATOMIC transaction semantics
- Three bulk endpoints in user_endpoints.R with proper auth and validation
- Max 20 user limit enforced at both service and endpoint level
- Admin deletion protection enforced (cannot bulk-delete admins)
- R syntax valid for both files
</success_criteria>

<output>
After completion, create `.planning/phases/29-user-management-workflows/29-01-SUMMARY.md`
</output>
