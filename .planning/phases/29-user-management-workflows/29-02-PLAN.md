---
phase: 29-user-management-workflows
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/src/composables/useBulkSelection.ts
  - app/src/composables/useFilterPresets.ts
  - app/src/composables/index.ts
  - app/src/types/models.ts
autonomous: true

must_haves:
  truths:
    - "useBulkSelection tracks selected IDs across pagination using reactive Set"
    - "Selection count is reactive and updates immediately on toggle"
    - "useBulkSelection enforces maximum selection limit (20)"
    - "useFilterPresets persists presets to localStorage"
    - "Filter presets are loaded reactively and survive page refresh"
  artifacts:
    - path: "app/src/composables/useBulkSelection.ts"
      provides: "Cross-page selection tracking composable"
      exports: ["useBulkSelection"]
    - path: "app/src/composables/useFilterPresets.ts"
      provides: "localStorage filter preset composable"
      exports: ["useFilterPresets"]
    - path: "app/src/composables/index.ts"
      provides: "Barrel exports for new composables"
      contains: "useBulkSelection"
  key_links:
    - from: "app/src/composables/useBulkSelection.ts"
      to: "vue"
      via: "ref, computed from vue"
      pattern: "import.*from 'vue'"
    - from: "app/src/composables/useFilterPresets.ts"
      to: "@vueuse/core"
      via: "useLocalStorage"
      pattern: "import.*useLocalStorage.*from '@vueuse/core'"
---

<objective>
Create reusable composables for bulk selection and filter presets

Purpose: Provide clean, tested abstractions for cross-page selection tracking and localStorage-based filter preset management that ManageUser.vue will consume.

Output: Two new composables (useBulkSelection.ts, useFilterPresets.ts) with TypeScript types
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-user-management-workflows/29-CONTEXT.md
@.planning/phases/29-user-management-workflows/29-RESEARCH.md

@app/src/composables/index.ts
@app/src/composables/useToast.ts
@app/src/types/models.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useBulkSelection composable</name>
  <files>app/src/composables/useBulkSelection.ts</files>
  <action>
Create a new composable for Set-based cross-page selection tracking.

Following the pattern from 29-RESEARCH.md (NetworkVisualization.vue Set pattern):

```typescript
import { ref, computed } from 'vue';
import type { Ref, ComputedRef } from 'vue';

export interface BulkSelectionReturn<T = number> {
  selectedIds: Ref<Set<T>>;
  selectionCount: ComputedRef<number>;
  isSelected: (id: T) => boolean;
  toggleSelection: (id: T) => boolean; // Returns false if limit reached
  selectMultiple: (ids: T[]) => number; // Returns count of newly selected
  clearSelection: () => void;
  getSelectedArray: () => T[];
}

export function useBulkSelection<T = number>(
  maxSelection: number = 20
): BulkSelectionReturn<T> {
  const selectedIds = ref(new Set<T>()) as Ref<Set<T>>;

  const selectionCount = computed(() => selectedIds.value.size);

  const isSelected = (id: T): boolean => selectedIds.value.has(id);

  const toggleSelection = (id: T): boolean => {
    const newSet = new Set(selectedIds.value);

    if (newSet.has(id)) {
      newSet.delete(id);
      selectedIds.value = newSet;
      return true;
    }

    // Check limit before adding
    if (newSet.size >= maxSelection) {
      return false; // Limit reached, caller should show warning
    }

    newSet.add(id);
    selectedIds.value = newSet;
    return true;
  };

  const selectMultiple = (ids: T[]): number => {
    const newSet = new Set(selectedIds.value);
    let added = 0;

    for (const id of ids) {
      if (newSet.size >= maxSelection) break;
      if (!newSet.has(id)) {
        newSet.add(id);
        added++;
      }
    }

    selectedIds.value = newSet;
    return added;
  };

  const clearSelection = (): void => {
    selectedIds.value = new Set();
  };

  const getSelectedArray = (): T[] => Array.from(selectedIds.value);

  return {
    selectedIds,
    selectionCount,
    isSelected,
    toggleSelection,
    selectMultiple,
    clearSelection,
    getSelectedArray,
  };
}

export default useBulkSelection;
```

Key points:
- Generic type T (default number) for flexibility
- Always create new Set and reassign for Vue reactivity
- toggleSelection returns false if limit reached (caller shows toast)
- selectMultiple returns count of newly added items
  </action>
  <verify>`cd /home/bernt-popp/development/sysndd/app && npx tsc --noEmit src/composables/useBulkSelection.ts`</verify>
  <done>useBulkSelection.ts exists with all methods, TypeScript compiles</done>
</task>

<task type="auto">
  <name>Task 2: Create useFilterPresets composable</name>
  <files>app/src/composables/useFilterPresets.ts</files>
  <action>
Create a composable for localStorage-based filter preset management.

Following 29-RESEARCH.md pattern with VueUse useLocalStorage:

```typescript
import { useLocalStorage } from '@vueuse/core';
import type { Ref } from 'vue';

export interface FilterPreset {
  name: string;
  filter: Record<string, unknown>;
  created: string; // ISO date string
}

export interface FilterPresetsReturn {
  presets: Ref<FilterPreset[]>;
  savePreset: (name: string, filter: Record<string, unknown>) => void;
  loadPreset: (name: string) => Record<string, unknown> | null;
  deletePreset: (name: string) => void;
  hasPreset: (name: string) => boolean;
  getPresetNames: () => string[];
}

export function useFilterPresets(
  storageKey: string = 'sysndd-filter-presets'
): FilterPresetsReturn {
  // Reactive localStorage binding with JSON serialization
  const presets = useLocalStorage<FilterPreset[]>(storageKey, [], {
    serializer: {
      read: (v: string): FilterPreset[] => {
        try {
          return v ? JSON.parse(v) : [];
        } catch {
          return [];
        }
      },
      write: (v: FilterPreset[]): string => JSON.stringify(v),
    },
  });

  const savePreset = (name: string, filter: Record<string, unknown>): void => {
    const trimmedName = name.trim();
    if (!trimmedName) return;

    const preset: FilterPreset = {
      name: trimmedName,
      filter: JSON.parse(JSON.stringify(filter)), // Deep copy
      created: new Date().toISOString(),
    };

    const existingIndex = presets.value.findIndex(p => p.name === trimmedName);
    if (existingIndex >= 0) {
      // Update existing (creates new array for reactivity)
      presets.value = [
        ...presets.value.slice(0, existingIndex),
        preset,
        ...presets.value.slice(existingIndex + 1),
      ];
    } else {
      // Add new
      presets.value = [...presets.value, preset];
    }
  };

  const loadPreset = (name: string): Record<string, unknown> | null => {
    const preset = presets.value.find(p => p.name === name);
    if (!preset) return null;
    // Return deep copy to prevent mutation
    return JSON.parse(JSON.stringify(preset.filter));
  };

  const deletePreset = (name: string): void => {
    presets.value = presets.value.filter(p => p.name !== name);
  };

  const hasPreset = (name: string): boolean => {
    return presets.value.some(p => p.name === name);
  };

  const getPresetNames = (): string[] => {
    return presets.value.map(p => p.name);
  };

  return {
    presets,
    savePreset,
    loadPreset,
    deletePreset,
    hasPreset,
    getPresetNames,
  };
}

export default useFilterPresets;
```

Key points:
- Uses VueUse useLocalStorage for reactive binding
- Deep copies filter objects on save/load to prevent mutation
- Handles empty/invalid localStorage gracefully
- Custom serializer for type safety
  </action>
  <verify>`cd /home/bernt-popp/development/sysndd/app && npx tsc --noEmit src/composables/useFilterPresets.ts`</verify>
  <done>useFilterPresets.ts exists with localStorage persistence, TypeScript compiles</done>
</task>

<task type="auto">
  <name>Task 3: Export composables from barrel and add types</name>
  <files>app/src/composables/index.ts, app/src/types/models.ts</files>
  <action>
1. Update app/src/composables/index.ts to export new composables:

Add after existing exports (near bottom of file):
```typescript
// Bulk selection for admin tables
export { useBulkSelection } from './useBulkSelection';
export type { BulkSelectionReturn } from './useBulkSelection';

// Filter presets for admin tables
export { useFilterPresets } from './useFilterPresets';
export type { FilterPreset, FilterPresetsReturn } from './useFilterPresets';
```

2. Add BulkActionResult type to app/src/types/models.ts for API responses:

Find appropriate section (or add at end) and add:
```typescript
/**
 * Response type for bulk user operations (approve, delete, role assignment)
 */
export interface BulkActionResult {
  success: boolean;
  processed: number;
  failed: number;
  message: string;
  errors?: Array<{ user_id: number; error: string }>;
}
```

This type will be used when calling bulk API endpoints.
  </action>
  <verify>`cd /home/bernt-popp/development/sysndd/app && npx tsc --noEmit src/composables/index.ts`</verify>
  <done>Both composables exported from barrel, BulkActionResult type added</done>
</task>

</tasks>

<verification>
- [ ] `npx tsc --noEmit src/composables/useBulkSelection.ts` passes
- [ ] `npx tsc --noEmit src/composables/useFilterPresets.ts` passes
- [ ] `npx tsc --noEmit src/composables/index.ts` passes
- [ ] useBulkSelection exports selectionCount, toggleSelection, clearSelection, getSelectedArray
- [ ] useFilterPresets exports presets, savePreset, loadPreset, deletePreset
- [ ] Both composables follow existing codebase patterns (see useToast.ts)
- [ ] BulkActionResult interface added to models.ts
</verification>

<success_criteria>
- useBulkSelection.ts: Set-based selection with max limit enforcement
- useFilterPresets.ts: localStorage persistence via VueUse
- Both composables exported from index.ts barrel
- BulkActionResult type available for API response typing
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/29-user-management-workflows/29-02-SUMMARY.md`
</output>
