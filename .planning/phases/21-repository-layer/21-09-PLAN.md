---
phase: 21-repository-layer
plan: 09
type: execute
wave: 1
depends_on: []
files_modified:
  - api/endpoints/authentication_endpoints.R
  - api/functions/publication-functions.R
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User signup inserts use db_execute_statement with parameterized INSERT"
    - "Publication inserts use db_execute_statement with parameterized INSERT"
    - "Zero dbAppendTable calls remain in these files"
  artifacts:
    - path: "api/endpoints/authentication_endpoints.R"
      provides: "User signup using db-helpers"
      contains: "db_execute_statement"
    - path: "api/functions/publication-functions.R"
      provides: "Publication insert using db-helpers"
      contains: "db_execute_statement"
  key_links:
    - from: "authentication_endpoints.R"
      to: "db-helpers.R"
      via: "db_execute_statement call"
      pattern: "db_execute_statement\\("
    - from: "publication-functions.R"
      to: "db-helpers.R"
      via: "db_execute_statement call"
      pattern: "db_execute_statement\\("
---

<objective>
Replace poolWithTransaction + dbAppendTable patterns in authentication_endpoints.R and publication-functions.R with db_execute_statement using parameterized INSERT queries.

Purpose: Close verification gap - these files bypass the db-helpers layer with direct DBI calls
Output: Both files use db_execute_statement for database inserts, consistent with repository layer
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-repository-layer/21-VERIFICATION.md
@api/functions/db-helpers.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate authentication_endpoints.R signup insert to db_execute_statement</name>
  <files>api/endpoints/authentication_endpoints.R</files>
  <action>
Replace the poolWithTransaction + dbAppendTable pattern (lines 82-85) with db_execute_statement:

Current pattern:
```r
poolWithTransaction(pool, function(conn) {
  dbAppendTable(conn, "user", user)
})
```

Replace with parameterized INSERT using db_execute_statement:
```r
# Build INSERT with explicit column names matching tibble structure
# CRITICAL: Column order in INSERT must match parameter list order
cols <- names(user)
placeholders <- paste(rep("?", length(cols)), collapse = ", ")
sql <- sprintf("INSERT INTO user (%s) VALUES (%s)", paste(cols, collapse = ", "), placeholders)
db_execute_statement(sql, as.list(user))
```

This approach dynamically builds the INSERT from the tibble's column names, ensuring:
1. Column order matches parameter order (uses names(tibble))
2. No manual column list to maintain
3. Works regardless of which columns are present in the user tibble

Alternatively, if you prefer explicit columns for documentation:
```r
db_execute_statement(
  "INSERT INTO user (user_name, first_name, family_name, email, orcid, comment, terms_agreed)
   VALUES (?, ?, ?, ?, ?, ?, ?)",
  list(
    user$user_name,
    user$first_name,
    user$family_name,
    user$email,
    user$orcid,
    user$comment,
    user$terms_agreed
  )
)
```

Key changes:
- Remove poolWithTransaction wrapper (db_execute_statement handles connection)
- Use explicit INSERT with ? placeholders
- Pass values as list in column order
- Single insert does not need transaction wrapper

Ensure db-helpers.R is sourced at top of file if not already:
```r
source("functions/db-helpers.R", local = TRUE)
```
  </action>
  <verify>
1. `grep -n "dbAppendTable" api/endpoints/authentication_endpoints.R` returns empty
2. `grep -n "poolWithTransaction" api/endpoints/authentication_endpoints.R` returns empty
3. `grep -n "db_execute_statement" api/endpoints/authentication_endpoints.R` returns the INSERT line
4. Syntax check: `R -e "source('api/endpoints/authentication_endpoints.R', local=TRUE)"` - no errors
5. **Column order verification**: If using dynamic approach, verify `names(user)` matches database table column expectations. If using explicit approach, verify the parameter list order matches the INSERT column order.
  </verify>
  <done>User signup in authentication_endpoints.R uses db_execute_statement with parameterized INSERT query, column order verified</done>
</task>

<task type="auto">
  <name>Task 2: Migrate publication-functions.R insert to db_execute_statement</name>
  <files>api/functions/publication-functions.R</files>
  <action>
Replace the poolWithTransaction + dbAppendTable pattern (lines 82-86) with db_execute_statement:

Current pattern (in new_publication function):
```r
if (nrow(publications_list_collected_info) > 0) {
  poolWithTransaction(pool, function(conn) {
    dbAppendTable(conn, "publication", publications_list_collected_info)
  })
}
```

Replace with a loop using db_execute_statement with dynamic column names:
```r
if (nrow(publications_list_collected_info) > 0) {
  # Insert each publication using parameterized query
  # Use names(tibble) to ensure column order matches INSERT statement
  cols <- names(publications_list_collected_info)
  placeholders <- paste(rep("?", length(cols)), collapse = ", ")
  sql <- sprintf("INSERT INTO publication (%s) VALUES (%s)", paste(cols, collapse = ", "), placeholders)

  for (i in seq_len(nrow(publications_list_collected_info))) {
    row <- publications_list_collected_info[i, ]
    db_execute_statement(sql, as.list(row))
  }
}
```

This approach:
1. Builds INSERT dynamically from tibble column names
2. Guarantees column order matches parameter order (both from names())
3. No manual column list to fall out of sync

Alternatively, if explicit column documentation preferred, verify column order against tibble:
```r
# First, verify the tibble structure from info_from_pmid() / info_from_genereviews_pmid()
# Expected columns: publication_id, other_publication_id, Title, Abstract,
#   Publication_date, Journal_abbreviation, Journal, Keywords, Lastname, Firstname
for (i in seq_len(nrow(publications_list_collected_info))) {
  row <- publications_list_collected_info[i, ]
  db_execute_statement(
    "INSERT INTO publication (publication_id, other_publication_id, Title, Abstract,
     Publication_date, Journal_abbreviation, Journal, Keywords, Lastname, Firstname)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
    list(
      row$publication_id,
      row$other_publication_id,
      row$Title,
      row$Abstract,
      row$Publication_date,
      row$Journal_abbreviation,
      row$Journal,
      row$Keywords,
      row$Lastname,
      row$Firstname
    )
  )
}
```

Key changes:
- Remove poolWithTransaction wrapper
- Use explicit INSERT with ? placeholders
- Loop through rows (typically few publications at a time)
- Each insert uses db_execute_statement

Add source statement at top of file if not present:
```r
source("functions/db-helpers.R", local = TRUE)
```
  </action>
  <verify>
1. `grep -n "dbAppendTable" api/functions/publication-functions.R` returns empty
2. `grep -n "poolWithTransaction" api/functions/publication-functions.R` returns empty
3. `grep -n "db_execute_statement" api/functions/publication-functions.R` returns the INSERT line
4. Syntax check: `R -e "source('api/functions/publication-functions.R', local=TRUE)"` - no errors
5. **Column order verification**: Check that `names(publications_list_collected_info)` output from info_from_pmid()/info_from_genereviews_pmid() matches the INSERT column order. Run: `grep -A 20 "info_from_pmid\|info_from_genereviews_pmid" api/functions/publication-functions.R` to verify tibble structure.
  </verify>
  <done>Publication insert in publication-functions.R uses db_execute_statement with parameterized INSERT queries, column order verified against tibble structure</done>
</task>

</tasks>

<verification>
Run gap verification for this plan:
```bash
# Check no direct DBI calls remain
grep -n "dbAppendTable\|poolWithTransaction" api/endpoints/authentication_endpoints.R api/functions/publication-functions.R

# Check db-helpers are used
grep -n "db_execute_statement" api/endpoints/authentication_endpoints.R api/functions/publication-functions.R

# Both should source db-helpers.R
grep -n "source.*db-helpers" api/endpoints/authentication_endpoints.R api/functions/publication-functions.R

# Column order verification for parameterized inserts
# For authentication_endpoints.R - check user tibble columns match INSERT order
grep -B5 -A15 "db_execute_statement.*INSERT INTO user" api/endpoints/authentication_endpoints.R

# For publication-functions.R - check publication tibble columns match INSERT order
grep -B5 -A15 "db_execute_statement.*INSERT INTO publication" api/functions/publication-functions.R
```
Expected: First grep returns empty, second and third return matches.
</verification>

<success_criteria>
- Zero dbAppendTable calls in authentication_endpoints.R
- Zero dbAppendTable calls in publication-functions.R
- Zero poolWithTransaction calls in both files
- Both files source db-helpers.R
- Both files use db_execute_statement for inserts
- Column order in INSERT statements verified to match tibble structure
- Existing functionality preserved (same data inserted)
</success_criteria>

<output>
After completion, create `.planning/phases/21-repository-layer/21-09-SUMMARY.md`
</output>
