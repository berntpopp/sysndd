---
phase: 21-repository-layer
plan: 10
type: execute
wave: 1
depends_on: []
files_modified:
  - api/endpoints/admin_endpoints.R
  - api/functions/pubtator-functions.R
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Admin endpoint transactions use db_execute_statement inside db_with_transaction"
    - "Pubtator transactions use db_with_transaction with db_execute_query/db_execute_statement"
    - "Zero poolCheckout/dbExecute/dbGetQuery/dbAppendTable/dbBegin/dbCommit/dbRollback calls remain"
  artifacts:
    - path: "api/endpoints/admin_endpoints.R"
      provides: "Admin transactions using db-helpers"
      contains: "db_execute_statement"
    - path: "api/functions/pubtator-functions.R"
      provides: "Pubtator transactions using db-helpers"
      contains: "db_with_transaction"
  key_links:
    - from: "admin_endpoints.R"
      to: "db-helpers.R"
      via: "db_with_transaction + db_execute_statement"
      pattern: "db_with_transaction\\("
    - from: "pubtator-functions.R"
      to: "db-helpers.R"
      via: "db_with_transaction + db_execute_query"
      pattern: "db_with_transaction\\("
---

<objective>
Refactor admin_endpoints.R and pubtator-functions.R to use db-helpers for all database operations, eliminating direct DBI calls (poolCheckout, dbExecute, dbGetQuery, dbAppendTable, dbBegin, dbCommit, dbRollback).

Purpose: Close verification gap - these files have complex transactions that bypass db-helpers
Output: Both files use db_with_transaction with db_execute_query/db_execute_statement consistently
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-repository-layer/21-VERIFICATION.md
@api/functions/db-helpers.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor admin_endpoints.R ontology and HGNC update transactions</name>
  <files>api/endpoints/admin_endpoints.R</files>
  <action>
The file has two functions with direct DBI calls inside db_with_transaction blocks. The issue is that INSIDE the db_with_transaction, the code manually checks out a connection and uses direct DBI calls. This defeats the purpose.

**Function 1: update_ontology (lines 140-166)**

Current broken pattern:
```r
db_with_transaction({
  conn <- poolCheckout(pool)
  on.exit(poolReturn(conn), add = TRUE)
  dbExecute(conn, "SET FOREIGN_KEY_CHECKS = 0;")
  dbExecute(conn, "TRUNCATE TABLE disease_ontology_set;")
  dbAppendTable(conn, "disease_ontology_set", disease_ontology_set_update)
  dbExecute(conn, "TRUNCATE TABLE ndd_entity;")
  dbAppendTable(conn, "ndd_entity", ndd_entity_mutated)
  dbExecute(conn, "SET FOREIGN_KEY_CHECKS = 1;")
})
```

Replace with db_execute_statement calls (db_with_transaction already handles connection):
```r
db_with_transaction({
  db_execute_statement("SET FOREIGN_KEY_CHECKS = 0")
  db_execute_statement("TRUNCATE TABLE disease_ontology_set")

  # Insert disease_ontology_set rows
  for (i in seq_len(nrow(disease_ontology_set_update))) {
    row <- disease_ontology_set_update[i, ]
    db_execute_statement(
      "INSERT INTO disease_ontology_set (disease_ontology_id_version, disease_ontology_id, hgnc_id, hpo_mode_of_inheritance_term, disease_ontology_name)
       VALUES (?, ?, ?, ?, ?)",
      list(row$disease_ontology_id_version, row$disease_ontology_id, row$hgnc_id, row$hpo_mode_of_inheritance_term, row$disease_ontology_name)
    )
  }

  db_execute_statement("TRUNCATE TABLE ndd_entity")

  # Insert ndd_entity rows - use all columns from tibble
  for (i in seq_len(nrow(ndd_entity_mutated))) {
    row <- ndd_entity_mutated[i, ]
    # Build INSERT with all columns from the tibble
    cols <- names(row)
    placeholders <- paste(rep("?", length(cols)), collapse = ", ")
    sql <- sprintf("INSERT INTO ndd_entity (%s) VALUES (%s)", paste(cols, collapse = ", "), placeholders)
    db_execute_statement(sql, as.list(row))
  }

  db_execute_statement("SET FOREIGN_KEY_CHECKS = 1")
})
```

**Function 2: update_hgnc_data (lines 200-222)**

Current broken pattern:
```r
db_with_transaction({
  conn <- poolCheckout(pool)
  on.exit(poolReturn(conn), add = TRUE)
  dbExecute(conn, "SET FOREIGN_KEY_CHECKS = 0;")
  dbExecute(conn, "TRUNCATE TABLE non_alt_loci_set;")
  dbWriteTable(conn, "non_alt_loci_set", hgnc_data, append = TRUE)
  dbExecute(conn, "SET FOREIGN_KEY_CHECKS = 1;")
})
```

Replace with:
```r
db_with_transaction({
  db_execute_statement("SET FOREIGN_KEY_CHECKS = 0")
  db_execute_statement("TRUNCATE TABLE non_alt_loci_set")

  # Insert hgnc_data rows
  for (i in seq_len(nrow(hgnc_data))) {
    row <- hgnc_data[i, ]
    cols <- names(row)
    placeholders <- paste(rep("?", length(cols)), collapse = ", ")
    sql <- sprintf("INSERT INTO non_alt_loci_set (%s) VALUES (%s)", paste(cols, collapse = ", "), placeholders)
    db_execute_statement(sql, as.list(row))
  }

  db_execute_statement("SET FOREIGN_KEY_CHECKS = 1")
})
```

Add source at top if not present:
```r
source("functions/db-helpers.R", local = TRUE)
```

IMPORTANT: db_with_transaction already checks out a connection internally. The code INSIDE the block should use db_execute_statement which will use the global pool. The transaction isolation is handled by db_with_transaction's use of DBI::dbWithTransaction.
  </action>
  <verify>
1. `grep -n "poolCheckout\|poolReturn\|dbExecute\|dbAppendTable\|dbWriteTable" api/endpoints/admin_endpoints.R` returns empty
2. `grep -n "db_execute_statement\|db_with_transaction" api/endpoints/admin_endpoints.R` returns multiple matches
3. Syntax check: `R -e "source('api/endpoints/admin_endpoints.R', local=TRUE)"` - no errors
  </verify>
  <done>Admin endpoint transactions use db_execute_statement inside db_with_transaction, no direct DBI calls</done>
</task>

<task type="auto">
  <name>Task 2: Refactor pubtator-functions.R to use db-helpers throughout</name>
  <files>api/functions/pubtator-functions.R</files>
  <action>
The pubtator_db_update function (lines 85-319) uses manual transaction management with poolCheckout, dbBegin, dbCommit, dbRollback, and direct dbGetQuery/dbExecute/dbSendQuery calls.

Refactor the entire function to use db_with_transaction and db_execute_query/db_execute_statement.

**Key changes:**

1. Replace manual transaction management with db_with_transaction
2. Replace dbGetQuery with db_execute_query
3. Replace dbExecute with db_execute_statement
4. Replace dbSendQuery + dbBind loops with db_execute_statement in a loop

**Before (line 96-107):**
```r
db_conn <- poolCheckout(pool)
on.exit({
  tryCatch({
    poolReturn(db_conn)
    ...
  })
}, add = TRUE)
dbBegin(db_conn)
```

**After - wrap entire function body in db_with_transaction:**
```r
db_with_transaction({
  # All database operations here use db_execute_query/db_execute_statement
})
```

**Before (line 131-137):**
```r
existing_query <- dbGetQuery(
  db_conn,
  "SELECT query_id, queried_page_number, total_page_number, page_size
   FROM pubtator_query_cache
   WHERE query_hash = ?",
  params = list(q_hash)
)
```

**After:**
```r
existing_query <- db_execute_query(
  "SELECT query_id, queried_page_number, total_page_number, page_size
   FROM pubtator_query_cache
   WHERE query_hash = ?",
  list(q_hash)
)
```

**Before (lines 143-149):**
```r
rs_ins <- dbSendQuery(db_conn, "
  INSERT INTO pubtator_query_cache
    (query_text, query_hash, total_page_number, queried_page_number, page_size)
  VALUES (?, ?, ?, ?, ?)
")
dbBind(rs_ins, list(query, q_hash, total_pages, max_pages, 10))
dbClearResult(rs_ins)
```

**After:**
```r
db_execute_statement(
  "INSERT INTO pubtator_query_cache
    (query_text, query_hash, total_page_number, queried_page_number, page_size)
   VALUES (?, ?, ?, ?, ?)",
  list(query, q_hash, total_pages, max_pages, 10)
)
```

**Before (line 151):**
```r
query_id <- dbGetQuery(db_conn, "SELECT LAST_INSERT_ID() AS id;")$id[1]
```

**After:**
```r
query_id <- db_execute_query("SELECT LAST_INSERT_ID() AS id")$id[1]
```

**Before (lines 164-175) - DELETE statements:**
```r
dbExecute(db_conn, "DELETE FROM pubtator_search_cache WHERE query_id = ?", params = list(query_id))
dbExecute(db_conn, "DELETE a FROM pubtator_annotation_cache a JOIN pubtator_search_cache s ON a.search_id = s.search_id WHERE s.query_id = ?", params = list(query_id))
```

**After:**
```r
db_execute_statement("DELETE FROM pubtator_search_cache WHERE query_id = ?", list(query_id))
db_execute_statement("DELETE a FROM pubtator_annotation_cache a JOIN pubtator_search_cache s ON a.search_id = s.search_id WHERE s.query_id = ?", list(query_id))
```

**Before (lines 177-181) - UPDATE:**
```r
dbExecute(db_conn, "UPDATE pubtator_query_cache SET total_page_number=?, queried_page_number=?, page_size=? WHERE query_id=?", params = list(total_pages, max_pages, 10, query_id))
```

**After:**
```r
db_execute_statement("UPDATE pubtator_query_cache SET total_page_number=?, queried_page_number=?, page_size=? WHERE query_id=?", list(total_pages, max_pages, 10, query_id))
```

**Before (lines 226-231) - INSERT loop:**
```r
sql_ins <- "INSERT INTO pubtator_search_cache ..."
rs_ins <- dbSendQuery(db_conn, sql_ins)
for (r in seq_len(nrow(df_insert))) {
  vals <- unname(as.list(df_insert[r, ]))
  dbBind(rs_ins, vals)
}
dbClearResult(rs_ins)
```

**After:**
```r
for (r in seq_len(nrow(df_insert))) {
  db_execute_statement(
    "INSERT INTO pubtator_search_cache (query_id, id, pmid, doi, title, journal, date, score, text_hl) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
    unname(as.list(df_insert[r, ]))
  )
}
```

**Before (lines 234-238) - UPDATE:**
```r
dbExecute(db_conn, "UPDATE pubtator_query_cache SET queried_page_number=?, total_page_number=? WHERE query_id=?", params = list(max_pages, total_pages, query_id))
```

**After:**
```r
db_execute_statement("UPDATE pubtator_query_cache SET queried_page_number=?, total_page_number=? WHERE query_id=?", list(max_pages, total_pages, query_id))
```

**Before (lines 248-253) - SELECT:**
```r
pmid_rows <- dbGetQuery(db_conn, "SELECT pmid FROM pubtator_search_cache WHERE query_id=? AND pmid IS NOT NULL GROUP BY pmid", params = list(query_id))
```

**After:**
```r
pmid_rows <- db_execute_query("SELECT pmid FROM pubtator_search_cache WHERE query_id=? AND pmid IS NOT NULL GROUP BY pmid", list(query_id))
```

**Before (lines 274-278) - SELECT:**
```r
srch_map <- dbGetQuery(db_conn, "SELECT search_id, pmid FROM pubtator_search_cache WHERE query_id=?", params = list(query_id))
```

**After:**
```r
srch_map <- db_execute_query("SELECT search_id, pmid FROM pubtator_search_cache WHERE query_id=?", list(query_id))
```

**Before (lines 291-305) - INSERT loop:**
```r
ins_sql <- "INSERT INTO pubtator_annotation_cache ..."
rs_ins <- dbSendQuery(db_conn, ins_sql)
for (r in seq_len(nrow(df_ann))) {
  vals <- unname(as.list(df_ann[r, ]))
  dbBind(rs_ins, vals)
}
dbClearResult(rs_ins)
```

**After:**
```r
for (r in seq_len(nrow(df_ann))) {
  db_execute_statement(
    "INSERT INTO pubtator_annotation_cache (search_id, pmid, id, text, identifier, type, ncbi_homologene, valid, normalized, `database`, normalized_id, biotype, name, accession) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
    unname(as.list(df_ann[r, ]))
  )
}
```

**Before (lines 307-308, 256, 266):**
```r
dbCommit(db_conn)
# or
dbRollback(db_conn)
```

**After:** Remove all dbCommit/dbRollback calls - db_with_transaction handles this automatically.

**Handle early returns:** The current code has multiple return points inside the transaction (lines 117, 189, 257, 267).
- For success cases, just let the value fall through to the end
- For the "no pages found" case (line 117), throw an error or return NULL from outside transaction
- Store query_id as result and return after transaction block

**Revised structure:**
```r
pubtator_db_update <- function(...) {
  # Validation that doesn't need DB
  total_pages <- pubtator_v3_total_pages_from_query(query)
  if (is.null(total_pages) || total_pages == 0) {
    log_warn("No pages found for query: {query}. Aborting.")
    return(NULL)
  }

  # Wrap all DB operations in transaction
  result <- tryCatch({
    db_with_transaction({
      # All DB operations here
      # Return query_id at the end
      query_id
    })
  }, error = function(e) {
    log_error("pubtator_db_update: Error => {e$message}")
    return(NULL)
  })

  return(result)
}
```

Add source at top:
```r
source("functions/db-helpers.R", local = TRUE)
```
  </action>
  <verify>
1. `grep -n "poolCheckout\|poolReturn\|dbBegin\|dbCommit\|dbRollback\|dbGetQuery\|dbExecute\|dbSendQuery\|dbBind\|dbClearResult" api/functions/pubtator-functions.R` returns empty
2. `grep -n "db_execute_query\|db_execute_statement\|db_with_transaction" api/functions/pubtator-functions.R` returns multiple matches
3. Syntax check: `R -e "source('api/functions/pubtator-functions.R', local=TRUE)"` - no errors
  </verify>
  <done>Pubtator functions use db_with_transaction with db_execute_query/db_execute_statement, no direct DBI calls</done>
</task>

</tasks>

<verification>
Run comprehensive gap verification:
```bash
# Check ALL four files have no direct DBI calls (include 21-09 files too)
echo "=== Checking for remaining direct DBI calls ==="
grep -rn "dbConnect\|poolCheckout\|poolReturn\|dbBegin\|dbCommit\|dbRollback\|dbGetQuery\|dbExecute\|dbSendQuery\|dbBind\|dbClearResult\|dbAppendTable\|dbWriteTable\|poolWithTransaction" \
  api/endpoints/authentication_endpoints.R \
  api/endpoints/admin_endpoints.R \
  api/functions/pubtator-functions.R \
  api/functions/publication-functions.R

# Should return empty (or only comments/documentation)

echo "=== Checking db-helpers usage ==="
grep -rn "db_execute_query\|db_execute_statement\|db_with_transaction" \
  api/endpoints/authentication_endpoints.R \
  api/endpoints/admin_endpoints.R \
  api/functions/pubtator-functions.R \
  api/functions/publication-functions.R

# Should return multiple matches in each file
```
</verification>

<success_criteria>
- Zero direct DBI calls in admin_endpoints.R (poolCheckout, dbExecute, dbAppendTable, dbWriteTable)
- Zero direct DBI calls in pubtator-functions.R (poolCheckout, dbBegin, dbCommit, dbRollback, dbGetQuery, dbExecute, dbSendQuery, dbBind, dbClearResult)
- Both files use db_with_transaction for transactional operations
- Both files use db_execute_query for SELECT operations
- Both files use db_execute_statement for INSERT/UPDATE/DELETE operations
- Both files source db-helpers.R
- Existing functionality preserved (same data operations)
</success_criteria>

<output>
After completion, create `.planning/phases/21-repository-layer/21-10-SUMMARY.md`
</output>
