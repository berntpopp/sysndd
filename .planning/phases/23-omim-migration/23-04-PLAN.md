---
phase: 23-omim-migration
plan: 04
type: execute
wave: 3
depends_on: ["23-02", "23-03"]
files_modified:
  - api/functions/ontology-functions.R
  - api/endpoints/admin_endpoints.R
  - api/functions/job-manager.R
autonomous: true

must_haves:
  truths:
    - "process_omim_ontology uses mim2gene.txt instead of genemap2.txt"
    - "JAX API fetches OMIM disease names"
    - "MONDO mappings included in ontology update"
    - "Async endpoint returns job_id immediately"
    - "Progress tracking shows 4 steps: Download -> Fetch names -> Validate -> Write"
  artifacts:
    - path: "api/functions/ontology-functions.R"
      provides: "Updated ontology processing using mim2gene + JAX API"
      min_lines: 400
    - path: "api/endpoints/admin_endpoints.R"
      provides: "Async OMIM update endpoint"
      contains: "update_ontology_async"
  key_links:
    - from: "api/endpoints/admin_endpoints.R"
      to: "api/functions/job-manager.R"
      via: "create_job function call"
      pattern: "create_job"
    - from: "api/functions/ontology-functions.R"
      to: "api/functions/omim-functions.R"
      via: "source or function calls"
      pattern: "download_mim2gene|fetch_all_disease_names"
---

<objective>
Integrate the new OMIM and MONDO functions into the ontology update workflow, replacing genemap2.txt with mim2gene.txt + JAX API, and converting the update endpoint to async.

Purpose: This is the core integration that completes the OMIM migration. The synchronous PUT /admin/update_ontology becomes async, using the job-manager framework from Phase 20.

Output: Updated ontology-functions.R using new data sources, async admin endpoint, and proper progress tracking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-omim-migration/23-CONTEXT.md
@.planning/phases/23-omim-migration/23-02-SUMMARY.md
@.planning/phases/23-omim-migration/23-03-SUMMARY.md
@api/functions/ontology-functions.R
@api/endpoints/admin_endpoints.R
@api/functions/job-manager.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update ontology-functions.R to Use New Data Sources</name>
  <files>api/functions/ontology-functions.R</files>
  <action>
Modify api/functions/ontology-functions.R:

**1. Add source statements at top:**
```r
source(find.package("api")[1] %||% ".", "functions/omim-functions.R")
source(find.package("api")[1] %||% ".", "functions/mondo-functions.R")
```

**2. Refactor process_omim_ontology() function:**

REMOVE the genemap2 download and parsing code (lines ~260-355).

REPLACE with new implementation:

```r
process_omim_ontology <- function(hgnc_list, moi_list, max_file_age = 3, progress_callback = NULL) {
  # Step 1: Download mim2gene.txt
  if (!is.null(progress_callback)) {
    progress_callback(step = "Downloading mim2gene.txt", current = 1, total = 4)
  }
  mim2gene_file <- download_mim2gene("data/", force = FALSE)
  mim2gene_data <- parse_mim2gene(mim2gene_file)

  # Step 2: Fetch disease names from JAX API
  phenotype_mims <- mim2gene_data$mim_number
  if (!is.null(progress_callback)) {
    # Pass through sub-progress to progress_callback
    disease_names <- fetch_all_disease_names(
      phenotype_mims,
      progress_callback = function(step, current, total) {
        progress_callback(
          step = paste0("Fetching disease names: ", current, "/", total),
          current = 2,
          total = 4
        )
      }
    )
  } else {
    disease_names <- fetch_all_disease_names(phenotype_mims)
  }

  # Step 3: Build OMIM ontology set
  if (!is.null(progress_callback)) {
    progress_callback(step = "Building ontology set", current = 3, total = 4)
  }
  omim_terms <- build_omim_ontology_set(mim2gene_data, disease_names, hgnc_list, moi_list)

  return(omim_terms)
}
```

**3. Update process_combine_ontology() to use MONDO mappings:**

After combining mondo_terms and omim_terms, add:
```r
# Download and apply MONDO SSSOM mappings
mondo_sssom_file <- download_mondo_sssom("data/mondo_mappings/")
mondo_sssom <- parse_mondo_sssom(mondo_sssom_file)

# Add MONDO equivalence to OMIM entries
disease_ontology_set <- add_mondo_mappings_to_ontology(disease_ontology_set, mondo_sssom)
```

**4. Add progress_callback parameter to process_combine_ontology:**
Pass it through to process_omim_ontology.

**5. Keep existing MONDO processing** (process_mondo_ontology) - it still works.

**6. REMOVE references to genemap2:**
- Delete genemap2_link variable and download.file call
- Delete genemap2 read_delim and processing
- Remove any check_file_age("genemap2", ...) calls

Important: This is a significant refactor. Test thoroughly after changes.
  </action>
  <verify>
1. Source the file: `source("api/functions/ontology-functions.R")`
2. Grep for genemap2 - should return nothing: `grep -n "genemap2" api/functions/ontology-functions.R`
3. Check functions exist: `exists("process_omim_ontology")`
  </verify>
  <done>
- genemap2 references removed from ontology-functions.R
- process_omim_ontology uses mim2gene + JAX API
- process_combine_ontology adds MONDO SSSOM mappings
- progress_callback parameter added for async tracking
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Async Update Endpoint and Update Job Manager</name>
  <files>api/endpoints/admin_endpoints.R, api/functions/job-manager.R</files>
  <action>
**1. Update job-manager.R get_progress_message():**

Add omim_update operation with detailed step tracking:
```r
get_progress_message <- function(operation) {
  messages <- list(
    clustering = "Fetching interaction data from STRING-db...",
    phenotype_clustering = "Running Multiple Correspondence Analysis...",
    ontology_update = "Downloading and processing ontology data from MONDO/OMIM...",
    omim_update = "Updating OMIM annotations from mim2gene.txt + JAX API..."
  )
  messages[[operation]] %||% "Processing request..."
}
```

**2. Add new async endpoint to admin_endpoints.R:**

Add after existing update_ontology endpoint:

```r
#* Updates OMIM ontology annotations asynchronously
#*
#* Returns immediately with a job_id. Poll GET /api/jobs/{job_id} for status.
#* Progress steps: 1) Download mim2gene.txt, 2) Fetch JAX disease names,
#* 3) Validate data, 4) Write to database.
#*
#* # `Authorization`
#* Restricted to Administrator role.
#*
#* @tag admin
#* @serializer json list(na="string")
#* @put update_ontology_async
function(req, res) {
  if (req$user_role != "Administrator") {
    res$status <- 403
    return(list(error = "Access forbidden. Only administrators can perform this operation."))
  }

  # Pre-fetch database data (cannot be accessed in daemon workers)
  mode_of_inheritance_list <- pool %>%
    tbl("mode_of_inheritance_list") %>%
    select(-is_active, -sort) %>%
    collect()

  non_alt_loci_set <- pool %>%
    tbl("non_alt_loci_set") %>%
    select(hgnc_id, symbol) %>%
    collect()

  ndd_entity_view <- pool %>%
    tbl("ndd_entity_view") %>%
    collect()

  disease_ontology_set_current <- pool %>%
    tbl("disease_ontology_set") %>%
    collect()

  ndd_entity <- pool %>%
    tbl("ndd_entity") %>%
    collect()

  # Check for duplicate job
  dup_check <- check_duplicate_job("omim_update", list())
  if (dup_check$duplicate) {
    return(list(
      job_id = dup_check$existing_job_id,
      status = "already_running",
      message = "An OMIM update job is already running"
    ))
  }

  # Create async job
  result <- create_job(
    operation = "omim_update",
    params = list(
      mode_of_inheritance_list = mode_of_inheritance_list,
      non_alt_loci_set = non_alt_loci_set,
      ndd_entity_view = ndd_entity_view,
      disease_ontology_set_current = disease_ontology_set_current,
      ndd_entity = ndd_entity,
      db_config = list(
        dbname = dw$dbname,
        user = dw$user,
        password = dw$password,
        server = dw$server,
        host = dw$host,
        port = dw$port
      )
    ),
    executor_fn = function(params) {
      # Source required functions in worker
      source("functions/omim-functions.R")
      source("functions/mondo-functions.R")
      source("functions/ontology-functions.R")
      source("functions/file-functions.R")

      # Process new ontology data
      disease_ontology_set_update <- process_combine_ontology(
        params$non_alt_loci_set,
        params$mode_of_inheritance_list,
        3,
        "data/"
      )

      # Validate before write (CONTEXT.md: abort if any entry fails)
      validation <- validate_omim_data(disease_ontology_set_update)
      if (!validation$valid) {
        stop(paste("Validation failed:", paste(validation$errors, collapse = "; ")))
      }

      # Identify critical changes
      ndd_entity_view_ontology_set <- params$ndd_entity_view %>%
        select(entity_id, disease_ontology_id_version, disease_ontology_name)

      critical_changes <- identify_critical_ontology_changes(
        disease_ontology_set_update,
        params$disease_ontology_set_current,
        ndd_entity_view_ontology_set
      )

      # Connect and write in transaction
      sysndd_db <- dbConnect(
        RMariaDB::MariaDB(),
        dbname = params$db_config$dbname,
        user = params$db_config$user,
        password = params$db_config$password,
        server = params$db_config$server,
        host = params$db_config$host,
        port = params$db_config$port
      )

      on.exit(dbDisconnect(sysndd_db), add = TRUE)

      dbBegin(sysndd_db)
      tryCatch({
        dbExecute(sysndd_db, "SET FOREIGN_KEY_CHECKS = 0;")
        dbExecute(sysndd_db, "TRUNCATE TABLE disease_ontology_set;")
        dbAppendTable(sysndd_db, "disease_ontology_set", disease_ontology_set_update)
        dbExecute(sysndd_db, "SET FOREIGN_KEY_CHECKS = 1;")

        dbCommit(sysndd_db)
        list(status = "Success", rows_written = nrow(disease_ontology_set_update))
      }, error = function(e) {
        dbRollback(sysndd_db)
        stop(paste("Database write failed:", e$message))
      })
    }
  )

  res$status <- 202
  return(result)
}
```

**3. Keep the existing synchronous update_ontology endpoint** for backward compatibility, but add a deprecation note in its documentation.
  </action>
  <verify>
1. Check endpoint exists: `grep -n "update_ontology_async" api/endpoints/admin_endpoints.R`
2. Check job-manager has omim_update: `grep -n "omim_update" api/functions/job-manager.R`
3. Verify no syntax errors by sourcing admin_endpoints.R
  </verify>
  <done>
- PUT /admin/update_ontology_async endpoint created
- Job manager recognizes omim_update operation
- Pre-fetched data passed to daemon worker (DB connections don't cross processes)
- Validation occurs before database write
- Single transaction with rollback on failure
  </done>
</task>

</tasks>

<verification>
1. Start API locally and test:
   - PUT /admin/update_ontology_async returns 202 with job_id
   - GET /api/jobs/{job_id} returns status
2. No genemap2 references remain in ontology-functions.R
3. OMIM data source is mim2gene.txt + JAX API
4. MONDO SSSOM mappings added to disease_ontology_set
</verification>

<success_criteria>
- OMIM-01: mim2gene.txt integration complete
- OMIM-02: JAX API integration for disease names complete
- OMIM-04: Data validation before database writes
- MONDO-01: MONDO-to-OMIM equivalence mapping stored
- Async endpoint uses job-manager from Phase 20
</success_criteria>

<output>
After completion, create `.planning/phases/23-omim-migration/23-04-SUMMARY.md`
</output>
