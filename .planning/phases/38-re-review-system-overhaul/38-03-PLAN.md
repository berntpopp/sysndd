---
phase: 38-re-review-overhaul
plan: 03
type: execute
wave: 2
depends_on: ["38-01", "38-02"]
files_modified:
  - app/src/composables/useBatchForm.ts
  - app/src/components/forms/BatchCriteriaForm.vue
autonomous: true

must_haves:
  truths:
    - "useBatchForm composable manages batch creation form state and API calls"
    - "BatchCriteriaForm component renders all criteria fields on single form"
    - "Preview button shows matching entities without creating batch"
    - "Gene list uses BFormSelect with multiple attribute"
    - "Form validates that at least one criterion is provided"
  artifacts:
    - path: "app/src/composables/useBatchForm.ts"
      provides: "Batch form state management and API integration"
      exports: ["useBatchForm"]
      min_lines: 80
    - path: "app/src/components/forms/BatchCriteriaForm.vue"
      provides: "Batch criteria selection UI component"
      min_lines: 150
  key_links:
    - from: "app/src/composables/useBatchForm.ts"
      to: "/api/re_review/batch/create"
      via: "axios POST"
      pattern: "batch/create"
    - from: "app/src/composables/useBatchForm.ts"
      to: "/api/re_review/batch/preview"
      via: "axios POST"
      pattern: "batch/preview"
---

<objective>
Create useBatchForm composable and BatchCriteriaForm component

Purpose: Build the frontend infrastructure for dynamic batch creation. The composable manages form state, validation, and API calls. The component provides the single-form interface with all criteria fields (date range, gene list, status, batch size, user assignment) as decided in CONTEXT.md.

Output: app/src/composables/useBatchForm.ts and app/src/components/forms/BatchCriteriaForm.vue
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-re-review-system-overhaul/38-CONTEXT.md
@.planning/phases/38-re-review-system-overhaul/38-RESEARCH.md
@app/src/composables/useEntityForm.ts
@app/src/composables/useToast.ts
@app/src/views/curate/ManageReReview.vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useBatchForm composable</name>
  <files>app/src/composables/useBatchForm.ts</files>
  <action>
Create `app/src/composables/useBatchForm.ts` following the established composable patterns.

```typescript
/**
 * Composable for managing re-review batch creation form
 *
 * Handles form state, validation, preview, and submission for dynamic batch creation.
 * Follows single-form interface pattern from CONTEXT.md decisions.
 */
import { ref, reactive, computed } from 'vue';
import axios from 'axios';
import useToast from './useToast';

// Types for batch criteria
interface DateRange {
  start: string | null;  // YYYY-MM-DD format
  end: string | null;
}

interface BatchFormData {
  batch_name: string;
  date_range: DateRange;
  gene_list: number[];      // Array of hgnc_ids (BFormSelect multiple returns array)
  status_filter: number | null;  // category_id
  disease_id: string | null;
  batch_size: number;
  assigned_user_id: number | null;
}

interface PreviewEntity {
  entity_id: number;
  hgnc_id: number;
  gene_symbol: string;
  disease_ontology_name: string;
  review_date: string;
}

interface GeneOption {
  value: number;
  text: string;
}

interface StatusOption {
  value: number;
  text: string;
}

interface UserOption {
  value: number;
  text: string;
}

export function useBatchForm() {
  const { makeToast } = useToast();

  // Form state
  const formData = reactive<BatchFormData>({
    batch_name: '',
    date_range: { start: null, end: null },
    gene_list: [],
    status_filter: null,
    disease_id: null,
    batch_size: 20,
    assigned_user_id: null,
  });

  // Loading states
  const isLoading = ref(false);
  const isPreviewLoading = ref(false);

  // Options for dropdowns (loaded from API)
  const geneOptions = ref<GeneOption[]>([]);
  const statusOptions = ref<StatusOption[]>([]);
  const userOptions = ref<UserOption[]>([]);

  // Preview data
  const previewEntities = ref<PreviewEntity[]>([]);
  const showPreviewModal = ref(false);

  // Validation: at least one criterion required
  const isFormValid = computed(() => {
    const hasDateRange = formData.date_range.start && formData.date_range.end;
    const hasGeneList = formData.gene_list.length > 0;
    const hasStatusFilter = formData.status_filter !== null;
    const hasDiseaseId = formData.disease_id !== null && formData.disease_id !== '';

    return hasDateRange || hasGeneList || hasStatusFilter || hasDiseaseId;
  });

  // Build criteria object for API
  const buildCriteria = () => {
    const criteria: Record<string, unknown> = {
      batch_size: formData.batch_size,
    };

    if (formData.date_range.start && formData.date_range.end) {
      criteria.date_range = {
        start: formData.date_range.start,
        end: formData.date_range.end,
      };
    }

    if (formData.gene_list.length > 0) {
      criteria.gene_list = formData.gene_list;
    }

    if (formData.status_filter !== null) {
      criteria.status_filter = formData.status_filter;
    }

    if (formData.disease_id) {
      criteria.disease_id = formData.disease_id;
    }

    return criteria;
  };

  // Load dropdown options
  const loadOptions = async () => {
    const apiUrl = import.meta.env.VITE_API_URL;
    const token = localStorage.getItem('token');
    const headers = { Authorization: `Bearer ${token}` };

    try {
      // Load users (Curators and Reviewers)
      const usersResponse = await axios.get(
        `${apiUrl}/api/user/list?roles=Curator,Reviewer`,
        { headers }
      );
      const usersData = usersResponse.data;
      userOptions.value = Array.isArray(usersData)
        ? usersData.map((u: { user_id: number; user_name: string }) => ({
            value: u.user_id,
            text: u.user_name,
          }))
        : [];

      // Load status categories
      const statusResponse = await axios.get(
        `${apiUrl}/api/entity/status/category/list`,
        { headers }
      );
      const statusData = statusResponse.data;
      statusOptions.value = Array.isArray(statusData)
        ? statusData.map((s: { category_id: number; category: string }) => ({
            value: s.category_id,
            text: s.category,
          }))
        : [];

      // Load genes (from entities for selection)
      // This loads unique genes that have entities
      const genesResponse = await axios.get(
        `${apiUrl}/api/entity/genes`,
        { headers }
      );
      const genesData = genesResponse.data;
      geneOptions.value = Array.isArray(genesData)
        ? genesData.map((g: { hgnc_id: number; gene_symbol: string }) => ({
            value: g.hgnc_id,
            text: g.gene_symbol,
          }))
        : [];
    } catch (error) {
      makeToast('Failed to load form options', 'Error', 'danger');
    }
  };

  // Preview matching entities
  const handlePreview = async () => {
    if (!isFormValid.value) {
      makeToast('Please select at least one criterion', 'Validation', 'warning');
      return;
    }

    isPreviewLoading.value = true;
    const apiUrl = import.meta.env.VITE_API_URL;
    const token = localStorage.getItem('token');

    try {
      const response = await axios.post(
        `${apiUrl}/api/re_review/batch/preview`,
        buildCriteria(),
        { headers: { Authorization: `Bearer ${token}` } }
      );

      previewEntities.value = response.data.data || [];
      showPreviewModal.value = true;
    } catch (error: unknown) {
      const message = axios.isAxiosError(error)
        ? error.response?.data?.message || error.message
        : 'Preview failed';
      makeToast(message, 'Error', 'danger');
    } finally {
      isPreviewLoading.value = false;
    }
  };

  // Create batch
  const handleSubmit = async () => {
    if (!isFormValid.value) {
      makeToast('Please select at least one criterion', 'Validation', 'warning');
      return false;
    }

    isLoading.value = true;
    const apiUrl = import.meta.env.VITE_API_URL;
    const token = localStorage.getItem('token');

    try {
      const payload = {
        ...buildCriteria(),
        batch_name: formData.batch_name || null,
        assigned_user_id: formData.assigned_user_id,
      };

      const response = await axios.post(
        `${apiUrl}/api/re_review/batch/create`,
        payload,
        { headers: { Authorization: `Bearer ${token}` } }
      );

      const result = response.data.entry;
      makeToast(
        `Batch created with ${result.entity_count} entities`,
        'Success',
        'success'
      );

      // Reset form
      resetForm();
      return true;
    } catch (error: unknown) {
      const message = axios.isAxiosError(error)
        ? error.response?.data?.message || error.message
        : 'Batch creation failed';
      makeToast(message, 'Error', 'danger');
      return false;
    } finally {
      isLoading.value = false;
    }
  };

  // Reset form to initial state
  const resetForm = () => {
    formData.batch_name = '';
    formData.date_range = { start: null, end: null };
    formData.gene_list = [];
    formData.status_filter = null;
    formData.disease_id = null;
    formData.batch_size = 20;
    formData.assigned_user_id = null;
    previewEntities.value = [];
  };

  // Preview table fields
  const previewFields = [
    { key: 'entity_id', label: 'Entity ID', sortable: true },
    { key: 'gene_symbol', label: 'Gene', sortable: true },
    { key: 'disease_ontology_name', label: 'Disease', sortable: true },
    { key: 'review_date', label: 'Last Review', sortable: true },
  ];

  return {
    // State
    formData,
    isLoading,
    isPreviewLoading,
    isFormValid,

    // Options
    geneOptions,
    statusOptions,
    userOptions,

    // Preview
    previewEntities,
    previewFields,
    showPreviewModal,

    // Methods
    loadOptions,
    handlePreview,
    handleSubmit,
    resetForm,
  };
}

export default useBatchForm;
```
  </action>
  <verify>
```bash
# File exists with expected exports
grep -q "export function useBatchForm" app/src/composables/useBatchForm.ts && echo "useBatchForm exported: OK"

# Check for key functions
grep -q "handlePreview" app/src/composables/useBatchForm.ts && echo "Preview handler: OK"
grep -q "handleSubmit" app/src/composables/useBatchForm.ts && echo "Submit handler: OK"
grep -q "batch/create" app/src/composables/useBatchForm.ts && echo "Create API call: OK"
grep -q "batch/preview" app/src/composables/useBatchForm.ts && echo "Preview API call: OK"
```
  </verify>
  <done>
- app/src/composables/useBatchForm.ts exists with 80+ lines
- Exports useBatchForm function
- Manages formData reactive state with all criteria fields
- Provides handlePreview() that calls /api/re_review/batch/preview
- Provides handleSubmit() that calls /api/re_review/batch/create
- Provides loadOptions() for dropdown data
- Includes isFormValid computed property requiring at least one criterion
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BatchCriteriaForm component</name>
  <files>app/src/components/forms/BatchCriteriaForm.vue</files>
  <action>
Create `app/src/components/forms/BatchCriteriaForm.vue` - the single-form interface for batch creation.

```vue
<!-- src/components/forms/BatchCriteriaForm.vue -->
<template>
  <BCard
    header="Create Re-Review Batch"
    header-class="bg-primary text-white"
    class="mb-3"
  >
    <BForm @submit.prevent="onSubmit">
      <!-- Batch Name (optional) -->
      <BFormGroup
        label="Batch Name (optional)"
        label-for="batch-name"
        class="mb-3"
      >
        <BFormInput
          id="batch-name"
          v-model="formData.batch_name"
          placeholder="Auto-generated if empty (e.g., Batch 2026-01-26 14:30)"
          :disabled="isLoading"
        />
        <BFormText>Leave empty for auto-generated name based on creation time</BFormText>
      </BFormGroup>

      <!-- Date Range -->
      <BFormGroup
        label="Review Date Range"
        label-for="date-start"
        class="mb-3"
      >
        <div class="d-flex gap-2">
          <BFormInput
            id="date-start"
            v-model="formData.date_range.start"
            type="date"
            placeholder="Start date"
            :disabled="isLoading"
            aria-label="Start date for review date range"
          />
          <span class="align-self-center">to</span>
          <BFormInput
            id="date-end"
            v-model="formData.date_range.end"
            type="date"
            placeholder="End date"
            :disabled="isLoading"
            aria-label="End date for review date range"
          />
        </div>
        <BFormText>Include entities last reviewed between these dates</BFormText>
      </BFormGroup>

      <!-- Gene List (multi-select) -->
      <BFormGroup
        label="Genes (optional)"
        label-for="gene-select"
        class="mb-3"
      >
        <BFormSelect
          id="gene-select"
          v-model="formData.gene_list"
          :options="geneOptions"
          multiple
          :select-size="6"
          :disabled="isLoading"
          aria-label="Select genes to include in batch"
        >
          <template #first>
            <option
              :value="null"
              disabled
            >
              -- Select genes (hold Ctrl/Cmd for multiple) --
            </option>
          </template>
        </BFormSelect>
        <BFormText>
          {{ formData.gene_list.length }} gene(s) selected.
          Hold Ctrl/Cmd to select multiple genes.
        </BFormText>
      </BFormGroup>

      <!-- Status Filter -->
      <BFormGroup
        label="Status Category (optional)"
        label-for="status-filter"
        class="mb-3"
      >
        <BFormSelect
          id="status-filter"
          v-model="formData.status_filter"
          :options="statusOptions"
          :disabled="isLoading"
          aria-label="Filter by entity status category"
        >
          <template #first>
            <option :value="null">
              -- Any status --
            </option>
          </template>
        </BFormSelect>
      </BFormGroup>

      <!-- Batch Size -->
      <BFormGroup
        label="Batch Size"
        label-for="batch-size"
        class="mb-3"
      >
        <BFormInput
          id="batch-size"
          v-model.number="formData.batch_size"
          type="number"
          min="1"
          max="100"
          :disabled="isLoading"
          aria-label="Maximum number of entities in this batch"
        />
        <BFormText>Maximum entities to include (default: 20, max: 100)</BFormText>
      </BFormGroup>

      <!-- User Assignment -->
      <BFormGroup
        label="Assign to User (optional)"
        label-for="user-select"
        class="mb-3"
      >
        <BFormSelect
          id="user-select"
          v-model="formData.assigned_user_id"
          :options="userOptions"
          :disabled="isLoading"
          aria-label="Select user to assign batch to"
        >
          <template #first>
            <option :value="null">
              -- Assign later --
            </option>
          </template>
        </BFormSelect>
        <BFormText>Leave unassigned to assign after creation</BFormText>
      </BFormGroup>

      <!-- Validation message -->
      <BAlert
        v-if="!isFormValid"
        variant="info"
        show
        class="mb-3"
      >
        <i class="bi bi-info-circle me-1" />
        Please select at least one criterion (date range, genes, or status).
      </BAlert>

      <!-- Actions -->
      <div class="d-flex gap-2">
        <BButton
          variant="outline-primary"
          :disabled="isLoading || isPreviewLoading || !isFormValid"
          @click="onPreview"
        >
          <BSpinner
            v-if="isPreviewLoading"
            small
            class="me-1"
          />
          <i
            v-else
            class="bi bi-eye me-1"
          />
          Preview Matching Entities
        </BButton>
        <BButton
          type="submit"
          variant="primary"
          :disabled="isLoading || !isFormValid"
        >
          <BSpinner
            v-if="isLoading"
            small
            class="me-1"
          />
          <i
            v-else
            class="bi bi-plus-circle me-1"
          />
          Create Batch
        </BButton>
        <BButton
          variant="outline-secondary"
          :disabled="isLoading"
          @click="onReset"
        >
          <i class="bi bi-x-circle me-1" />
          Reset
        </BButton>
      </div>
    </BForm>

    <!-- Preview Modal -->
    <BModal
      v-model="showPreviewModal"
      title="Preview: Matching Entities"
      size="lg"
      ok-only
      ok-title="Close"
    >
      <div v-if="previewEntities.length > 0">
        <BAlert
          variant="success"
          show
        >
          <strong>{{ previewEntities.length }}</strong> entities match your criteria
          (limited to batch size of {{ formData.batch_size }}).
        </BAlert>
        <BTable
          :items="previewEntities"
          :fields="previewFields"
          small
          striped
          hover
          responsive
        />
      </div>
      <BAlert
        v-else
        variant="warning"
        show
      >
        <i class="bi bi-exclamation-triangle me-1" />
        No entities match the selected criteria. Try broadening your selection.
      </BAlert>
    </BModal>
  </BCard>
</template>

<script setup lang="ts">
import { onMounted } from 'vue';
import { useBatchForm } from '@/composables/useBatchForm';

const emit = defineEmits<{
  (e: 'batch-created'): void;
}>();

const {
  formData,
  isLoading,
  isPreviewLoading,
  isFormValid,
  geneOptions,
  statusOptions,
  userOptions,
  previewEntities,
  previewFields,
  showPreviewModal,
  loadOptions,
  handlePreview,
  handleSubmit,
  resetForm,
} = useBatchForm();

onMounted(() => {
  loadOptions();
});

const onPreview = () => {
  handlePreview();
};

const onSubmit = async () => {
  const success = await handleSubmit();
  if (success) {
    emit('batch-created');
  }
};

const onReset = () => {
  resetForm();
};
</script>

<style scoped>
/* Component-specific styles if needed */
</style>
```

**Key implementation notes:**
- Uses BFormSelect with `multiple` attribute for gene list (returns array per CONTEXT decision)
- Single form with all criteria on one screen (per CONTEXT decision)
- Optional preview before creation (per CONTEXT decision)
- Validation requires at least one criterion
- Loading spinners during API calls
- Emits 'batch-created' event for parent to refresh table
  </action>
  <verify>
```bash
# File exists
test -f app/src/components/forms/BatchCriteriaForm.vue && echo "Component file exists: OK"

# Check for key elements
grep -q "useBatchForm" app/src/components/forms/BatchCriteriaForm.vue && echo "Uses composable: OK"
grep -q "BFormSelect" app/src/components/forms/BatchCriteriaForm.vue && echo "BFormSelect present: OK"
grep -q 'multiple' app/src/components/forms/BatchCriteriaForm.vue && echo "Multiple select: OK"
grep -q "batch-created" app/src/components/forms/BatchCriteriaForm.vue && echo "Emit event: OK"
```
  </verify>
  <done>
- app/src/components/forms/BatchCriteriaForm.vue exists with 150+ lines
- Uses useBatchForm composable for state management
- Renders all criteria fields: batch name, date range, gene list, status, batch size, user
- Gene list uses BFormSelect with multiple attribute
- Preview button calls handlePreview and shows modal
- Create button calls handleSubmit
- Emits 'batch-created' event for parent refresh
  </done>
</task>

</tasks>

<verification>
```bash
# Check file sizes
wc -l app/src/composables/useBatchForm.ts  # Should be 80+ lines
wc -l app/src/components/forms/BatchCriteriaForm.vue  # Should be 150+ lines

# Check TypeScript compiles
cd /home/bernt-popp/development/sysndd/app && npx vue-tsc --noEmit 2>&1 | head -20
```
</verification>

<success_criteria>
1. app/src/composables/useBatchForm.ts exists with state management and API calls
2. app/src/components/forms/BatchCriteriaForm.vue exists with single-form UI
3. BFormSelect multiple used for gene list (returns array)
4. Preview functionality shows matching entities
5. Validation requires at least one criterion
6. Loading states during API operations
7. Component emits 'batch-created' event
</success_criteria>

<output>
After completion, create `.planning/phases/38-re-review-overhaul/38-03-SUMMARY.md`
</output>
