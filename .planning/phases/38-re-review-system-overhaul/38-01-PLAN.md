---
phase: 38-re-review-overhaul
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/services/re-review-service.R
autonomous: true

must_haves:
  truths:
    - "Service function batch_create() creates batch with criteria-based entity selection"
    - "Service function batch_assign() assigns batch to user with lifecycle state change"
    - "Service function batch_reassign() allows reassignment to different user"
    - "Service function batch_preview() returns matching entities without creating batch"
    - "Service function entity_assign() assigns specific entities/genes to a user"
    - "Service function batch_recalculate() re-assigns entities to batch based on updated criteria"
    - "Entity overlap prevention excludes entities already in active batches"
  artifacts:
    - path: "api/services/re-review-service.R"
      provides: "Batch management business logic"
      exports: ["batch_create", "batch_assign", "batch_reassign", "batch_preview", "batch_archive", "build_batch_where_clause", "entity_assign", "batch_recalculate"]
      min_lines: 280
  key_links:
    - from: "api/services/re-review-service.R"
      to: "api/functions/db-helpers.R"
      via: "db_with_transaction, db_execute_query, db_execute_statement"
      pattern: "db_with_transaction|db_execute_query|db_execute_statement"
---

<objective>
Create re-review-service.R with batch management business logic

Purpose: Provide service layer for dynamic batch creation with criteria-based entity selection, assignment workflows, lifecycle management, gene-specific assignment, and batch recalculation. This replaces the hardcoded pre-computed batch system with flexible, on-demand batch creation.

Output: api/services/re-review-service.R with functions for batch_create(), batch_assign(), batch_reassign(), batch_preview(), batch_archive(), build_batch_where_clause(), entity_assign(), and batch_recalculate().
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-re-review-system-overhaul/38-CONTEXT.md
@.planning/phases/38-re-review-system-overhaul/38-RESEARCH.md
@api/services/status-service.R
@api/services/entity-service.R
@api/functions/db-helpers.R
@api/endpoints/re_review_endpoints.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create re-review-service.R with batch management functions</name>
  <files>api/services/re-review-service.R</files>
  <action>
Create `api/services/re-review-service.R` following the established service layer patterns from status-service.R and entity-service.R.

**File header:**
```r
# Re-Review Service Layer for SysNDD API
# Provides business logic for dynamic batch management
#
# Functions accept pool as parameter (dependency injection)
# Handles batch creation, assignment, reassignment, and lifecycle
```

**Function 1: build_batch_where_clause(criteria, pool)**
- Build dynamic WHERE clause from criteria object
- Support date_range (start, end), gene_list (array of hgnc_ids), status_filter (category_id), disease_id
- Use glue_sql() with .con parameter for safe interpolation
- Return SQL string (without WHERE keyword)
- If no criteria, return "1=1" (match all)

**Function 2: batch_preview(criteria, batch_size, pool)**
- Return matching entities WITHOUT creating batch
- Use build_batch_where_clause() for filtering
- Exclude entities already in active batches (see below for exclusion query)
- Order by review_date ASC (oldest first per CONTEXT decision)
- Limit to batch_size (default 20)
- Return list with status=200 and data=tibble of matching entities

**Function 3: batch_create(criteria, assigned_user_id, batch_name, pool)**
- Validate at least one criterion provided
- Use db_with_transaction() for atomicity (CRITICAL - see pitfall #2 in RESEARCH)
- Inside transaction:
  1. Generate batch_name if NULL: format "Batch YYYY-MM-DD HH:MM"
  2. Insert into re_review_entity_connect with new batch_id (use MAX(re_review_batch) + 1 from existing)
  3. Find matching entities using build_batch_where_clause()
  4. IMPORTANT: Exclude entities already in active batches:
     ```sql
     AND e.entity_id NOT IN (
       SELECT rec.entity_id FROM re_review_entity_connect rec
       INNER JOIN re_review_assignment ra ON rec.re_review_batch = ra.re_review_batch
       WHERE rec.re_review_approved = 0
     )
     ```
  5. For each matching entity, insert re_review_entity_connect record:
     - Get current status_id and review_id from ndd_entity_view
     - Set re_review_review_saved=0, re_review_status_saved=0, re_review_submitted=0, re_review_approved=0
  6. If assigned_user_id provided, call batch_assign() logic inline
- Log batch creation with entity count
- Return list(status=200, message="Batch created", entry=list(batch_id=X, entity_count=Y))

**Function 4: batch_assign(batch_id, user_id, pool)**
- Verify batch exists and has no existing assignment (is unassigned)
- Insert into re_review_assignment table
- Log assignment
- Return list(status=200, message="Batch assigned")

**Function 5: batch_reassign(batch_id, new_user_id, pool)**
- Verify batch exists
- Update re_review_assignment.user_id for the batch
- Log reassignment
- Return list(status=200, message="Batch reassigned")

**Function 6: batch_archive(batch_id, pool)**
- Soft delete: Delete from re_review_assignment (unassign)
- Note: re_review_entity_connect records preserved for audit
- Log archival
- Return list(status=200, message="Batch archived")

**Function 7: entity_assign(entity_ids, user_id, batch_name, pool)** (NEW - RRV-03, RRV-06)
- Assign specific entities/genes to a user by creating a new batch with those exact entities
- entity_ids: array of entity_id integers (specific genes/entities to include)
- user_id: user to assign to (required)
- batch_name: optional custom name, auto-generate if NULL
- Use db_with_transaction() for atomicity
- Inside transaction:
  1. Validate entity_ids are not empty
  2. Validate all entity_ids exist and are not already in active batches
  3. Generate new batch_id (MAX + 1)
  4. For each entity_id, insert re_review_entity_connect record
  5. Insert re_review_assignment record for user
- Return list(status=200, message="Entities assigned", entry=list(batch_id=X, entity_count=Y))

**Function 8: batch_recalculate(batch_id, criteria, pool)** (NEW - RRV-05)
- Re-calculate which entities belong in a batch based on updated criteria
- Only allowed for batches that are NOT yet assigned (per CONTEXT: "Recalculation allowed only before assignment")
- batch_id: the batch to recalculate
- criteria: new criteria to apply (same structure as batch_create)
- Use db_with_transaction() for atomicity
- Inside transaction:
  1. Verify batch exists
  2. Verify batch is NOT assigned (no entry in re_review_assignment or status check)
  3. Delete existing re_review_entity_connect records for this batch
  4. Re-query entities using build_batch_where_clause() with new criteria
  5. Insert new re_review_entity_connect records
- Return list(status=200, message="Batch recalculated", entry=list(batch_id=X, entity_count=Y))

**Important implementation notes from RESEARCH:**
- Use db_execute_query() and db_execute_statement() from db-helpers.R
- All multi-step operations MUST use db_with_transaction()
- gene_list from frontend is array of integers, not comma string
- Use parameterized queries (list of params), never string concatenation
  </action>
  <verify>
```bash
# File exists and has expected functions
grep -c "batch_create\|batch_assign\|batch_reassign\|batch_preview\|batch_archive\|build_batch_where_clause\|entity_assign\|batch_recalculate" api/services/re-review-service.R
# Should return 8+ (function definitions)

# Check for proper patterns
grep -q "db_with_transaction" api/services/re-review-service.R && echo "Transaction wrapper: OK"
grep -q "db_execute_query\|db_execute_statement" api/services/re-review-service.R && echo "DB helpers: OK"
grep -q "logger::log_info" api/services/re-review-service.R && echo "Logging: OK"

# Check for new functions
grep -q "entity_assign" api/services/re-review-service.R && echo "entity_assign: OK"
grep -q "batch_recalculate" api/services/re-review-service.R && echo "batch_recalculate: OK"
```
  </verify>
  <done>
- api/services/re-review-service.R exists with 8 exported functions
- All functions use db-helpers.R patterns (db_execute_query, db_execute_statement, db_with_transaction)
- batch_create uses transaction wrapper for atomicity
- Entity overlap prevention query included
- entity_assign() supports gene-specific assignment (RRV-03, RRV-06)
- batch_recalculate() supports re-calculating batch contents (RRV-05)
- Functions have proper roxygen2 documentation
  </done>
</task>

<task type="auto">
  <name>Task 2: Source re-review-service.R in API startup</name>
  <files>api/start_sysndd_api.R</files>
  <action>
Add source() call for the new service file in api/start_sysndd_api.R.

1. Find the section where other services are sourced (look for "services/" pattern)
2. Add: `source("services/re-review-service.R")`
3. Place it alphabetically with other service sources

This ensures the service functions are available to the endpoints.
  </action>
  <verify>
```bash
grep -q "re-review-service.R" api/start_sysndd_api.R && echo "Service sourced: OK"
```
  </verify>
  <done>
- re-review-service.R is sourced in API startup
- Service functions available to endpoint handlers
  </done>
</task>

</tasks>

<verification>
```bash
# Verify service file structure
wc -l api/services/re-review-service.R  # Should be 280+ lines

# Verify all function exports
grep -E "^batch_|^build_batch|^entity_assign" api/services/re-review-service.R | wc -l  # Should be 8

# Verify proper dependency injection pattern
grep -c "pool" api/services/re-review-service.R  # Should be many occurrences

# Verify transaction safety
grep -c "db_with_transaction" api/services/re-review-service.R  # Should be >= 3 (batch_create, entity_assign, batch_recalculate)
```
</verification>

<success_criteria>
1. api/services/re-review-service.R exists with 280+ lines
2. Eight functions exported: batch_create, batch_assign, batch_reassign, batch_preview, batch_archive, build_batch_where_clause, entity_assign, batch_recalculate
3. All functions accept pool parameter (dependency injection)
4. batch_create, entity_assign, batch_recalculate use db_with_transaction for atomicity
5. Entity overlap prevention implemented in batch creation
6. entity_assign() enables gene-specific user assignment (RRV-03, RRV-06)
7. batch_recalculate() enables recalculating batch entity membership (RRV-05)
8. Service sourced in API startup
</success_criteria>

<output>
After completion, create `.planning/phases/38-re-review-overhaul/38-01-SUMMARY.md`
</output>
