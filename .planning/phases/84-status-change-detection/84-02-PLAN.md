---
phase: 84-status-change-detection
plan: 02
type: execute
wave: 2
depends_on: ["84-01"]
files_modified:
  - app/src/views/curate/ModifyEntity.vue
autonomous: true

must_haves:
  truths:
    - "When user opens ModifyEntity status modal and clicks Submit without changing anything, no API call is made and the modal closes silently"
    - "When user opens ModifyEntity review modal and clicks Submit without changing anything, no API call is made and the modal closes silently"
    - "When user changes status fields and tries to close the modal without saving, a confirmation dialog appears"
    - "When user changes review fields and tries to close the modal without saving, a confirmation dialog appears"
    - "When user actually changes status category or problematic flag, submitting creates a new status record"
  artifacts:
    - path: "app/src/views/curate/ModifyEntity.vue"
      provides: "Change detection wiring for both status (composable) and review (local) forms, silent skip, unsaved changes warning"
      contains: "hasChanges"
  key_links:
    - from: "ModifyEntity.vue setup()"
      to: "useStatusForm"
      via: "hasChanges destructuring"
      pattern: "hasChanges.*statusForm"
    - from: "ModifyEntity.vue submitStatusChange()"
      to: "hasChanges check"
      via: "silent skip guard"
      pattern: "hasStatusChanges|hasChanges"
    - from: "ModifyEntity.vue @hide handler"
      to: "hasChanges check"
      via: "unsaved changes warning"
      pattern: "onModifyStatusModalHide"
    - from: "ModifyEntity.vue submitReviewChange()"
      to: "hasReviewChanges check"
      via: "silent skip guard"
      pattern: "hasReviewChanges"
    - from: "ModifyEntity.vue @hide handler"
      to: "hasReviewChanges check"
      via: "unsaved changes warning"
      pattern: "onModifyReviewModalHide"

# NOTE on status_change indicator exclusion from ModifyEntity:
#
# The CONTEXT.md says the status_change badge should appear in "all curation
# views." However, ModifyEntity is architecturally different from the table
# views (ApproveReview, ApproveStatus):
#
# 1. DATA: The entity endpoint (/api/entity?filter=...) and the entity-specific
#    status endpoint (/api/entity/{id}/status) do NOT return status_change.
#    That flag is computed only by the review table endpoint (/api/review) which
#    compares active_status vs newest_status across all entities.
#
# 2. UX: ModifyEntity operates on a single entity that the curator deliberately
#    selected by ID. There is no scanning/browsing context where a visual
#    indicator adds discovery value. The curator already knows they are editing
#    this specific entity.
#
# 3. COST: Adding the indicator would require either:
#    (a) A backend change to add status_change to the entity or entity-status
#        endpoint (scope creep beyond frontend-only phase), or
#    (b) An extra API call to the review endpoint filtered by entity_id,
#        adding latency and complexity for marginal UX benefit.
#
# Decision: Exclude status_change indicator from ModifyEntity. Apply it only
# to table views (ApproveReview, ApproveStatus) where it aids entity scanning.
# This is a deliberate, justified exclusion -- not an oversight.
---

<objective>
Wire up change detection in ModifyEntity.vue for both status and review forms: silent skip on save when unchanged, unsaved-changes confirmation on modal close.

Purpose: Prevent unnecessary status/review database records when curator saves without modifications. Improve UX with unsaved-changes warnings.
Output: ModifyEntity with full change detection behavior on both form types.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/84-status-change-detection/84-CONTEXT.md
@.planning/phases/84-status-change-detection/84-RESEARCH.md
@.planning/phases/84-status-change-detection/84-01-SUMMARY.md

@app/src/views/curate/ModifyEntity.vue
@app/src/views/curate/composables/useStatusForm.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire hasChanges into ModifyEntity status form (composable-based)</name>
  <files>app/src/views/curate/ModifyEntity.vue</files>
  <action>
This task wires the composable-provided `hasChanges` into ModifyEntity's status modal. The status form uses the `useStatusForm` composable (Plan 84-01 adds `hasChanges` to it).

**1. Expose hasChanges from setup():**

In the `setup()` function (line 772-798), destructure `hasChanges` from statusForm alongside the existing destructured values:
```typescript
const {
  formData: statusFormData,
  loading: statusFormLoading,
  loadStatusByEntity,
  submitForm: submitStatusForm,
  resetForm: resetStatusForm,
  hasChanges: hasStatusChanges,  // ADD
} = statusForm;
```

Add `hasStatusChanges` to the return statement so it's accessible in the Options API methods.

**2. Modify submitStatusChange() (line 1387-1401):**

Add a silent skip guard at the top of the method, BEFORE setting `this.submitting`:
```javascript
async submitStatusChange() {
  // Silent skip: close modal without API call when nothing changed
  if (!this.hasStatusChanges) {
    this.$refs.modifyStatusModal.hide();
    return;
  }

  this.submitting = 'status';
  try {
    await this.submitStatusForm(false, false);
    this.makeToast('Status submitted successfully', 'Success', 'success');
    this.announce('Status submitted successfully');
    this.resetStatusForm();
    this.resetForm();
  } catch (e) {
    this.makeToast(e, 'Error', 'danger');
    this.announce('Failed to submit status', 'assertive');
  } finally {
    this.submitting = null;
  }
},
```

**3. Add @hide handler to the status modal:**

On the BModal element for modifyStatusModal (line 640-654), add `@hide="onModifyStatusModalHide"`.

Add the handler method:
```javascript
onModifyStatusModalHide(event) {
  // Only warn about unsaved changes if not currently submitting
  if (this.hasStatusChanges && !this.submitting) {
    const confirmed = window.confirm('You have unsaved status changes. Discard them?');
    if (!confirmed) {
      event.preventDefault();
    }
  }
},
```

**IMPORTANT:** The existing `onModifyStatusModalShow()` method (line 1453-1456) is intentionally empty -- do NOT modify it. The reset happens in `showStatusModify()` before modal opens (Phase 83 fix).
  </action>
  <verify>
1. `cd /home/bernt-popp/development/sysndd/app && npm run type-check` -- no TypeScript errors
2. `cd /home/bernt-popp/development/sysndd/app && npm run lint` -- no ESLint errors
  </verify>
  <done>
ModifyEntity status form: hasStatusChanges wired from useStatusForm composable, silent skip on save when unchanged, @hide unsaved-changes warning dialog. No regressions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add local change detection to ModifyEntity review form (Options API)</name>
  <files>app/src/views/curate/ModifyEntity.vue</files>
  <action>
This task adds local change detection to ModifyEntity's review modal. Unlike the status form, the review form does NOT use a composable -- it uses raw `review_info` (a `Review` class instance) and direct API calls with Options API `data()` fields (`this.select_phenotype`, `this.select_variation`, `this.select_additional_references`, `this.select_gene_reviews`).

**1. Add loaded data tracking in data():**

Add to the `data()` return object:
```javascript
reviewLoadedData: null, // Stores original review data for change detection
```

**2. Add hasReviewChanges computed property:**

Add a `computed` section to the component (or extend existing if one exists). Since ModifyEntity uses Options API with `setup()` returning composition values, add `hasReviewChanges` as a computed property:
```javascript
computed: {
  hasReviewChanges() {
    if (!this.reviewLoadedData) return false;
    const arrEqual = (a, b) => {
      const sa = [...a].sort();
      const sb = [...b].sort();
      return sa.length === sb.length && sa.every((v, i) => v === sb[i]);
    };
    return (
      this.review_info.synopsis !== this.reviewLoadedData.synopsis ||
      this.review_info.comment !== this.reviewLoadedData.comment ||
      !arrEqual(this.select_phenotype, this.reviewLoadedData.phenotypes) ||
      !arrEqual(this.select_variation, this.reviewLoadedData.variationOntology) ||
      !arrEqual(this.select_additional_references, this.reviewLoadedData.publications) ||
      !arrEqual(this.select_gene_reviews, this.reviewLoadedData.genereviews)
    );
  },
},
```

Note: ModifyEntity does NOT have an `arraysAreEqual` method (that helper exists in ApproveReview). Define the comparison inline within the computed property or as a local helper method.

**3. Snapshot loaded data in getReview():**

In `getReview()` (line 1054+), after loading all data into `this.review_info` and the select arrays (after all assignment lines), snapshot the original values:
```javascript
this.reviewLoadedData = {
  synopsis: this.review_info.synopsis || '',
  comment: this.review_info.comment || '',
  phenotypes: [...this.select_phenotype],
  variationOntology: [...this.select_variation],
  publications: [...this.select_additional_references],
  genereviews: [...this.select_gene_reviews],
};
```

Place this AFTER all data has been parsed and assigned to the select arrays (at the end of the try block, before finally).

**4. Add silent skip to submitReviewChange():**

At the top of `submitReviewChange()` (find it -- currently around line 1336-1386):
```javascript
async submitReviewChange() {
  if (!this.hasReviewChanges) {
    this.$refs.modifyReviewModal.hide();
    return;
  }
  // ... existing logic unchanged
}
```

**5. Add @hide handler to the review modal:**

Find the BModal for modifyReviewModal and add `@hide="onModifyReviewModalHide"`.

Add the handler method:
```javascript
onModifyReviewModalHide(event) {
  if (this.hasReviewChanges && !this.submitting) {
    const confirmed = window.confirm('You have unsaved review changes. Discard them?');
    if (!confirmed) {
      event.preventDefault();
    }
  }
},
```

**6. Reset reviewLoadedData in resetForm():**

In `resetForm()` (line 1402), add:
```javascript
this.reviewLoadedData = null;
```
  </action>
  <verify>
1. `cd /home/bernt-popp/development/sysndd/app && npm run type-check` -- no TypeScript errors
2. `cd /home/bernt-popp/development/sysndd/app && npm run lint` -- no ESLint errors
3. `cd /home/bernt-popp/development/sysndd/app && npx vitest run --reporter=verbose` -- all existing tests pass
  </verify>
  <done>
ModifyEntity review form: local hasReviewChanges computed property comparing review_info + select arrays against snapshot, silent skip on save when unchanged, @hide unsaved-changes warning dialog. reviewLoadedData reset on form reset. No regressions in existing tests. TypeScript and ESLint clean.
  </done>
</task>

</tasks>

<verification>
1. TypeScript check passes: `cd /home/bernt-popp/development/sysndd/app && npm run type-check`
2. ESLint passes: `cd /home/bernt-popp/development/sysndd/app && npm run lint`
3. All existing tests pass: `cd /home/bernt-popp/development/sysndd/app && npx vitest run --reporter=verbose`
</verification>

<success_criteria>
- Clicking Submit on status modal without changes closes modal silently (no API call)
- Clicking Submit on review modal without changes closes modal silently (no API call)
- Closing status modal with changes triggers confirmation dialog
- Closing review modal with changes triggers confirmation dialog
- Actual changes still submit correctly with success toast
- No regressions in existing curation workflows
</success_criteria>

<output>
After completion, create `.planning/phases/84-status-change-detection/84-02-SUMMARY.md`
</output>
