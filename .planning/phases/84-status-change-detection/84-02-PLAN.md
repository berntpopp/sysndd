---
phase: 84-status-change-detection
plan: 02
type: execute
wave: 2
depends_on: ["84-01"]
files_modified:
  - app/src/views/curate/ModifyEntity.vue
autonomous: true

must_haves:
  truths:
    - "When user opens ModifyEntity status modal and clicks Submit without changing anything, no API call is made and the modal closes silently"
    - "When user opens ModifyEntity review modal and clicks Submit without changing anything, no API call is made and the modal closes silently"
    - "When user changes status fields and tries to close the modal without saving, a confirmation dialog appears"
    - "When user actually changes status category or problematic flag, submitting creates a new status record"
    - "Status change pending indicator appears next to the status button in ModifyEntity when backend reports status_change"
  artifacts:
    - path: "app/src/views/curate/ModifyEntity.vue"
      provides: "Change detection wiring, silent skip, unsaved changes warning, status_change indicator"
      contains: "hasChanges"
  key_links:
    - from: "ModifyEntity.vue setup()"
      to: "useStatusForm"
      via: "hasChanges destructuring"
      pattern: "hasChanges.*statusForm"
    - from: "ModifyEntity.vue submitStatusChange()"
      to: "hasChanges check"
      via: "silent skip guard"
      pattern: "hasStatusChanges|hasChanges"
    - from: "ModifyEntity.vue @hide handler"
      to: "hasChanges check"
      via: "unsaved changes warning"
      pattern: "onModifyStatusModalHide"
---

<objective>
Wire up change detection in ModifyEntity.vue for both status and review forms: silent skip on save when unchanged, unsaved-changes confirmation on modal close, and status_change indicator icon.

Purpose: Prevent unnecessary status/review database records when curator saves without modifications. Improve UX with unsaved-changes warnings and consistent change indicators.
Output: ModifyEntity with full change detection behavior.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/84-status-change-detection/84-CONTEXT.md
@.planning/phases/84-status-change-detection/84-RESEARCH.md
@.planning/phases/84-status-change-detection/84-01-SUMMARY.md

@app/src/views/curate/ModifyEntity.vue
@app/src/views/curate/composables/useStatusForm.ts
@app/src/views/curate/ApproveReview.vue (lines 384-393 for status_change indicator pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire hasChanges into ModifyEntity status form</name>
  <files>app/src/views/curate/ModifyEntity.vue</files>
  <action>
**1. Expose hasChanges from setup():**

In the `setup()` function (line 772-798), destructure `hasChanges` from statusForm alongside the existing destructured values:
```typescript
const {
  formData: statusFormData,
  loading: statusFormLoading,
  loadStatusByEntity,
  submitForm: submitStatusForm,
  resetForm: resetStatusForm,
  hasChanges: hasStatusChanges,  // ADD
} = statusForm;
```

Add `hasStatusChanges` to the return statement.

**2. Add submitting tracking (if not already available to template):**

The `data()` section already has `submitting: null` (line 834). This is accessible in the Options API methods. Good.

**3. Modify submitStatusChange() (line 1387-1401):**

Add a silent skip guard at the top of the method, BEFORE setting `this.submitting`:
```javascript
async submitStatusChange() {
  // Silent skip: close modal without API call when nothing changed
  if (!this.hasStatusChanges) {
    this.$refs.modifyStatusModal.hide();
    return;
  }

  this.submitting = 'status';
  try {
    await this.submitStatusForm(false, false);
    this.makeToast('Status submitted successfully', 'Success', 'success');
    this.announce('Status submitted successfully');
    this.resetStatusForm();
    this.resetForm();
  } catch (e) {
    this.makeToast(e, 'Error', 'danger');
    this.announce('Failed to submit status', 'assertive');
  } finally {
    this.submitting = null;
  }
},
```

**4. Add @hide handler to the status modal:**

On the BModal element for modifyStatusModal (line 640-654), add `@hide="onModifyStatusModalHide"`.

Add the handler method (replace the existing empty onModifyStatusModalShow pattern or add alongside it):
```javascript
onModifyStatusModalHide(event) {
  // Only warn about unsaved changes if not currently submitting
  if (this.hasStatusChanges && !this.submitting) {
    const confirmed = window.confirm('You have unsaved status changes. Discard them?');
    if (!confirmed) {
      event.preventDefault();
    }
  }
},
```

**IMPORTANT:** The existing `onModifyStatusModalShow()` method (line 1453-1456) is intentionally empty -- do NOT modify it. The reset happens in `showStatusModify()` before modal opens (Phase 83 fix).

**5. Add status_change indicator to the entity preview (optional but context-specified):**

ModifyEntity loads entity via `getEntity()` which returns entity data. If the backend does NOT include `status_change` in the entity response (it's only in review/status table endpoints), skip this indicator for ModifyEntity. The indicator requirement from CONTEXT.md applies to the table views (ApproveReview, ApproveStatus) which list multiple entities with the change flag data.

Check: The entity endpoint (`/api/entity?filter=...`) does NOT return `status_change`. So no indicator is needed in ModifyEntity's entity preview card -- it only shows one entity at a time without table context.

**6. Review form change detection (review modal):**

ModifyEntity does NOT use `useReviewForm` composable for its review modal -- it uses raw `review_info` (a `Review` class instance) and direct API calls. The review form in ModifyEntity works with `this.review_info.synopsis`, `this.select_phenotype`, `this.select_variation`, `this.select_additional_references`, `this.select_gene_reviews`.

For review change detection in ModifyEntity, add local tracking:

a) In `data()`, add:
```javascript
reviewLoadedData: null, // Stores original review data for change detection
```

b) In `getReview()` method (find it -- it loads review data), after loading all data into `this.review_info` and the select arrays, snapshot:
```javascript
this.reviewLoadedData = {
  synopsis: this.review_info.synopsis,
  comment: this.review_info.comment,
  phenotypes: [...this.select_phenotype],
  variationOntology: [...this.select_variation],
  publications: [...this.select_additional_references],
  genereviews: [...this.select_gene_reviews],
};
```

c) Add a computed-like method or check in `submitReviewChange()`:
```javascript
get hasReviewChanges() {
  // Cannot use computed in Options API data, use a getter or method
}
```

Actually, since ModifyEntity uses Options API with `data()` + `methods`, use a `computed` section or a method. Add to the component:
```javascript
computed: {
  hasReviewChanges() {
    if (!this.reviewLoadedData) return false;
    return (
      this.review_info.synopsis !== this.reviewLoadedData.synopsis ||
      this.review_info.comment !== this.reviewLoadedData.comment ||
      !this.arraysAreEqual([...this.select_phenotype].sort(), [...this.reviewLoadedData.phenotypes].sort()) ||
      !this.arraysAreEqual([...this.select_variation].sort(), [...this.reviewLoadedData.variationOntology].sort()) ||
      !this.arraysAreEqual([...this.select_additional_references].sort(), [...this.reviewLoadedData.publications].sort()) ||
      !this.arraysAreEqual([...this.select_gene_reviews].sort(), [...this.reviewLoadedData.genereviews].sort())
    );
  },
},
```

Note: ModifyEntity already has an `arraysAreEqual` utility -- check if it exists. If not (it doesn't appear to have one from what was read), add a method. Actually, looking at the code, ModifyEntity does NOT have `arraysAreEqual` (that's in ApproveReview). Add it as a helper method or use inline comparison.

d) Add silent skip to `submitReviewChange()` (currently at line ~1336-1386):
```javascript
async submitReviewChange() {
  if (!this.hasReviewChanges) {
    this.$refs.modifyReviewModal.hide();
    return;
  }
  // ... existing logic
}
```

e) Add @hide handler to the review modal (find the BModal for modifyReviewModal):
```javascript
onModifyReviewModalHide(event) {
  if (this.hasReviewChanges && !this.submitting) {
    const confirmed = window.confirm('You have unsaved review changes. Discard them?');
    if (!confirmed) {
      event.preventDefault();
    }
  }
},
```

Add `@hide="onModifyReviewModalHide"` to the review BModal element.

f) Reset `this.reviewLoadedData = null` in `resetForm()` (line 1402).
  </action>
  <verify>
1. `cd /home/bernt-popp/development/sysndd/app && npm run type-check` -- no TypeScript errors
2. `cd /home/bernt-popp/development/sysndd/app && npm run lint` -- no ESLint errors
3. `cd /home/bernt-popp/development/sysndd/app && npx vitest run --reporter=verbose` -- all existing tests pass
  </verify>
  <done>
ModifyEntity status form: hasStatusChanges wired from composable, silent skip on save, @hide unsaved warning.
ModifyEntity review form: local hasReviewChanges computed, silent skip on save, @hide unsaved warning.
No regressions in existing tests. TypeScript and ESLint clean.
  </done>
</task>

</tasks>

<verification>
1. TypeScript check passes: `cd /home/bernt-popp/development/sysndd/app && npm run type-check`
2. ESLint passes: `cd /home/bernt-popp/development/sysndd/app && npm run lint`
3. All existing tests pass: `cd /home/bernt-popp/development/sysndd/app && npx vitest run --reporter=verbose`
</verification>

<success_criteria>
- Clicking Submit on status modal without changes closes modal silently (no API call)
- Clicking Submit on review modal without changes closes modal silently (no API call)
- Closing status modal with changes triggers confirmation dialog
- Closing review modal with changes triggers confirmation dialog
- Actual changes still submit correctly with success toast
- No regressions in existing curation workflows
</success_criteria>

<output>
After completion, create `.planning/phases/84-status-change-detection/84-02-SUMMARY.md`
</output>
