---
phase: 84-status-change-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/src/views/curate/composables/useStatusForm.ts
  - app/src/views/curate/composables/useReviewForm.ts
  - app/src/views/curate/composables/__tests__/useStatusForm.spec.ts
  - app/src/views/curate/composables/__tests__/useReviewForm.spec.ts
autonomous: true

must_haves:
  truths:
    - "useStatusForm exposes a hasChanges computed that is false after load and true when category_id, comment, or problematic differ from loaded values"
    - "useReviewForm exposes a hasChanges computed that is false after load and true when synopsis, comment, phenotypes, variationOntology, publications, or genereviews differ from loaded values"
    - "hasChanges returns false after resetForm is called"
    - "All existing useReviewForm tests still pass"
  artifacts:
    - path: "app/src/views/curate/composables/useStatusForm.ts"
      provides: "hasChanges computed property and loadedData ref"
      contains: "hasChanges"
    - path: "app/src/views/curate/composables/useReviewForm.ts"
      provides: "hasChanges computed property and loadedData ref"
      contains: "hasChanges"
    - path: "app/src/views/curate/composables/__tests__/useStatusForm.spec.ts"
      provides: "Change detection unit tests"
      contains: "hasChanges"
    - path: "app/src/views/curate/composables/__tests__/useReviewForm.spec.ts"
      provides: "Change detection unit tests added to existing file"
      contains: "hasChanges"
  key_links:
    - from: "useStatusForm.ts"
      to: "return statement"
      via: "hasChanges export"
      pattern: "return.*hasChanges"
    - from: "useReviewForm.ts"
      to: "return statement"
      via: "hasChanges export"
      pattern: "return.*hasChanges"
---

<objective>
Add `hasChanges` computed property to both useStatusForm and useReviewForm composables, following the established pattern from LlmPromptEditor.vue.

Purpose: Foundation for change detection -- composables track whether form data differs from loaded data, enabling silent skip and unsaved-changes warnings in consumer views.
Output: Both composables export `hasChanges`, with comprehensive unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/84-status-change-detection/84-CONTEXT.md
@.planning/phases/84-status-change-detection/84-RESEARCH.md

@app/src/views/curate/composables/useStatusForm.ts
@app/src/views/curate/composables/useReviewForm.ts
@app/src/views/curate/composables/__tests__/useReviewForm.spec.ts
@app/src/components/llm/LlmPromptEditor.vue (lines 140-155 for hasChanges pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add hasChanges to useStatusForm and useReviewForm composables</name>
  <files>
    app/src/views/curate/composables/useStatusForm.ts
    app/src/views/curate/composables/useReviewForm.ts
  </files>
  <action>
**useStatusForm.ts:**

1. Add `computed` to the import from 'vue' (line 12 currently imports `ref, reactive, watch`).

2. After the `formData` reactive declaration (line 63-67), add a `loadedData` ref:
```typescript
const loadedData = ref<Pick<StatusFormData, 'category_id' | 'comment' | 'problematic'> | null>(null);
```

3. Add `hasChanges` computed property after the `loadedData` ref:
```typescript
const hasChanges = computed(() => {
  if (!loadedData.value) return false;
  return (
    formData.category_id !== loadedData.value.category_id ||
    formData.comment !== loadedData.value.comment ||
    formData.problematic !== loadedData.value.problematic
  );
});
```

4. In `loadStatusData()` (around line 137), after setting formData fields (lines 151-153), snapshot the loaded values:
```typescript
loadedData.value = {
  category_id: formData.category_id,
  comment: formData.comment,
  problematic: formData.problematic,
};
```

5. In `loadStatusByEntity()` (around line 173), after setting formData fields (lines 187-189), snapshot the loaded values with the same pattern.

6. In `resetForm()` (line 282), add `loadedData.value = null;` after the existing reset logic (before the touched state reset, around line 291).

7. Add `hasChanges` to the return statement (line 311-338).

**useReviewForm.ts:**

1. After the `formData` reactive declaration (line 103-110), add a `loadedData` ref:
```typescript
const loadedData = ref<{
  synopsis: string;
  comment: string;
  phenotypes: string[];
  variationOntology: string[];
  publications: string[];
  genereviews: string[];
} | null>(null);
```

2. Add `hasChanges` computed (already has `computed` imported):
```typescript
const hasChanges = computed(() => {
  if (!loadedData.value) return false;
  return (
    formData.synopsis !== loadedData.value.synopsis ||
    formData.comment !== loadedData.value.comment ||
    !arraysEqual(formData.phenotypes, loadedData.value.phenotypes) ||
    !arraysEqual(formData.variationOntology, loadedData.value.variationOntology) ||
    !arraysEqual(formData.publications, loadedData.value.publications) ||
    !arraysEqual(formData.genereviews, loadedData.value.genereviews)
  );
});
```

3. Add a private helper function above the `hasChanges` computed:
```typescript
function arraysEqual(a: string[], b: string[]): boolean {
  if (a.length !== b.length) return false;
  return a.every((val, idx) => val === b[idx]);
}
```

4. In `loadReviewData()` (line 202), after loading all form data (after line 259 where originalGenereviews is set), snapshot loaded data:
```typescript
loadedData.value = {
  synopsis: formData.synopsis,
  comment: formData.comment,
  phenotypes: [...formData.phenotypes],
  variationOntology: [...formData.variationOntology],
  publications: [...formData.publications],
  genereviews: [...formData.genereviews],
};
```

5. In `resetForm()` (line 344), add `loadedData.value = null;` after clearing originalGenereviews (line 363).

6. Add `hasChanges` to the return statement (line 392-424).
  </action>
  <verify>
Run: `cd /home/bernt-popp/development/sysndd/app && npx vitest run src/views/curate/composables/__tests__/useReviewForm.spec.ts --reporter=verbose`
Existing tests must pass. Then run TypeScript check: `cd /home/bernt-popp/development/sysndd/app && npm run type-check`
  </verify>
  <done>Both composables export `hasChanges` computed property. Existing useReviewForm tests pass. TypeScript compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for change detection in both composables</name>
  <files>
    app/src/views/curate/composables/__tests__/useStatusForm.spec.ts
    app/src/views/curate/composables/__tests__/useReviewForm.spec.ts
  </files>
  <action>
**Create useStatusForm.spec.ts** -- new file following the exact pattern from useReviewForm.spec.ts:

Mock axios and useFormDraft the same way. Test cases:

1. `hasChanges is false when no data loaded` -- call useStatusForm(), check hasChanges.value is false
2. `hasChanges is false immediately after loadStatusByEntity` -- mock axios.get to return `[{category_id: 2, comment: 'test', problematic: false, status_id: 1, entity_id: 1}]`, load, check false
3. `hasChanges is true when category_id changes` -- load data, change formData.category_id, check true
4. `hasChanges is true when comment changes` -- load data, change formData.comment, check true
5. `hasChanges is true when problematic changes` -- load data, toggle formData.problematic, check true
6. `hasChanges detects whitespace changes in comment (exact comparison)` -- load, add trailing space to comment, check true
7. `hasChanges returns false after resetForm` -- load, change, reset, check false
8. `hasChanges is false after loadStatusData` -- mock axios.get for status endpoint, load via loadStatusData(statusId, reReviewSaved), check false

**Add to useReviewForm.spec.ts** -- add a new `describe('Change detection', ...)` block after the existing BUG-05 describe block:

1. `hasChanges is false when no data loaded` -- call useReviewForm(), check hasChanges.value is false
2. `hasChanges is false immediately after loadReviewData` -- mock all API responses, load, check false
3. `hasChanges is true when synopsis changes` -- load, change synopsis, check true
4. `hasChanges is true when comment changes` -- load, change comment, check true
5. `hasChanges is true when publications change` -- load, push new PMID, check true
6. `hasChanges returns false after resetForm` -- load, change, reset, check false
  </action>
  <verify>
Run: `cd /home/bernt-popp/development/sysndd/app && npx vitest run src/views/curate/composables/__tests__/ --reporter=verbose`
All tests must pass including existing BUG-05 tests and new change detection tests.
  </verify>
  <done>useStatusForm.spec.ts created with 8 test cases. useReviewForm.spec.ts extended with 6 change detection tests. All tests pass.</done>
</task>

</tasks>

<verification>
1. `cd /home/bernt-popp/development/sysndd/app && npm run type-check` -- no TypeScript errors
2. `cd /home/bernt-popp/development/sysndd/app && npx vitest run src/views/curate/composables/__tests__/ --reporter=verbose` -- all tests pass
3. `cd /home/bernt-popp/development/sysndd/app && npm run lint` -- no ESLint errors
</verification>

<success_criteria>
- useStatusForm exports hasChanges (false after load, true on field change, false after reset)
- useReviewForm exports hasChanges (false after load, true on field change, false after reset)
- All 14+ new tests pass
- All existing tests pass (especially BUG-05 publication preservation)
- TypeScript and ESLint clean
</success_criteria>

<output>
After completion, create `.planning/phases/84-status-change-detection/84-01-SUMMARY.md`
</output>
