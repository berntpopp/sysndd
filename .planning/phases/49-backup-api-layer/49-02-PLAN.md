---
phase: 49-backup-api-layer
plan: 02
type: execute
wave: 2
depends_on: ["49-01"]
files_modified:
  - api/functions/backup-functions.R
  - api/endpoints/backup_endpoints.R
  - api/functions/job-manager.R
autonomous: true

must_haves:
  truths:
    - "POST /api/backup/create triggers async backup and returns job ID"
    - "POST /api/backup/restore creates pre-restore backup before restoring"
    - "Concurrent backup requests return 409 Conflict"
    - "Restore fails if pre-restore backup fails"
    - "Backup jobs use existing job manager infrastructure"
  artifacts:
    - path: "api/functions/backup-functions.R"
      provides: "Backup execution functions"
      exports: ["execute_mysqldump", "execute_restore"]
      min_lines: 100
    - path: "api/endpoints/backup_endpoints.R"
      provides: "Backup/restore endpoints"
      exports: ["POST /create", "POST /restore"]
      min_lines: 150
    - path: "api/functions/job-manager.R"
      provides: "Progress message for backup operations"
      contains: "backup_create"
  key_links:
    - from: "api/endpoints/backup_endpoints.R"
      to: "api/functions/job-manager.R"
      via: "create_job call"
      pattern: "create_job.*backup"
    - from: "api/endpoints/backup_endpoints.R"
      to: "api/functions/backup-functions.R"
      via: "execute_mysqldump in executor_fn"
      pattern: "execute_mysqldump|execute_restore"
---

<objective>
Add backup creation and restore endpoints with async job handling.

Purpose: Administrators can trigger manual backups and restore from backups via REST API. Pre-restore safety backups (BKUP-05) ensure restore operations are reversible. Async job pattern prevents timeout on long operations.

Output: Working POST /api/backup/create and POST /api/backup/restore endpoints using job manager for async execution. Pre-restore backup automatically created before any restore.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-backup-api-layer/49-CONTEXT.md
@.planning/phases/49-backup-api-layer/49-RESEARCH.md
@.planning/phases/49-backup-api-layer/49-01-SUMMARY.md

# Reference patterns
@api/functions/job-manager.R
@api/endpoints/jobs_endpoints.R
@api/endpoints/admin_endpoints.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add backup execution functions</name>
  <files>api/functions/backup-functions.R</files>
  <action>
Extend api/functions/backup-functions.R with backup and restore execution functions.

Functions to add:

1. `execute_mysqldump(db_config, output_file)`:
   - Use system2() with mysqldump binary
   - Args: -h, -P, -u, -p, --single-transaction, --routines, --triggers, --quick
   - Capture stderr for error handling
   - Return list(success = TRUE/FALSE, file = path, error = message)
   - Follow pattern from RESEARCH.md code examples

2. `execute_restore(db_config, restore_file)`:
   - Handle both .sql and .sql.gz files
   - For .gz: use system() with gunzip piped to mysql
   - For .sql: use system() with mysql redirect
   - Return list(success = TRUE/FALSE, error = message)

3. `check_backup_in_progress()`:
   - Check jobs_env for running backup_create or backup_restore operations
   - Return TRUE if any backup operation is running
   - Used to enforce single concurrent backup rule

Code pattern for execute_mysqldump:
```r
execute_mysqldump <- function(db_config, output_file) {
  args <- c(
    "-h", db_config$host,
    "-P", as.character(db_config$port),
    "-u", db_config$user,
    paste0("-p", db_config$password),
    "--single-transaction",
    "--routines",
    "--triggers",
    "--quick",
    db_config$dbname
  )

  result <- system2(
    "mysqldump",
    args = args,
    stdout = output_file,
    stderr = TRUE
  )

  status <- attr(result, "status") %||% 0

  if (status != 0) {
    return(list(
      success = FALSE,
      error = paste(result, collapse = "\n")
    ))
  }

  list(success = TRUE, file = output_file)
}
```
  </action>
  <verify>
Run lintr: `Rscript -e "lintr::lint('api/functions/backup-functions.R')"`
Confirm functions exist: `grep -E "^execute_mysqldump|^execute_restore|^check_backup_in_progress" api/functions/backup-functions.R`
  </verify>
  <done>
backup-functions.R has execute_mysqldump(), execute_restore(), and check_backup_in_progress() functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add progress message for backup operations</name>
  <files>api/functions/job-manager.R</files>
  <action>
Update get_progress_message() function in api/functions/job-manager.R to include backup operation messages.

Add to the messages list:
```r
messages <- list(
  clustering = "Fetching interaction data from STRING-db...",
  phenotype_clustering = "Running Multiple Correspondence Analysis...",
  ontology_update = "Downloading and processing ontology data from MONDO/OMIM...",
  omim_update = "Updating OMIM annotations from mim2gene.txt + JAX API...",
  hgnc_update = "Downloading HGNC data and enriching with gnomAD constraints...",
  backup_create = "Creating database backup...",
  backup_restore = "Restoring database from backup..."
)
```

This ensures backup job status polling returns meaningful step messages.
  </action>
  <verify>
`grep "backup_create" api/functions/job-manager.R` should show the progress message.
  </verify>
  <done>
job-manager.R get_progress_message() includes backup_create and backup_restore messages.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add backup creation and restore endpoints</name>
  <files>api/endpoints/backup_endpoints.R</files>
  <action>
Extend api/endpoints/backup_endpoints.R with creation and restore endpoints.

Endpoints to add:

1. POST /create - Trigger manual backup
   - Requires Administrator role
   - Check for running backup job (return 409 if in progress per CONTEXT.md)
   - Use check_duplicate_job() from job-manager.R
   - Create async job via create_job() with 10 minute timeout (600000ms per CONTEXT.md)
   - Backup filename format: API-triggered backups use `manual_YYYY-MM-DD_HH-MM-SS.sql`
   - Return 202 Accepted with job_id, status_url
   - Set Location and Retry-After headers (5 seconds per CONTEXT.md)

2. POST /restore - Restore from backup
   - Requires Administrator role
   - Request body: { "filename": "backup-file.sql" }
   - Validate file exists (return 404 if not)
   - Check for running backup/restore job (return 409)
   - Create async job that:
     a. Creates pre-restore backup first (BKUP-05)
     b. If pre-restore fails, abort with 503 (per CONTEXT.md)
     c. Execute restore from specified file
   - Pre-restore naming: `pre-restore_YYYY-MM-DD_HH-MM-SS.sql` (per CONTEXT.md)
   - Return 202 Accepted with job_id, status_url

Code structure for create endpoint:
```r
#* Trigger manual backup creation
#*
#* Creates a new database backup asynchronously.
#* Returns job ID for status polling.
#* Requires Administrator role.
#*
#* @tag backup
#* @serializer json list(na="string")
#* @post /create
function(req, res) {
  require_role(req, res, "Administrator")

  # Check for duplicate job
  dup_check <- check_duplicate_job("backup_create", list())
  if (dup_check$duplicate) {
    res$status <- 409
    return(list(
      error = "BACKUP_IN_PROGRESS",
      message = "A backup operation is already running",
      existing_job_id = dup_check$existing_job_id
    ))
  }

  # Database config for daemon
  db_config <- list(
    dbname = dw$dbname,
    host = dw$host,
    user = dw$user,
    password = dw$password,
    port = dw$port
  )

  backup_filename <- sprintf("manual_%s.sql", format(Sys.time(), "%Y-%m-%d_%H-%M-%S"))

  result <- create_job(
    operation = "backup_create",
    params = list(
      db_config = db_config,
      backup_dir = "/backup",
      backup_filename = backup_filename
    ),
    timeout_ms = 600000,  # 10 minutes per CONTEXT.md
    executor_fn = function(params) {
      # Source backup functions in daemon
      source("/app/functions/backup-functions.R", local = FALSE)

      output_path <- file.path(params$backup_dir, params$backup_filename)
      result <- execute_mysqldump(params$db_config, output_path)

      if (!result$success) {
        stop(paste("Backup failed:", result$error))
      }

      list(
        status = "completed",
        filename = params$backup_filename,
        size_bytes = file.info(output_path)$size
      )
    }
  )

  # Handle capacity exceeded
  if (!is.null(result$error)) {
    res$status <- 503
    res$setHeader("Retry-After", as.character(result$retry_after))
    return(result)
  }

  res$status <- 202
  res$setHeader("Location", paste0("/api/jobs/", result$job_id, "/status"))
  res$setHeader("Retry-After", "5")

  list(
    job_id = result$job_id,
    status = "accepted",
    estimated_seconds = 120,
    status_url = paste0("/api/jobs/", result$job_id, "/status")
  )
}
```

Follow similar pattern for restore endpoint with pre-restore backup step.
  </action>
  <verify>
1. Run lintr: `Rscript -e "lintr::lint('api/endpoints/backup_endpoints.R')"`
2. Confirm endpoints exist: `grep -E "@post /create|@post /restore" api/endpoints/backup_endpoints.R`
  </verify>
  <done>
backup_endpoints.R has POST /create and POST /restore endpoints using job manager for async execution.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. R code passes linting:
   - `Rscript -e "lintr::lint('api/functions/backup-functions.R')"` - no errors
   - `Rscript -e "lintr::lint('api/endpoints/backup_endpoints.R')"` - no errors
   - `Rscript -e "lintr::lint('api/functions/job-manager.R')"` - no errors

2. All functions and endpoints exist:
   - execute_mysqldump, execute_restore in backup-functions.R
   - POST /create, POST /restore in backup_endpoints.R
   - backup_create, backup_restore in job-manager.R progress messages

3. Job manager integration:
   - Endpoints use create_job() for async execution
   - Duplicate job detection prevents concurrent backups
</verification>

<success_criteria>
1. api/functions/backup-functions.R has execute_mysqldump() and execute_restore() functions
2. api/endpoints/backup_endpoints.R has POST /create and POST /restore endpoints
3. POST /create returns 202 with job_id for async backup creation
4. POST /restore creates pre-restore backup before restoring (BKUP-05)
5. Concurrent backup requests return 409 Conflict
6. All R code passes lintr (0 errors)
</success_criteria>

<output>
After completion, create `.planning/phases/49-backup-api-layer/49-02-SUMMARY.md`
</output>
