---
phase: 13-mixin-composable-conversion
plan: 04
type: execute
wave: 3
depends_on: ["13-02", "13-03"]
files_modified:
  - app/src/composables/useTableData.js
  - app/src/composables/useTableMethods.js
  - app/src/composables/index.js
autonomous: true

must_haves:
  truths:
    - "useTableData provides all reactive table state (items, currentPage, perPage, sortBy, etc.)"
    - "useTableMethods provides table action methods (filtered, handleSortByOrDescChange, requestExcel, etc.)"
    - "sortDesc is a computed getter/setter for backward compatibility"
    - "Each useTableData call creates independent state (per-instance)"
  artifacts:
    - path: "app/src/composables/useTableData.js"
      provides: "Per-instance reactive table state and computed properties"
      exports: ["useTableData"]
    - path: "app/src/composables/useTableMethods.js"
      provides: "Table action methods (sort, filter, pagination, export)"
      exports: ["useTableMethods"]
    - path: "app/src/composables/index.js"
      provides: "Updated barrel export with table composables"
      contains: "export { default as useTableData }"
  key_links:
    - from: "app/src/composables/useTableData.js"
      to: "vue reactivity"
      via: "ref and computed imports"
      pattern: "import.*ref.*computed.*from.*vue"
    - from: "app/src/composables/useTableMethods.js"
      to: "useToast"
      via: "error handling in requestExcel"
      pattern: "makeToast.*danger"
---

<objective>
Create useTableData and useTableMethods composables.

Purpose: Convert the table-related mixins that provide shared table state and methods. These are used by table components to manage pagination, sorting, filtering, and data export. Each call creates independent state (per-instance pattern).

Output: Two table composables that work together to provide complete table functionality
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-mixin-composable-conversion/13-CONTEXT.md
@.planning/phases/13-mixin-composable-conversion/13-RESEARCH.md

# Source mixins to convert
@app/src/assets/js/mixins/tableDataMixin.js
@app/src/assets/js/mixins/tableMethodsMixin.js

# Prior plan summaries
@.planning/phases/13-mixin-composable-conversion/13-01-SUMMARY.md
@.planning/phases/13-mixin-composable-conversion/13-02-SUMMARY.md
@.planning/phases/13-mixin-composable-conversion/13-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useTableData composable</name>
  <files>app/src/composables/useTableData.js, app/src/composables/index.js</files>
  <action>
Convert tableDataMixin to useTableData composable with per-instance reactive state:

```javascript
import { ref, computed } from 'vue';

/**
 * Composable for shared table data state.
 * Each call creates independent state (per-instance pattern).
 *
 * @param {Object} options - Initial options
 * @param {number} options.pageSize - Initial page size (default: 10)
 * @param {string} options.sort - Initial sort string
 * @param {number} options.pageAfter - Initial page after value
 * @returns {Object} Reactive table state and computed properties
 */
export default function useTableData(options = {}) {
  // Reactive state (per-instance)
  const items = ref([]);
  const totalRows = ref(0);
  const currentPage = ref(1);
  const currentItemID = ref(options.pageAfter || 0);
  const prevItemID = ref(null);
  const nextItemID = ref(null);
  const lastItemID = ref(null);
  const executionTime = ref(0);
  const perPage = ref(Number(options.pageSize) || 10);
  const pageOptions = ref([10, 25, 50, 100]);

  // Bootstrap-Vue-Next uses array-based sortBy: [{ key: 'column', order: 'asc'|'desc' }]
  const sortBy = ref([]);
  const sort = ref(options.sort || '');

  // Note: filter is defined in each component with its specific structure
  // Do NOT define filter here to avoid state duplication
  const filter_string = ref('');
  const filterOn = ref([]);
  const downloading = ref(false);
  const loading = ref(true);
  const isBusy = ref(false);

  // Computed properties for backward compatibility
  const sortDesc = computed({
    get: () => sortBy.value.length > 0 && sortBy.value[0].order === 'desc',
    set: (value) => {
      if (sortBy.value.length > 0) {
        sortBy.value = [{ key: sortBy.value[0].key, order: value ? 'desc' : 'asc' }];
      }
    },
  });

  const sortColumn = computed(() =>
    sortBy.value.length > 0 ? sortBy.value[0].key : ''
  );

  const removeFiltersButtonVariant = computed(() =>
    (filter_string.value === '' || filter_string.value === null || filter_string.value === 'null')
      ? 'info'
      : 'warning'
  );

  const removeFiltersButtonTitle = computed(() => {
    let title = 'The table is ';
    title += (filter_string.value === '' || filter_string.value === null || filter_string.value === 'null')
      ? 'not '
      : '';
    title += 'filtered.';
    if (filter_string.value !== '' && filter_string.value !== null && filter_string.value !== 'null') {
      title += ' Click to remove all filters.';
    }
    return title;
  });

  return {
    // State refs
    items,
    totalRows,
    currentPage,
    currentItemID,
    prevItemID,
    nextItemID,
    lastItemID,
    executionTime,
    perPage,
    pageOptions,
    sortBy,
    sort,
    filter_string,
    filterOn,
    downloading,
    loading,
    isBusy,
    // Computed
    sortDesc,
    sortColumn,
    removeFiltersButtonVariant,
    removeFiltersButtonTitle,
  };
}
```

Update index.js to export useTableData.
  </action>
  <verify>
- useTableData.js exists with all state refs and computed properties
- sortDesc is a computed with getter/setter
- Each call creates fresh state (not shared)
- index.js exports useTableData
  </verify>
  <done>useTableData composable created with per-instance reactive state</done>
</task>

<task type="auto">
  <name>Task 2: Create useTableMethods composable</name>
  <files>app/src/composables/useTableMethods.js, app/src/composables/index.js</files>
  <action>
Convert tableMethodsMixin to useTableMethods composable.

Key design decisions:
- Methods need access to table state, so accept tableData as parameter
- Methods need access to component-specific things (filter, loadData, apiEndpoint)
- Use dependency injection pattern: pass required dependencies

```javascript
import { useRoute } from 'vue-router';
import useToast from './useToast';
import useUrlParsing from './useUrlParsing';

/**
 * Composable for table action methods.
 *
 * @param {Object} tableData - Reactive table data from useTableData()
 * @param {Object} options - Component-specific options
 * @param {Function} options.loadData - Function to load/refresh data
 * @param {Object} options.filter - Reactive filter object
 * @param {string} options.apiEndpoint - API endpoint for Excel export
 * @param {Object} options.axios - Axios instance
 * @returns {Object} Table action methods
 */
export default function useTableMethods(tableData, options = {}) {
  const route = useRoute();
  const { makeToast } = useToast();
  const { filterObjToStr } = useUrlParsing();

  const {
    loadData,
    filter,
    apiEndpoint,
    axios,
  } = options;

  // Destructure needed state from tableData
  const {
    sort,
    filter_string,
    sortBy,
    currentItemID,
    perPage,
    currentPage,
    prevItemID,
    nextItemID,
    lastItemID,
    downloading,
  } = tableData;

  /**
   * Copies the current page URL with query parameters to clipboard.
   */
  const copyLinkToClipboard = () => {
    const urlParam = `sort=${sort.value}&filter=${filter_string.value}&page_after=${currentItemID.value}&page_size=${perPage.value}`;
    navigator.clipboard.writeText(
      `${process.env.VUE_APP_URL || import.meta.env.VITE_APP_URL}${route.path}?${urlParam}`
    );
  };

  /**
   * Handles changes in sorting order or direction.
   */
  const handleSortByOrDescChange = () => {
    currentItemID.value = 0;

    const sortColumn = sortBy.value.length > 0 ? sortBy.value[0].key : '';
    const sortOrder = sortBy.value.length > 0 ? sortBy.value[0].order : 'asc';
    const isDesc = sortOrder === 'desc';

    sort.value = (isDesc ? '-' : '+') + sortColumn;
    filtered();
  };

  /**
   * Handles per-page changes.
   * @param {number|string} newPerPage - New page size
   */
  const handlePerPageChange = (newPerPage) => {
    perPage.value = parseInt(newPerPage, 10);
    filtered();
  };

  /**
   * Handles page changes in pagination.
   * @param {number} value - New page number
   */
  const handlePageChange = (value) => {
    const totalPages = tableData.totalPages?.value || Math.ceil(tableData.totalRows.value / perPage.value);

    if (value === 1) {
      currentItemID.value = 0;
    } else if (value === totalPages) {
      currentItemID.value = lastItemID.value;
    } else if (value > currentPage.value) {
      currentItemID.value = nextItemID.value;
    } else if (value < currentPage.value) {
      currentItemID.value = prevItemID.value;
    }
    filtered();
  };

  /**
   * Filters table data based on current filter criteria.
   */
  const filtered = () => {
    if (!filter) {
      if (loadData) loadData();
      return;
    }

    const filter_string_loc = filterObjToStr(filter.value || filter);

    if (filter_string_loc !== filter_string.value) {
      filter_string.value = filter_string_loc;
    }

    if (loadData) loadData();
  };

  /**
   * Resets all filters to default state.
   */
  const removeFilters = () => {
    const filterObj = filter.value || filter;
    Object.keys(filterObj).forEach((key) => {
      filterObj[key].content = null;
    });
    filtered();
  };

  /**
   * Clears the global search filter.
   */
  const removeSearch = () => {
    const filterObj = filter.value || filter;
    if (filterObj.any) {
      filterObj.any.content = null;
    }
    filtered();
  };

  /**
   * Downloads table data as Excel file.
   */
  const requestExcel = async () => {
    if (!axios || !apiEndpoint) {
      console.warn('requestExcel requires axios and apiEndpoint in options');
      return;
    }

    downloading.value = true;

    const urlParam = `sort=${sort.value}&filter=${filter_string.value}&page_after=0&page_size=all&format=xlsx`;
    const baseUrl = process.env.VUE_APP_API_URL || import.meta.env.VITE_API_URL;
    const apiUrl = `${baseUrl}/api/${apiEndpoint}?${urlParam}`;

    try {
      const response = await axios({
        url: apiUrl,
        method: 'GET',
        responseType: 'blob',
      });

      const fileURL = window.URL.createObjectURL(new Blob([response.data]));
      const fileLink = document.createElement('a');
      fileLink.setAttribute('download', `sysndd_${apiEndpoint}_table.xlsx`);
      fileLink.href = fileURL;
      document.body.appendChild(fileLink);
      fileLink.click();
      document.body.removeChild(fileLink);
      window.URL.revokeObjectURL(fileURL);
    } catch (e) {
      makeToast(e, 'Error', 'danger');
    } finally {
      downloading.value = false;
    }
  };

  /**
   * Truncates a string to specified length.
   * @param {string} str - String to truncate
   * @param {number} n - Maximum length
   * @returns {string} Truncated string
   */
  const truncate = (str, n) => {
    return str.length > n ? `${str.substr(0, n - 1)}...` : str;
  };

  /**
   * Normalizes a node object for tree components.
   * @param {*} node - Node to normalize
   * @returns {Object} Normalized node with id and label
   */
  const normalizer = (node) => ({
    id: node,
    label: node,
  });

  /**
   * Handles sort updates from GenericTable (legacy format).
   * @param {Object} payload - { sortBy: string, sortDesc: boolean }
   */
  const handleSortUpdate = ({ sortBy: sortByKey, sortDesc }) => {
    sortBy.value = [{ key: sortByKey, order: sortDesc ? 'desc' : 'asc' }];
  };

  /**
   * Handles sort-by updates from Bootstrap-Vue-Next BTable.
   * @param {Array} newSortBy - [{ key, order }]
   */
  const handleSortByUpdate = (newSortBy) => {
    sortBy.value = newSortBy;
  };

  return {
    copyLinkToClipboard,
    handleSortByOrDescChange,
    handlePerPageChange,
    handlePageChange,
    filtered,
    removeFilters,
    removeSearch,
    requestExcel,
    truncate,
    normalizer,
    handleSortUpdate,
    handleSortByUpdate,
  };
}
```

Update index.js to export useTableMethods.
  </action>
  <verify>
- useTableMethods.js exists with all table action methods
- Methods accept tableData and options as parameters
- requestExcel uses makeToast for errors
- index.js exports useTableMethods
  </verify>
  <done>useTableMethods composable created with all table action methods</done>
</task>

</tasks>

<verification>
1. Both table composables exist and are exported from index.js

2. Build succeeds: `cd app && npm run build`

3. API design verification:
   - useTableData() returns reactive state refs
   - useTableMethods(tableData, options) accepts dependencies
   - sortDesc computed works as getter/setter

4. Per-instance verification (conceptual):
```javascript
const table1 = useTableData({ pageSize: 10 });
const table2 = useTableData({ pageSize: 25 });
// table1.perPage and table2.perPage are independent
```
</verification>

<success_criteria>
- useTableData provides all reactive table state
- useTableMethods provides all table action methods
- Each composable call creates independent state
- sortDesc backward compatibility preserved
- Build succeeds with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-mixin-composable-conversion/13-04-SUMMARY.md`
</output>
