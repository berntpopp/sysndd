---
phase: 25-performance-optimization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - api/endpoints/analysis_endpoints.R
  - api/tests/testthat/test-unit-analysis-endpoints.R
autonomous: true

must_haves:
  truths:
    - "functional_clustering endpoint accepts pageAfter and pageSize parameters"
    - "Response includes pagination metadata (totalCount, hasMore, nextCursor)"
    - "Clusters are sorted deterministically before pagination"
    - "Empty pageAfter returns first page"
    - "Response size reduced from ~8.6MB to <500KB per page"
  artifacts:
    - path: "api/endpoints/analysis_endpoints.R"
      provides: "Paginated functional_clustering endpoint"
      contains: "pageAfter"
    - path: "api/tests/testthat/test-unit-analysis-endpoints.R"
      provides: "Pagination unit tests"
      contains: "pagination"
  key_links:
    - from: "functional_clustering endpoint"
      to: "generate_cursor_pag_inf"
      via: "pagination helper"
      pattern: "generate_cursor_pag_inf"
    - from: "clusters_sorted"
      to: "arrange(cluster)"
      via: "stable sort"
      pattern: "arrange\\(cluster\\)"
---

<objective>
Add cursor-based pagination to functional_clustering endpoint.

Purpose: Reduce response payload from 8.6MB to <500KB per page (PERF-05), eliminating JSON serialization blocking that causes 500-2000ms delays. This directly improves API responsiveness for concurrent users.

Output: Paginated functional_clustering endpoint following existing Entities pattern (pageAfter cursor + pageSize parameters).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-performance-optimization/25-CONTEXT.md
@.planning/phases/25-performance-optimization/25-RESEARCH.md

# Key source files
@api/endpoints/analysis_endpoints.R
@api/functions/helper-functions.R (lines 637-700 for generate_cursor_pag_inf)
@api/endpoints/entity_endpoints.R (lines 13-117 for pagination pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pagination parameters to functional_clustering endpoint</name>
  <files>api/endpoints/analysis_endpoints.R</files>
  <action>
Update the functional_clustering endpoint to support cursor-based pagination.

Modify the endpoint definition (starting at line 35):

1. Add plumber parameter annotations after existing @tag and @serializer:
```r
#* @param page_after:str Cursor for pagination (hash_filter of last item, empty for first page)
#* @param page_size:str Number of clusters per page (default "10", max "50")
```

2. Update function signature to accept parameters:
```r
function(page_after = "", page_size = "10") {
```

3. Add parameter validation at the beginning of the function body (after link definitions):
```r
# Validate and parse pagination parameters
page_size_int <- min(max(as.integer(page_size), 1), 50)
page_after_clean <- if (is.null(page_after) || page_after == "") "" else page_after
```

4. After generating functional_clusters (line 88), add sorting and pagination:
```r
# Sort clusters deterministically for stable pagination
# (prevents duplicates/gaps across pages)
clusters_sorted <- functional_clusters %>%
  arrange(cluster) %>%
  mutate(row_num = row_number())

# Find cursor position
if (page_after_clean == "") {
  start_idx <- 1
} else {
  cursor_pos <- which(clusters_sorted$hash_filter == page_after_clean)
  start_idx <- if (length(cursor_pos) > 0) cursor_pos[1] + 1 else 1
}

# Extract page slice
end_idx <- min(start_idx + page_size_int - 1, nrow(clusters_sorted))
clusters_page <- clusters_sorted %>%
  slice(start_idx:end_idx) %>%
  select(-row_num)  # Remove internal field

# Generate next cursor (hash_filter of last item in page)
next_cursor <- if (end_idx < nrow(clusters_sorted)) {
  clusters_page %>% slice(n()) %>% pull(hash_filter)
} else {
  NULL
}
```

5. Update the return statement (lines 106-110) to include pagination metadata:
```r
list(
  categories = categories,
  clusters = clusters_page,  # Paginated clusters (was functional_clusters)
  pagination = list(
    page_size = page_size_int,
    page_after = page_after_clean,
    next_cursor = next_cursor,
    total_count = nrow(clusters_sorted),
    has_more = !is.null(next_cursor)
  )
)
```

WHY this pattern:
- Follows existing Entities endpoint pattern (pageAfter/pageSize)
- hash_filter already exists and is unique per cluster (ideal cursor)
- Sorting by cluster number ensures deterministic order
- Max page_size=50 prevents abuse while allowing flexibility
  </action>
  <verify>
1. `grep -n "page_after\|page_size" api/endpoints/analysis_endpoints.R` shows new parameters
2. `grep -n "pagination" api/endpoints/analysis_endpoints.R` shows pagination metadata in response
3. `grep -n "arrange(cluster)" api/endpoints/analysis_endpoints.R` shows sorting for stable pagination
4. No syntax errors: `Rscript -e "source('api/endpoints/analysis_endpoints.R')"`
  </verify>
  <done>
- functional_clustering accepts page_after and page_size parameters
- Response includes pagination object with next_cursor, total_count, has_more
- Clusters sorted deterministically before pagination
- Parameter validation prevents invalid values
  </done>
</task>

<task type="auto">
  <name>Task 2: Update endpoint documentation and add backward compatibility</name>
  <files>api/endpoints/analysis_endpoints.R</files>
  <action>
Enhance the endpoint documentation and ensure backward compatibility.

1. Update the endpoint description block (lines 19-34):
```r
#* Retrieve Functional Clustering Data with Pagination
#*
#* This endpoint fetches functional clustering data for genes with NDD phenotype.
#* Results are paginated to reduce response size and improve performance.
#*
#* # `Details`
#* - Returns clusters sorted by cluster number for stable pagination
#* - Use `page_after` cursor to fetch subsequent pages
#* - Default page size is 10 clusters, maximum is 50
#* - Categories are returned in full (small dataset, not paginated)
#*
#* # `Pagination`
#* - First page: omit `page_after` or pass empty string
#* - Next page: use `next_cursor` from previous response as `page_after`
#* - Last page: `has_more` will be `false` and `next_cursor` will be `null`
#*
#* # `Return`
#* Returns categories, paginated clusters, and pagination metadata.
#*
#* @tag analysis
#* @serializer json list(na="string")
```

2. Add response examples in documentation:
```r
#* @response 200 OK. Returns object with:
#*   - categories: Full list of enrichment categories with links
#*   - clusters: Array of cluster objects (paginated)
#*   - pagination: {page_size, page_after, next_cursor, total_count, has_more}
```

3. Ensure backward compatibility note:
```r
# NOTE: Backward compatibility
# - Clients not using pagination get first 10 clusters (was all clusters)
# - To get all clusters, iterate using next_cursor until has_more=false
# - Categories still returned in full (not paginated)
```

WHY backward compatibility matters:
- Existing frontend code may not handle pagination yet
- Default page_size=10 returns manageable subset
- Frontend will be updated in Phase 26/27 to handle pagination
  </action>
  <verify>
1. `grep -n "Pagination\|backward" api/endpoints/analysis_endpoints.R` shows documentation
2. Documentation includes usage examples for cursor navigation
3. Backward compatibility note present in code comments
  </verify>
  <done>
- Endpoint documentation updated with pagination details
- Response structure documented
- Backward compatibility note added for existing clients
  </done>
</task>

<task type="auto">
  <name>Task 3: Add pagination unit tests</name>
  <files>api/tests/testthat/test-unit-analysis-endpoints.R</files>
  <action>
Create unit tests for the pagination logic. Create new file or append to existing.

Create `api/tests/testthat/test-unit-analysis-endpoints.R`:

```r
# test-unit-analysis-endpoints.R
# Unit tests for analysis_endpoints.R pagination logic

# Test pagination parameter validation
test_that("page_size is validated and clamped to valid range", {
  # Test valid integer parsing
  expect_equal(min(max(as.integer("10"), 1), 50), 10)
  expect_equal(min(max(as.integer("1"), 1), 50), 1)
  expect_equal(min(max(as.integer("50"), 1), 50), 50)

  # Test clamping below minimum

  expect_equal(min(max(as.integer("0"), 1), 50), 1)
  expect_equal(min(max(as.integer("-5"), 1), 50), 1)


  # Test clamping above maximum
  expect_equal(min(max(as.integer("100"), 1), 50), 50)
  expect_equal(min(max(as.integer("999"), 1), 50), 50)
})

test_that("page_after handles empty and null values", {
  # Empty string
  page_after <- ""
  result <- if (is.null(page_after) || page_after == "") "" else page_after
  expect_equal(result, "")

  # NULL value
  page_after <- NULL
  result <- if (is.null(page_after) || page_after == "") "" else page_after
  expect_equal(result, "")

  # Valid cursor
  page_after <- "abc123hash"
  result <- if (is.null(page_after) || page_after == "") "" else page_after
  expect_equal(result, "abc123hash")
})

test_that("pagination slice calculation is correct", {
  # Simulate cluster data
  test_data <- tibble::tibble(
    cluster = 1:100,
    hash_filter = paste0("hash_", 1:100)
  ) %>%
    dplyr::mutate(row_num = dplyr::row_number())

  page_size <- 10

  # First page (page_after = "")
  start_idx <- 1
  end_idx <- min(start_idx + page_size - 1, nrow(test_data))
  expect_equal(start_idx, 1)
  expect_equal(end_idx, 10)

  # Second page (page_after = "hash_10")
  cursor_pos <- which(test_data$hash_filter == "hash_10")
  start_idx <- cursor_pos + 1
  end_idx <- min(start_idx + page_size - 1, nrow(test_data))
  expect_equal(start_idx, 11)
  expect_equal(end_idx, 20)

  # Last page
  cursor_pos <- which(test_data$hash_filter == "hash_95")
  start_idx <- cursor_pos + 1
  end_idx <- min(start_idx + page_size - 1, nrow(test_data))
  expect_equal(start_idx, 96)
  expect_equal(end_idx, 100)  # Only 5 items remaining
})

test_that("next_cursor is NULL on last page", {
  test_data <- tibble::tibble(
    cluster = 1:25,
    hash_filter = paste0("hash_", 1:25)
  )

  # Page that doesn't reach end
  end_idx <- 20
  next_cursor <- if (end_idx < nrow(test_data)) {
    test_data %>% dplyr::slice(end_idx) %>% dplyr::pull(hash_filter)
  } else {
    NULL
  }
  expect_equal(next_cursor, "hash_20")

  # Last page
  end_idx <- 25
  next_cursor <- if (end_idx < nrow(test_data)) {
    test_data %>% dplyr::slice(end_idx) %>% dplyr::pull(hash_filter)
  } else {
    NULL
  }
  expect_null(next_cursor)
})

test_that("sorting ensures stable pagination order", {
  # Simulate unsorted data
  unsorted_data <- tibble::tibble(
    cluster = c(5, 2, 8, 1, 3),
    hash_filter = paste0("hash_", c(5, 2, 8, 1, 3))
  )

  # Sort should produce deterministic order
  sorted_data <- unsorted_data %>%
    dplyr::arrange(cluster)

  expect_equal(sorted_data$cluster, c(1, 2, 3, 5, 8))
  expect_equal(sorted_data$hash_filter, c("hash_1", "hash_2", "hash_3", "hash_5", "hash_8"))
})

test_that("pagination metadata structure is correct", {
  # Simulate pagination metadata
  pagination <- list(
    page_size = 10,
    page_after = "",
    next_cursor = "hash_10",
    total_count = 87,
    has_more = TRUE
  )

  expect_true("page_size" %in% names(pagination))
  expect_true("page_after" %in% names(pagination))
  expect_true("next_cursor" %in% names(pagination))
  expect_true("total_count" %in% names(pagination))
  expect_true("has_more" %in% names(pagination))

  expect_type(pagination$page_size, "double")
  expect_type(pagination$total_count, "double")
  expect_type(pagination$has_more, "logical")
})
```

These tests verify the pagination logic without requiring database access.
  </action>
  <verify>
1. `ls -la api/tests/testthat/test-unit-analysis-endpoints.R` confirms file exists
2. Run tests: `cd /home/bernt-popp/development/sysndd/api && Rscript -e "testthat::test_file('tests/testthat/test-unit-analysis-endpoints.R')"`
3. All tests pass
  </verify>
  <done>
- Unit test file created with pagination logic tests
- Tests cover parameter validation, slice calculation, cursor generation
- Tests verify sorting for stable pagination
- All tests pass without database dependency
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Pagination parameters verification:**
   ```bash
   grep -E "page_after|page_size" api/endpoints/analysis_endpoints.R
   ```
   Should show parameters in function signature and @param annotations

2. **Pagination response verification:**
   ```bash
   grep -E "pagination|next_cursor|has_more" api/endpoints/analysis_endpoints.R
   ```
   Should show pagination metadata in response object

3. **Sorting verification:**
   ```bash
   grep -E "arrange\(cluster\)" api/endpoints/analysis_endpoints.R
   ```
   Should show deterministic sorting before pagination

4. **Syntax verification:**
   ```bash
   cd /home/bernt-popp/development/sysndd/api
   Rscript -e "source('endpoints/analysis_endpoints.R')"
   ```
   No errors

5. **Test verification:**
   ```bash
   cd /home/bernt-popp/development/sysndd/api
   Rscript -e "testthat::test_file('tests/testthat/test-unit-analysis-endpoints.R')"
   ```
   All tests pass
</verification>

<success_criteria>
- PERF-05: functional_clustering endpoint accepts pagination parameters
- Response includes pagination metadata (page_size, next_cursor, total_count, has_more)
- Clusters sorted deterministically for stable pagination
- Default behavior returns first page (backward compatible)
- Unit tests verify pagination logic
</success_criteria>

<output>
After completion, create `.planning/phases/25-performance-optimization/25-02-SUMMARY.md`
</output>
