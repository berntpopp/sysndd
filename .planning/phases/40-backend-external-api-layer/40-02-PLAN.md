---
phase: 40-backend-external-api-layer
plan: 02
type: execute
wave: 2
depends_on: ["40-01"]
files_modified:
  - api/functions/external-proxy-gnomad.R
  - api/functions/external-proxy-uniprot.R
  - api/functions/external-proxy-ensembl.R
  - api/start_sysndd_api.R
autonomous: true

must_haves:
  truths:
    - "gnomAD proxy returns constraint scores (pLI, LOEUF, mis_z) and ClinVar variant data for a gene symbol"
    - "UniProt proxy returns protein domain coordinates and features for a gene symbol"
    - "Ensembl proxy returns gene structure data (exons, transcripts) for a gene symbol"
    - "All three proxy functions use memoised caching with appropriate TTL"
  artifacts:
    - path: "api/functions/external-proxy-gnomad.R"
      provides: "fetch_gnomad_constraints(), fetch_gnomad_clinvar_variants() + memoised versions"
      min_lines: 80
    - path: "api/functions/external-proxy-uniprot.R"
      provides: "fetch_uniprot_domains() + memoised version"
      min_lines: 50
    - path: "api/functions/external-proxy-ensembl.R"
      provides: "fetch_ensembl_gene_structure() + memoised version"
      min_lines: 50
  key_links:
    - from: "api/functions/external-proxy-gnomad.R"
      to: "external-proxy-functions.R"
      via: "uses EXTERNAL_API_THROTTLE$gnomad and cache_static/cache_dynamic"
      pattern: "EXTERNAL_API_THROTTLE|cache_static|cache_dynamic"
    - from: "api/functions/external-proxy-uniprot.R"
      to: "external-proxy-functions.R"
      via: "uses make_external_request and cache_stable"
      pattern: "make_external_request|cache_stable"
    - from: "api/functions/external-proxy-ensembl.R"
      to: "external-proxy-functions.R"
      via: "uses make_external_request and cache_stable"
      pattern: "make_external_request|cache_stable"
---

<objective>
Implement proxy functions for gnomAD (GraphQL), UniProt (REST), and Ensembl (REST) APIs with per-source caching and memoisation.

Purpose: These three sources provide the core genomic data: constraint scores, ClinVar variants, protein domains, and gene structure -- required by Phases 42-44.

Output: Three per-source function files + memoised wrappers registered in API startup.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/40-backend-external-api-layer/40-CONTEXT.md
@.planning/phases/40-backend-external-api-layer/40-RESEARCH.md
@.planning/phases/40-backend-external-api-layer/40-01-SUMMARY.md

Key existing files:
@api/functions/external-proxy-functions.R (shared infrastructure from Plan 01)
@api/functions/omim-functions.R (httr2 pattern reference)
@api/start_sysndd_api.R (where to register new source files)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gnomAD GraphQL proxy functions</name>
  <files>api/functions/external-proxy-gnomad.R</files>
  <action>
Create `api/functions/external-proxy-gnomad.R` with two proxy functions:

1. **`fetch_gnomad_constraints(gene_symbol)`**:
   - Validates gene_symbol using `validate_gene_symbol()` from external-proxy-functions.R. If invalid, return `list(error = TRUE, source = "gnomad", message = "Invalid gene symbol")`.
   - Uses ghql to query gnomAD v4 GraphQL API at `https://gnomad.broadinstitute.org/api`
   - GraphQL query (use ghql::GraphqlClient and ghql::Query):
     ```
     query GeneConstraint($symbol: String!) {
       gene(gene_symbol: $symbol, reference_genome: GRCh38) {
         gene_id
         symbol
         gnomad_constraint {
           pLI
           oe_lof
           oe_lof_lower
           oe_lof_upper
           oe_mis
           oe_mis_lower
           oe_mis_upper
           oe_syn
           oe_syn_lower
           oe_syn_upper
           exp_lof
           obs_lof
           exp_mis
           obs_mis
           exp_syn
           obs_syn
           lof_z
           mis_z
           syn_z
         }
       }
     }
     ```
   - Use httr2 directly (not ghql::exec, which has limited error handling): build POST request to gnomAD API URL with JSON body `list(query = query_string, variables = list(symbol = gene_symbol))`.
   - Apply throttle from `EXTERNAL_API_THROTTLE$gnomad` via `req_throttle()`.
   - Apply retry: `req_retry(max_tries = 3, max_seconds = 120, backoff = ~2^.x, is_transient = ~resp_status(.x) %in% c(429, 503, 504))`.
   - Apply timeout: `req_timeout(30)`.
   - Use `req_error(is_error = ~FALSE)` to handle errors manually.
   - Parse response: extract `data$gene$gnomad_constraint` from JSON body.
   - If gene not found (data$gene is NULL), return `list(found = FALSE, source = "gnomad")`.
   - Return structured result: `list(source = "gnomad", gene_symbol = symbol, gene_id = data$gene$gene_id, constraints = data$gene$gnomad_constraint)`.
   - Wrap in tryCatch for network errors.

2. **`fetch_gnomad_clinvar_variants(gene_symbol)`**:
   - Validates gene_symbol using `validate_gene_symbol()`.
   - GraphQL query to gnomAD:
     ```
     query GeneClinvar($symbol: String!) {
       gene(gene_symbol: $symbol, reference_genome: GRCh38) {
         gene_id
         symbol
         clinvar_variants {
           clinical_significance
           clinvar_variation_id
           gold_stars
           hgvsc
           hgvsp
           in_gnomad
           major_consequence
           pos
           review_status
           variant_id
         }
       }
     }
     ```
   - Same httr2 pattern as above (throttle + retry + timeout).
   - Parse response: extract `data$gene$clinvar_variants`.
   - Return: `list(source = "gnomad_clinvar", gene_symbol = symbol, gene_id = data$gene$gene_id, variants = data$gene$clinvar_variants, variant_count = length(data$gene$clinvar_variants))`.

3. **Memoised wrappers** at the bottom of the file:
   - `fetch_gnomad_constraints_mem <- memoise::memoise(fetch_gnomad_constraints, cache = cache_static)` (30-day TTL)
   - `fetch_gnomad_clinvar_variants_mem <- memoise::memoise(fetch_gnomad_clinvar_variants, cache = cache_dynamic)` (7-day TTL)

Add roxygen2 docs. Follow Google R Style Guide. File header: `# api/functions/external-proxy-gnomad.R`.
  </action>
  <verify>
`Rscript -e "source('api/functions/external-proxy-functions.R'); source('api/functions/external-proxy-gnomad.R')"` parses without error. `cd /home/bernt-popp/development/sysndd/api && Rscript scripts/lint-check.R` passes.
  </verify>
  <done>
gnomAD proxy file exists with fetch_gnomad_constraints(), fetch_gnomad_clinvar_variants(), and their memoised _mem variants. Uses GraphQL queries with httr2 retry/throttle.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create UniProt and Ensembl proxy functions + register all sources</name>
  <files>api/functions/external-proxy-uniprot.R, api/functions/external-proxy-ensembl.R, api/start_sysndd_api.R</files>
  <action>
**File 1: `api/functions/external-proxy-uniprot.R`**

Create with:

1. **`fetch_uniprot_domains(gene_symbol)`**:
   - Validates gene_symbol with `validate_gene_symbol()`.
   - Step 1: Look up UniProt accession by gene symbol. Use UniProt REST API:
     `https://rest.uniprot.org/uniprotkb/search?query=gene_exact:{gene_symbol}+AND+organism_id:9606+AND+reviewed:true&fields=accession,protein_name,sequence&format=json&size=1`
   - Use `make_external_request()` from external-proxy-functions.R with api_name = "uniprot" and throttle = `EXTERNAL_API_THROTTLE$uniprot`.
   - If no results found, return `list(found = FALSE, source = "uniprot")`.
   - Step 2: Fetch protein features/domains using the accession:
     `https://www.ebi.ac.uk/proteins/api/features/{accession}` with header `Accept: application/json`.
   - Parse features array, filter to domain-relevant types: "DOMAIN", "REGION", "MOTIF", "REPEAT", "ZN_FING", "DNA_BIND", "BINDING", "ACT_SITE", "METAL", "SITE", "DISULFID", "CROSSLNK", "CARBOHYD", "MOD_RES", "LIPID", "SIGNAL", "TRANSIT", "CHAIN".
   - Return: `list(source = "uniprot", gene_symbol = gene_symbol, accession = accession, protein_name = protein_name, protein_length = nchar(sequence), domains = filtered_features)`.
   - Wrap in tryCatch.

2. **Memoised wrapper**:
   - `fetch_uniprot_domains_mem <- memoise::memoise(fetch_uniprot_domains, cache = cache_stable)` (14-day TTL)

**File 2: `api/functions/external-proxy-ensembl.R`**

Create with:

1. **`fetch_ensembl_gene_structure(gene_symbol)`**:
   - Validates gene_symbol.
   - Step 1: Look up Ensembl gene ID by symbol:
     `https://rest.ensembl.org/xrefs/symbol/homo_sapiens/{gene_symbol}?content-type=application/json`
   - Use `make_external_request()` with api_name = "ensembl" and throttle = `EXTERNAL_API_THROTTLE$ensembl`.
   - Find the Ensembl gene ID (type == "gene") from results.
   - If not found, return `list(found = FALSE, source = "ensembl")`.
   - Step 2: Fetch gene structure with lookup:
     `https://rest.ensembl.org/lookup/id/{gene_id}?content-type=application/json;expand=1`
   - This returns gene with nested transcripts, each containing exons.
   - Extract: gene_id, display_name, start, end, seq_region_name (chromosome), strand, biotype.
   - Extract canonical transcript (marked with `is_canonical = 1`): transcript_id, start, end, biotype, exons array (each with start, end, id).
   - Return: `list(source = "ensembl", gene_symbol = gene_symbol, gene_id = gene_id, chromosome = seq_region_name, start = start, end = end, strand = strand, canonical_transcript = list(transcript_id, start, end, biotype, exons = exons_list))`.
   - Wrap in tryCatch.

2. **Memoised wrapper**:
   - `fetch_ensembl_gene_structure_mem <- memoise::memoise(fetch_ensembl_gene_structure, cache = cache_stable)` (14-day TTL)

**Register in start_sysndd_api.R:**

Add three source lines in section 4, after the line sourcing `external-proxy-functions.R` (added in Plan 01):
```r
source("functions/external-proxy-gnomad.R", local = TRUE)
source("functions/external-proxy-uniprot.R", local = TRUE)
source("functions/external-proxy-ensembl.R", local = TRUE)
```

Add roxygen2 docs for all functions. Follow Google R Style Guide.
  </action>
  <verify>
`Rscript -e "source('api/functions/external-proxy-functions.R'); source('api/functions/external-proxy-uniprot.R'); source('api/functions/external-proxy-ensembl.R')"` parses without error. `grep "external-proxy-gnomad\|external-proxy-uniprot\|external-proxy-ensembl" api/start_sysndd_api.R` shows three source lines. Lintr passes.
  </verify>
  <done>
UniProt proxy returns protein domains with accession lookup. Ensembl proxy returns gene structure with canonical transcript exons. Both use memoised wrappers with 14-day TTL. All three source files (gnomAD, UniProt, Ensembl) registered in API startup.
  </done>
</task>

</tasks>

<verification>
1. All three proxy files parse without R syntax errors
2. Memoised wrappers use correct cache backends (static for constraints, dynamic for ClinVar, stable for domains/structure)
3. All functions validate gene_symbol input before making external calls
4. start_sysndd_api.R sources all three new files
5. Lintr passes for all new files
</verification>

<success_criteria>
- gnomAD proxy: 2 functions (constraints + ClinVar variants) with GraphQL queries
- UniProt proxy: 1 function (protein domains) with two-step lookup (symbol -> accession -> features)
- Ensembl proxy: 1 function (gene structure) with two-step lookup (symbol -> gene_id -> structure)
- All functions have memoised wrappers with per-source TTL
- All functions use shared infrastructure (make_external_request, validate_gene_symbol, throttle configs)
- All files registered in API startup
</success_criteria>

<output>
After completion, create `.planning/phases/40-backend-external-api-layer/40-02-SUMMARY.md`
</output>
