---
phase: 40-backend-external-api-layer
plan: 05
type: execute
wave: 4
depends_on: ["40-04"]
files_modified:
  - api/tests/testthat/test-external-proxy-functions.R
  - api/tests/testthat/test-external-proxy-endpoints.R
  - api/tests/testthat/helper-mock-apis.R
autonomous: true

must_haves:
  truths:
    - "Unit tests verify shared proxy infrastructure functions (validation, error format, request helper)"
    - "Unit tests verify error isolation in aggregation endpoint logic"
    - "Tests use mocked HTTP responses (no real external API calls)"
    - "All new tests pass alongside existing 634 tests"
  artifacts:
    - path: "api/tests/testthat/test-external-proxy-functions.R"
      provides: "Unit tests for external-proxy-functions.R"
      min_lines: 60
    - path: "api/tests/testthat/test-external-proxy-endpoints.R"
      provides: "Unit tests for proxy endpoint logic"
      min_lines: 80
  key_links:
    - from: "api/tests/testthat/test-external-proxy-functions.R"
      to: "api/functions/external-proxy-functions.R"
      via: "tests validate_gene_symbol, create_external_error, cache backends"
      pattern: "validate_gene_symbol|create_external_error"
    - from: "api/tests/testthat/test-external-proxy-endpoints.R"
      to: "api/endpoints/external_endpoints.R"
      via: "tests aggregation error isolation logic"
      pattern: "error.*isolation|aggregat"
---

<objective>
Write unit tests for the shared proxy infrastructure and endpoint logic, using mocked HTTP responses to avoid hitting real external APIs.

Purpose: Verify the proxy layer works correctly without depending on external API availability. Test the critical path: input validation, error formatting, cache backend creation, and error isolation in the aggregation endpoint.

Output: Two test files covering infrastructure and endpoint logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/40-backend-external-api-layer/40-CONTEXT.md
@.planning/phases/40-backend-external-api-layer/40-04-SUMMARY.md

Key existing files:
@api/tests/testthat/helper-mock-apis.R (existing mock helpers)
@api/tests/testthat/setup.R (test setup)
@api/functions/external-proxy-functions.R
@api/endpoints/external_endpoints.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unit tests for shared proxy infrastructure</name>
  <files>api/tests/testthat/test-external-proxy-functions.R</files>
  <action>
Create `api/tests/testthat/test-external-proxy-functions.R` with tests for the shared infrastructure:

1. **validate_gene_symbol() tests:**
   ```r
   describe("validate_gene_symbol", {
     it("accepts valid HGNC gene symbols", {
       expect_true(validate_gene_symbol("BRCA1"))
       expect_true(validate_gene_symbol("TP53"))
       expect_true(validate_gene_symbol("HLA-A"))
       expect_true(validate_gene_symbol("C9orf72"))
     })

     it("rejects NULL and empty strings", {
       expect_false(validate_gene_symbol(NULL))
       expect_false(validate_gene_symbol(""))
       expect_false(validate_gene_symbol(NA))
     })

     it("rejects lowercase and special characters", {
       expect_false(validate_gene_symbol("brca1"))
       expect_false(validate_gene_symbol("BRCA1; DROP TABLE"))
       expect_false(validate_gene_symbol('BRCA1"'))
       expect_false(validate_gene_symbol("BRCA1\ngene"))
     })

     it("rejects GraphQL injection attempts", {
       expect_false(validate_gene_symbol('BRCA1" } evil { "'))
       expect_false(validate_gene_symbol("BRCA1{}"))
     })
   })
   ```

2. **create_external_error() tests:**
   ```r
   describe("create_external_error", {
     it("returns RFC 9457 formatted error with source", {
       err <- create_external_error("gnomad", "API unavailable")
       expect_equal(err$type, "https://sysndd.org/problems/external-api-failure")
       expect_equal(err$source, "gnomad")
       expect_equal(err$status, 503L)
       expect_true(grepl("gnomad", err$title))
       expect_equal(err$detail, "API unavailable")
     })

     it("accepts custom status code", {
       err <- create_external_error("uniprot", "Bad request", 400L)
       expect_equal(err$status, 400L)
     })

     it("includes instance when provided", {
       err <- create_external_error("ensembl", "Timeout", instance = "/api/external/ensembl/structure/BRCA1")
       expect_equal(err$instance, "/api/external/ensembl/structure/BRCA1")
     })
   })
   ```

3. **Cache backend tests:**
   ```r
   describe("cache backends", {
     it("cache_static exists and is a cachem cache object", {
       expect_true(!is.null(cache_static))
       expect_true(inherits(cache_static, "cache_disk") || is.environment(cache_static))
     })

     it("cache_stable exists and is a cachem cache object", {
       expect_true(!is.null(cache_stable))
     })

     it("cache_dynamic exists and is a cachem cache object", {
       expect_true(!is.null(cache_dynamic))
     })
   })
   ```

4. **EXTERNAL_API_THROTTLE config tests:**
   ```r
   describe("EXTERNAL_API_THROTTLE", {
     it("contains all 6 API configurations", {
       expect_true(all(c("gnomad", "ensembl", "uniprot", "alphafold", "mgi", "rgd") %in%
         names(EXTERNAL_API_THROTTLE)))
     })

     it("each config has capacity and fill_time_s", {
       for (api_name in names(EXTERNAL_API_THROTTLE)) {
         config <- EXTERNAL_API_THROTTLE[[api_name]]
         expect_true("capacity" %in% names(config), info = paste(api_name, "missing capacity"))
         expect_true("fill_time_s" %in% names(config), info = paste(api_name, "missing fill_time_s"))
       }
     })

     it("gnomAD has conservative rate limit (10/min)", {
       expect_equal(EXTERNAL_API_THROTTLE$gnomad$capacity, 10)
       expect_equal(EXTERNAL_API_THROTTLE$gnomad$fill_time_s, 60)
     })
   })
   ```

Make sure the test file sources the required functions at the top if needed, or relies on the test setup.R for loading. Check the existing test setup to understand how test files load project code.
  </action>
  <verify>
`cd /home/bernt-popp/development/sysndd/api && Rscript -e "testthat::test_file('tests/testthat/test-external-proxy-functions.R')"` runs and passes.
  </verify>
  <done>
Unit tests for validate_gene_symbol (valid symbols, injection, edge cases), create_external_error (RFC 9457 format, source field), cache backends (existence), and throttle config (all 6 APIs) all pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create tests for proxy endpoint logic and error isolation</name>
  <files>api/tests/testthat/test-external-proxy-endpoints.R, api/tests/testthat/helper-mock-apis.R</files>
  <action>
**Update `api/tests/testthat/helper-mock-apis.R`** to add mock helpers for external proxy testing:

Add mock functions that simulate external API responses without making real HTTP calls:

```r
# Mock for a successful gnomAD constraint response
mock_gnomad_constraints_success <- function(symbol) {
  list(
    source = "gnomad",
    gene_symbol = symbol,
    gene_id = "ENSG00000012048",
    constraints = list(
      pLI = 0.0,
      oe_lof = 0.48,
      oe_lof_upper = 0.61,
      mis_z = 2.55,
      exp_lof = 52.1,
      obs_lof = 25
    )
  )
}

# Mock for a "not found" response
mock_source_not_found <- function(source_name) {
  list(found = FALSE, source = source_name)
}

# Mock for an error response
mock_source_error <- function(source_name) {
  list(error = TRUE, source = source_name, message = paste(source_name, "unavailable"))
}
```

**Create `api/tests/testthat/test-external-proxy-endpoints.R`:**

Test the aggregation logic (the loop + error isolation pattern). Since we can't easily spin up a Plumber server in tests, test the aggregation logic as a standalone function.

Extract the aggregation logic into a testable helper or test the pattern directly:

```r
describe("aggregation error isolation", {
  it("returns partial data when some sources fail", {
    # Simulate the aggregation logic
    sources <- list(
      gnomad = function() mock_gnomad_constraints_success("BRCA1"),
      uniprot = function() stop("UniProt timeout"),
      ensembl = function() mock_source_not_found("ensembl")
    )

    results <- list(sources = list(), errors = list())

    for (source_name in names(sources)) {
      result <- tryCatch({
        sources[[source_name]]()
      }, error = function(e) {
        list(error = TRUE, source = source_name, message = conditionMessage(e))
      })

      if (is.list(result) && isTRUE(result$error)) {
        results$errors[[source_name]] <- create_external_error(
          source_name, result$message
        )
      } else if (is.list(result) && isTRUE(result$found == FALSE)) {
        results$sources[[source_name]] <- list(found = FALSE)
      } else {
        results$sources[[source_name]] <- result
      }
    }

    # gnomAD succeeded, ensembl returned not-found, uniprot errored
    expect_equal(length(results$sources), 2)  # gnomad + ensembl (not found)
    expect_equal(length(results$errors), 1)   # uniprot
    expect_equal(results$errors$uniprot$source, "uniprot")
    expect_equal(results$sources$gnomad$source, "gnomad")
  })

  it("returns 503 structure when ALL sources fail", {
    sources <- list(
      gnomad = function() stop("gnomAD down"),
      uniprot = function() stop("UniProt down")
    )

    results <- list(sources = list(), errors = list())

    for (source_name in names(sources)) {
      result <- tryCatch({
        sources[[source_name]]()
      }, error = function(e) {
        list(error = TRUE, source = source_name, message = conditionMessage(e))
      })

      if (is.list(result) && isTRUE(result$error)) {
        results$errors[[source_name]] <- create_external_error(
          source_name, result$message
        )
      } else {
        results$sources[[source_name]] <- result
      }
    }

    # All failed - no sources, only errors
    expect_equal(length(results$sources), 0)
    expect_equal(length(results$errors), 2)
  })

  it("handles mixed success, not-found, and error gracefully", {
    sources <- list(
      gnomad = function() mock_gnomad_constraints_success("SHANK3"),
      uniprot = function() mock_source_not_found("uniprot"),
      alphafold = function() mock_source_error("alphafold"),
      mgi = function() stop("Network error"),
      rgd = function() mock_source_not_found("rgd")
    )

    results <- list(sources = list(), errors = list())

    for (source_name in names(sources)) {
      result <- tryCatch({
        sources[[source_name]]()
      }, error = function(e) {
        list(error = TRUE, source = source_name, message = conditionMessage(e))
      })

      if (is.list(result) && isTRUE(result$error)) {
        results$errors[[source_name]] <- create_external_error(
          source_name, result$message %||% "unavailable"
        )
      } else if (is.list(result) && isTRUE(result$found == FALSE)) {
        results$sources[[source_name]] <- list(found = FALSE)
      } else {
        results$sources[[source_name]] <- result
      }
    }

    # 1 success (gnomad) + 2 not-found (uniprot, rgd) = 3 in sources
    # 2 errors (alphafold returned error list, mgi threw exception)
    expect_equal(length(results$sources), 3)
    expect_equal(length(results$errors), 2)
    expect_true("alphafold" %in% names(results$errors))
    expect_true("mgi" %in% names(results$errors))
  })
})
```

Also test the AUTH_ALLOWLIST update:

```r
describe("AUTH_ALLOWLIST includes external endpoints", {
  it("contains external proxy paths", {
    expect_true("/api/external/gene" %in% AUTH_ALLOWLIST)
    expect_true("/api/external/gnomad/constraints" %in% AUTH_ALLOWLIST)
    expect_true("/api/external/gnomad/variants" %in% AUTH_ALLOWLIST)
    expect_true("/api/external/uniprot/domains" %in% AUTH_ALLOWLIST)
    expect_true("/api/external/ensembl/structure" %in% AUTH_ALLOWLIST)
    expect_true("/api/external/alphafold/structure" %in% AUTH_ALLOWLIST)
    expect_true("/api/external/mgi/phenotypes" %in% AUTH_ALLOWLIST)
    expect_true("/api/external/rgd/phenotypes" %in% AUTH_ALLOWLIST)
  })
})
```

Use `%||%` from rlang. Ensure tests source the required infrastructure file at the top if the test setup doesn't already load it.
  </action>
  <verify>
`cd /home/bernt-popp/development/sysndd/api && Rscript -e "testthat::test_file('tests/testthat/test-external-proxy-endpoints.R')"` runs and passes. `cd /home/bernt-popp/development/sysndd/api && Rscript -e "testthat::test_dir('tests/testthat')"` runs all tests including existing 634, all pass.
  </verify>
  <done>
Tests verify: (1) error isolation returns partial data when some sources fail, (2) all-fail case returns 503 structure, (3) mixed success/not-found/error handled gracefully, (4) AUTH_ALLOWLIST contains all external paths. All new tests pass alongside existing test suite.
  </done>
</task>

</tasks>

<verification>
1. `test-external-proxy-functions.R` tests pass (validate_gene_symbol, create_external_error, cache backends, throttle config)
2. `test-external-proxy-endpoints.R` tests pass (error isolation, aggregation logic, AUTH_ALLOWLIST)
3. Full test suite runs without regressions (`testthat::test_dir` passes)
4. No real external API calls in tests (all mocked)
5. Tests are fast (< 30 seconds total)
</verification>

<success_criteria>
- Infrastructure tests: validate_gene_symbol (6+ test cases including injection), create_external_error (RFC 9457 format), cache backends (existence), throttle config (6 APIs)
- Endpoint logic tests: partial data on some failures, 503 on all failures, mixed scenarios
- AUTH_ALLOWLIST tests: all 8 external paths present
- All tests pass alongside existing 634 tests
- No network calls in tests
</success_criteria>

<output>
After completion, create `.planning/phases/40-backend-external-api-layer/40-05-SUMMARY.md`
</output>
