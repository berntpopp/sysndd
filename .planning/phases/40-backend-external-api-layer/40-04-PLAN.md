---
phase: 40-backend-external-api-layer
plan: 04
type: execute
wave: 3
depends_on: ["40-02", "40-03"]
files_modified:
  - api/endpoints/external_endpoints.R
  - api/core/middleware.R
autonomous: true

must_haves:
  truths:
    - "Individual proxy endpoints return data for each source at /api/external/{source}/{type}/{symbol}"
    - "Combined aggregation endpoint at /api/external/gene/{symbol} returns all sources with error isolation"
    - "When one external API fails, other sources still return data in aggregation response"
    - "All external proxy endpoints are publicly accessible without authentication"
    - "Error responses follow RFC 9457 format with source identification"
  artifacts:
    - path: "api/endpoints/external_endpoints.R"
      provides: "8 Plumber endpoints: 7 per-source + 1 aggregation"
      min_lines: 150
    - path: "api/core/middleware.R"
      provides: "AUTH_ALLOWLIST with external endpoint paths"
  key_links:
    - from: "api/endpoints/external_endpoints.R"
      to: "external-proxy-gnomad.R"
      via: "calls fetch_gnomad_constraints_mem and fetch_gnomad_clinvar_variants_mem"
      pattern: "fetch_gnomad_constraints_mem|fetch_gnomad_clinvar_variants_mem"
    - from: "api/endpoints/external_endpoints.R"
      to: "external-proxy-uniprot.R"
      via: "calls fetch_uniprot_domains_mem"
      pattern: "fetch_uniprot_domains_mem"
    - from: "api/endpoints/external_endpoints.R"
      to: "external-proxy-ensembl.R"
      via: "calls fetch_ensembl_gene_structure_mem"
      pattern: "fetch_ensembl_gene_structure_mem"
    - from: "api/core/middleware.R"
      to: "api/endpoints/external_endpoints.R"
      via: "AUTH_ALLOWLIST entries for /api/external/ paths"
      pattern: "/api/external/"
---

<objective>
Create all Plumber proxy endpoints (7 per-source + 1 aggregation), add them to AUTH_ALLOWLIST for public access, and implement error isolation in the combined endpoint.

Purpose: This exposes all external proxy functions as HTTP endpoints that the frontend will consume. The aggregation endpoint is the primary interface for the gene page (single request for all sources).

Output: Extended external_endpoints.R with 8 new endpoints, updated middleware.R with public access paths.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/40-backend-external-api-layer/40-CONTEXT.md
@.planning/phases/40-backend-external-api-layer/40-RESEARCH.md
@.planning/phases/40-backend-external-api-layer/40-02-SUMMARY.md
@.planning/phases/40-backend-external-api-layer/40-03-SUMMARY.md

Key existing files:
@api/endpoints/external_endpoints.R (existing file with internet_archive endpoint)
@api/core/middleware.R (AUTH_ALLOWLIST definition)
@api/core/errors.R (RFC 9457 error helpers)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add per-source proxy endpoints to external_endpoints.R</name>
  <files>api/endpoints/external_endpoints.R</files>
  <action>
Extend the existing `api/endpoints/external_endpoints.R` file. Keep the existing internet_archive endpoint. Add the following 7 per-source endpoints below the existing code:

1. **`GET gnomad/constraints/<symbol>`** (PROXY-01):
   ```r
   #* Get gnomAD constraint scores for a gene
   #*
   #* Returns pLI, LOEUF, mis_z and other constraint metrics from gnomAD v4.
   #* Data is cached for 30 days.
   #*
   #* @tag external-proxy
   #* @serializer unboxedJSON
   #* @param symbol Gene symbol (e.g., "BRCA1")
   #* @response 200 Constraint scores for the gene
   #* @response 400 Invalid gene symbol
   #* @response 404 Gene not found in gnomAD
   #* @response 503 gnomAD API unavailable
   #* @get gnomad/constraints/<symbol>
   ```
   - Validate symbol with `validate_gene_symbol()`. If invalid, return 400 with `create_external_error("gnomad", "Invalid gene symbol", 400L, ...)`.
   - Call `fetch_gnomad_constraints_mem(symbol)`.
   - Check result: if `$found == FALSE`, return 404. If `$error == TRUE`, return 503 with `create_external_error()`.
   - On success, return result directly.

2. **`GET gnomad/variants/<symbol>`** (PROXY-01 ClinVar part):
   - Same pattern as above but calls `fetch_gnomad_clinvar_variants_mem(symbol)`.
   - Tag: external-proxy. Serializer: unboxedJSON.

3. **`GET uniprot/domains/<symbol>`** (PROXY-02):
   - Calls `fetch_uniprot_domains_mem(symbol)`.
   - Same validation, error handling, RFC 9457 pattern.

4. **`GET ensembl/structure/<symbol>`** (PROXY-03):
   - Calls `fetch_ensembl_gene_structure_mem(symbol)`.
   - Same pattern.

5. **`GET alphafold/structure/<symbol>`** (PROXY-04):
   - Calls `fetch_alphafold_structure_mem(symbol)`.
   - Same pattern.

6. **`GET mgi/phenotypes/<symbol>`** (PROXY-05):
   - Calls `fetch_mgi_phenotypes_mem(symbol)`.
   - Same pattern.

7. **`GET rgd/phenotypes/<symbol>`** (PROXY-06):
   - Calls `fetch_rgd_phenotypes_mem(symbol)`.
   - Same pattern.

**For each endpoint, follow this pattern:**

```r
function(symbol, res) {
  # Validate input
  if (!validate_gene_symbol(symbol)) {
    res$status <- 400L
    res$setHeader("Content-Type", "application/problem+json")
    return(create_external_error(
      "{api_name}",
      sprintf("Invalid gene symbol: %s", symbol),
      400L,
      paste0("/api/external/{path}/", symbol)
    ))
  }

  # Fetch data (memoised)
  result <- fetch_{source}_mem(symbol)

  # Handle not found
  if (is.list(result) && isTRUE(result$found == FALSE)) {
    res$status <- 404L
    res$setHeader("Content-Type", "application/problem+json")
    return(create_external_error(
      "{api_name}",
      sprintf("Gene %s not found in {source}", symbol),
      404L,
      paste0("/api/external/{path}/", symbol)
    ))
  }

  # Handle error
  if (is.list(result) && isTRUE(result$error)) {
    res$status <- 503L
    res$setHeader("Content-Type", "application/problem+json")
    return(create_external_error(
      "{api_name}",
      result$message %||% "External API unavailable",
      503L,
      paste0("/api/external/{path}/", symbol)
    ))
  }

  # Success
  return(result)
}
```

Use `%||%` from rlang (already loaded in project). Add full roxygen2 docs. Use `@tag external-proxy` and `@serializer unboxedJSON` for all endpoints.
  </action>
  <verify>
`grep -c "@get" api/endpoints/external_endpoints.R` returns 8 (1 existing + 7 new). `grep "gnomad/constraints\|gnomad/variants\|uniprot/domains\|ensembl/structure\|alphafold/structure\|mgi/phenotypes\|rgd/phenotypes" api/endpoints/external_endpoints.R | wc -l` returns 7. Lintr passes.
  </verify>
  <done>
Seven per-source proxy endpoints exist in external_endpoints.R, each with input validation, RFC 9457 error responses, and memoised function calls.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add aggregation endpoint and update AUTH_ALLOWLIST</name>
  <files>api/endpoints/external_endpoints.R, api/core/middleware.R</files>
  <action>
**Add aggregation endpoint to `api/endpoints/external_endpoints.R`** (PROXY-07):

Add the combined endpoint at the end of the file:

```r
#* Get all external genomic data for a gene
#*
#* Aggregates data from all external sources (gnomAD, UniProt, Ensembl,
#* AlphaFold, MGI, RGD) in a single request. Uses error isolation so one
#* failing source does not block others. Returns 200 with partial data if
#* at least one source succeeds. Returns 503 only if ALL sources fail.
#*
#* @tag external-proxy
#* @serializer unboxedJSON
#* @param symbol Gene symbol (e.g., "BRCA1")
#* @response 200 Aggregated data from available sources
#* @response 400 Invalid gene symbol
#* @response 503 All external sources unavailable
#* @get gene/<symbol>
```

Implementation:
- Validate symbol. If invalid, return 400.
- Define source fetch functions as named list:
  ```r
  sources <- list(
    gnomad_constraints = function() fetch_gnomad_constraints_mem(symbol),
    gnomad_clinvar = function() fetch_gnomad_clinvar_variants_mem(symbol),
    uniprot = function() fetch_uniprot_domains_mem(symbol),
    ensembl = function() fetch_ensembl_gene_structure_mem(symbol),
    alphafold = function() fetch_alphafold_structure_mem(symbol),
    mgi = function() fetch_mgi_phenotypes_mem(symbol),
    rgd = function() fetch_rgd_phenotypes_mem(symbol)
  )
  ```
- Initialize result structure:
  ```r
  results <- list(
    gene_symbol = symbol,
    sources = list(),
    errors = list(),
    timestamp = format(Sys.time(), "%Y-%m-%dT%H:%M:%SZ")
  )
  ```
- Loop through sources with error isolation (tryCatch per source):
  ```r
  for (source_name in names(sources)) {
    result <- tryCatch({
      sources[[source_name]]()
    }, error = function(e) {
      list(error = TRUE, source = source_name, message = conditionMessage(e))
    })

    if (is.list(result) && isTRUE(result$error)) {
      results$errors[[source_name]] <- create_external_error(
        source_name,
        result$message %||% paste(source_name, "unavailable"),
        503L,
        paste0("/api/external/gene/", symbol)
      )
    } else if (is.list(result) && isTRUE(result$found == FALSE)) {
      # Gene not found in this source - not an error, just no data
      results$sources[[source_name]] <- list(found = FALSE)
    } else {
      results$sources[[source_name]] <- result
    }
  }
  ```
- Return logic:
  - If ALL sources failed (length(results$sources) == 0 AND all were errors, not "not found"):
    ```r
    if (length(results$sources) == 0 && length(results$errors) > 0) {
      res$status <- 503L
      res$setHeader("Content-Type", "application/problem+json")
      return(list(
        type = "https://sysndd.org/problems/all-sources-failed",
        title = "All external data sources unavailable",
        status = 503L,
        detail = sprintf("Failed to retrieve data for gene %s from any source", symbol),
        errors = results$errors
      ))
    }
    ```
  - Otherwise return 200 with partial data:
    ```r
    return(results)
    ```

**Update `api/core/middleware.R`** (PROXY-11):

Add external proxy endpoints to AUTH_ALLOWLIST array. Insert after the existing entries (before the closing parenthesis):

```r
# External API proxy endpoints (public read access to public genomic data)
"/api/external/gnomad/constraints",
"/api/external/gnomad/variants",
"/api/external/uniprot/domains",
"/api/external/ensembl/structure",
"/api/external/alphafold/structure",
"/api/external/mgi/phenotypes",
"/api/external/rgd/phenotypes",
"/api/external/gene"
```

IMPORTANT: Note that the middleware checks `req$PATH_INFO %in% AUTH_ALLOWLIST`. Since Plumber path params are dynamic (e.g., `/api/external/gnomad/constraints/BRCA1`), the exact path won't match. However, looking at the existing code on line 77, GET requests without auth already get public read access (`req$REQUEST_METHOD == "GET" && is.null(req$HTTP_AUTHORIZATION)` returns forward). So external proxy endpoints (all GET) are ALREADY publicly accessible by the existing middleware logic.

Still add the paths to AUTH_ALLOWLIST for documentation purposes and in case the middleware logic changes. But add a comment noting that GET endpoints are already public by default per the existing middleware flow.
  </action>
  <verify>
`grep "gene/<symbol>" api/endpoints/external_endpoints.R` returns the aggregation endpoint. `grep -c "external" api/core/middleware.R` shows the new allowlist entries. `grep "all-sources-failed" api/endpoints/external_endpoints.R` confirms error isolation logic exists. Lintr passes on both files.
  </verify>
  <done>
Aggregation endpoint returns data from all 7 sources with error isolation (tryCatch per source). AUTH_ALLOWLIST updated with all external proxy paths. RFC 9457 errors include source identification. Partial data returned when some sources fail.
  </done>
</task>

</tasks>

<verification>
1. Total of 8 endpoints in external_endpoints.R (1 legacy + 7 per-source + 1 aggregation)
2. Aggregation endpoint uses tryCatch per source (error isolation)
3. Aggregation returns 200 with partial data when some sources fail
4. Aggregation returns 503 only when ALL sources fail
5. All error responses include "source" field for frontend identification
6. AUTH_ALLOWLIST contains all external endpoint paths
7. All endpoints validate gene_symbol input before calling proxy functions
8. Lintr passes on both modified files
</verification>

<success_criteria>
- 7 per-source endpoints expose proxy functions with consistent validation and error format
- 1 aggregation endpoint fetches all sources with error isolation
- AUTH_ALLOWLIST includes external endpoint paths
- Error isolation: one failing source never blocks others
- RFC 9457 error responses include source identification
- All code passes lintr
</success_criteria>

<output>
After completion, create `.planning/phases/40-backend-external-api-layer/40-04-SUMMARY.md`
</output>
