---
phase: 09-developer-experience
plan: 03
type: execute
wave: 2
depends_on: ["09-01", "09-02"]
files_modified:
  - docker-compose.dev.yml
autonomous: false

must_haves:
  truths:
    - "docker compose watch starts and syncs file changes"
    - "Editing app/src/*.vue triggers hot module reload in browser"
    - "Editing api/endpoints/*.R syncs to container"
    - "Full stack starts with cp .env.example .env && docker compose up"
  artifacts:
    - path: "docker-compose.dev.yml"
      provides: "Updated hybrid development compose with watch hints"
      min_lines: 50
      contains: "mysql-dev"
  key_links:
    - from: "docker compose watch"
      to: "docker-compose.override.yml"
      via: "merges develop.watch configurations"
      pattern: "develop:"
---

<objective>
Verify end-to-end development workflow with Docker Compose Watch: test hot-reload for both frontend and API, update docker-compose.dev.yml documentation, and validate new developer onboarding experience.

Purpose: Ensure the complete developer experience workflow is functional and documented.
Output: Verified hot-reload workflow, updated docker-compose.dev.yml, human verification of browser hot module reload
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-developer-experience/09-RESEARCH.md
@.planning/phases/09-developer-experience/09-01-SUMMARY.md
@.planning/phases/09-developer-experience/09-02-SUMMARY.md

@docker-compose.yml
@docker-compose.override.yml
@docker-compose.dev.yml
@app/Dockerfile.dev
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update docker-compose.dev.yml header documentation</name>
  <files>docker-compose.dev.yml</files>
  <action>
Update the header comment in docker-compose.dev.yml to clarify its purpose now that docker-compose.override.yml exists.

Current purpose: Hybrid development (database in Docker, API runs locally)
Keep this purpose - it's different from the full-stack Docker workflow.

Update header to explain:
```yaml
# =============================================================================
# Hybrid Development Database Containers
# =============================================================================
# Usage: docker compose -f docker-compose.dev.yml up -d
#
# Purpose: Run databases in Docker while developing API locally (not in container).
# This is for LOCAL R/Plumber development with IDE debugger access.
#
# Ports:
#   - mysql-dev: localhost:7654 (development database)
#   - mysql-test: localhost:7655 (test database for R testthat)
#
# Alternative workflows:
#   - Full-stack Docker: docker compose up --watch (uses docker-compose.override.yml)
#   - Production: docker compose -f docker-compose.yml up
#
# Note: This file requires explicit -f flag (not auto-loaded like override.yml)
# =============================================================================
```

Also update the mysql command from deprecated --default-authentication-plugin to caching_sha2_password to match docker-compose.yml:
```yaml
command:
  - --authentication-policy=caching_sha2_password
  - --character-set-server=utf8mb4
  - --collation-server=utf8mb4_unicode_ci
```
  </action>
  <verify>
Check header documentation updated:
```bash
head -20 docker-compose.dev.yml | grep -q "Full-stack Docker" && echo "Documentation updated"
```
Check mysql command updated:
```bash
grep "authentication-policy=caching_sha2_password" docker-compose.dev.yml
```
  </verify>
  <done>docker-compose.dev.yml has updated header explaining hybrid vs full-stack workflows, mysql uses caching_sha2_password</done>
</task>

<task type="auto">
  <name>Task 2: Build and start development stack</name>
  <files>None (verification only)</files>
  <action>
Build and start the full development stack to verify configuration is correct.

Steps:
1. Build app with Dockerfile.dev:
   ```bash
   docker compose build app
   ```

2. Start all services in detached mode:
   ```bash
   docker compose up -d
   ```

3. Wait for services to be healthy:
   ```bash
   docker compose ps
   ```

4. Check logs for any errors:
   ```bash
   docker compose logs --tail=20 app api
   ```

If build fails, check:
- app/Dockerfile.dev exists and has valid syntax
- docker-compose.override.yml references correct dockerfile
- Volume mount paths are correct

Do NOT leave services running after verification - stop them after task 3.
  </action>
  <verify>
Check services are running:
```bash
docker compose ps | grep -E "sysndd_(app|api|mysql)" | grep -v "Exit"
```
Check app is using dev server:
```bash
docker compose logs app 2>&1 | head -20 | grep -E "webpack|serve|compiled"
```
  </verify>
  <done>Development stack builds and starts successfully with app using webpack-dev-server</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Docker development workflow with hot-reload:
- app/Dockerfile.dev for Vue.js development server
- docker-compose.override.yml for auto-loaded dev config
- Compose Watch configuration for file synchronization
- MySQL accessible at localhost:7654
- .env.example for new developer onboarding
  </what-built>
  <how-to-verify>
**Test 1: New Developer Onboarding**
1. Verify .env.example exists and is readable:
   ```bash
   cat .env.example
   ```
2. Confirm instructions are clear for: `cp .env.example .env && docker compose up`

**Test 2: Full Stack Startup**
1. Start with watch mode:
   ```bash
   docker compose up --watch
   ```
2. Wait for all services to be healthy (1-2 minutes)
3. Open browser to http://localhost (Traefik routes to app)

**Test 3: Frontend Hot Reload** (CRITICAL)
1. With `docker compose up --watch` running
2. Edit a visible file, e.g., app/src/App.vue or a component
3. Add a visible change (text, style)
4. Check browser - should update within 2 seconds WITHOUT manual refresh
5. Check terminal for "Syncing" message from Compose Watch

**Test 4: API Sync**
1. Edit api/endpoints/endpoint_hello_world.R or similar
2. Check terminal for "Syncing" message
3. Note: R Plumber requires manual restart to pick up changes:
   ```bash
   docker compose restart api
   ```
4. Verify API responds with changes at http://localhost/api/hello/

**Test 5: Database Access**
1. Connect database tool (DBeaver, MySQL Workbench, etc.) to:
   - Host: localhost (or 127.0.0.1)
   - Port: 7654
   - User: from your .env MYSQL_USER
   - Password: from your .env MYSQL_PASSWORD
2. Verify connection succeeds and you can browse tables

**After verification:**
```bash
docker compose down
```
  </how-to-verify>
  <resume-signal>
Type "approved" if all tests pass, or describe any issues encountered:
- Hot reload not working? Check webpack-dev-server logs
- Services not starting? Check docker compose logs
- Database connection failed? Verify port 7654 is not in use
  </resume-signal>
</task>

</tasks>

<verification>
Phase 9 success criteria:
1. `docker compose watch` starts and syncs file changes without container rebuild
2. Editing app/src/*.vue triggers hot module reload in browser within 2 seconds
3. Editing api/endpoints/*.R syncs to container (restart needed for R changes)
4. MySQL accessible at localhost:7654 for local database tools
5. New developer can start full stack with `cp .env.example .env && docker compose up`
</verification>

<success_criteria>
1. Full development stack starts with single command
2. Frontend hot reload works (verified by human)
3. API file sync works (verified by Compose Watch output)
4. Database tools can connect to localhost:7654
5. docker-compose.dev.yml documentation clarifies hybrid vs full-stack workflows
</success_criteria>

<output>
After completion, create `.planning/phases/09-developer-experience/09-03-SUMMARY.md`
</output>
