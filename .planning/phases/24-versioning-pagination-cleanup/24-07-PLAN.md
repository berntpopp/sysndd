---
phase: 24-versioning-pagination-cleanup
plan: 07
type: execute
wave: 4
depends_on: ["24-05", "24-06"]
files_modified:
  - api/tests/testthat/test-integration-version.R
  - api/tests/testthat/test-integration-pagination.R
  - api/tests/testthat/test-integration-async.R
  - api/tests/testthat/test-unit-password-migration.R
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Integration test verifies /api/version returns correct structure"
    - "Integration test verifies pagination works on refactored endpoints"
    - "Unit test verifies password migration (plaintext to Argon2id)"
    - "Async operation test verifies job submission and status polling"
    - "All tests pass with testthat"
  artifacts:
    - path: "api/tests/testthat/test-integration-version.R"
      provides: "Version endpoint integration test"
      contains: "test_that.*version"
    - path: "api/tests/testthat/test-integration-pagination.R"
      provides: "Pagination integration tests"
      contains: "test_that.*pagination"
    - path: "api/tests/testthat/test-unit-password-migration.R"
      provides: "Password migration unit tests"
      contains: "test_that.*password"
  key_links:
    - from: "api/tests/testthat/test-integration-version.R"
      to: "api/endpoints/version_endpoints.R"
      via: "HTTP request"
      pattern: "httr2.*request"
---

<objective>
Create integration tests for new features and password migration tests

Purpose: Ensure refactored endpoints work correctly (TEST-03, TEST-04, TEST-05)
Output: Passing integration tests for version, pagination, async operations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-versioning-pagination-cleanup/24-RESEARCH.md
@.planning/phases/24-versioning-pagination-cleanup/24-01-SUMMARY.md

# Existing test structure
@api/tests/testthat/ (test helpers and existing tests)

# httr2 usage pattern from research
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create version endpoint integration test</name>
  <files>api/tests/testthat/test-integration-version.R</files>
  <action>
Create test-integration-version.R using httr2:

```r
# api/tests/testthat/test-integration-version.R
# Integration tests for /api/version endpoint

library(testthat)
library(httr2)

# Skip if API not running (CI/local flexibility)
skip_if_not <- function() {
  tryCatch({
    request("http://localhost:8000/health") %>%
      req_timeout(2) %>%
      req_perform()
    TRUE
  }, error = function(e) FALSE)
}

test_that("version endpoint returns correct structure", {
  skip_if(!skip_if_not(), "API not running")

  resp <- request("http://localhost:8000/api/version") %>%
    req_perform()

  expect_equal(resp_status(resp), 200)

  body <- resp_body_json(resp)

  # Verify required fields

  expect_true("version" %in% names(body))
  expect_true("commit" %in% names(body))
  expect_true("title" %in% names(body))
  expect_true("description" %in% names(body))

  # Verify version format (semantic versioning)
  expect_match(body$version, "^\\d+\\.\\d+\\.\\d+$")

  # Verify commit is not empty (may be "unknown" in some envs)
  expect_true(nchar(body$commit) > 0)
})

test_that("version endpoint does not require authentication", {
  skip_if(!skip_if_not(), "API not running")

  # Request without Authorization header
  resp <- request("http://localhost:8000/api/version") %>%
    req_perform()

  expect_equal(resp_status(resp), 200)
})
```
  </action>
  <verify>
File exists: api/tests/testthat/test-integration-version.R
Contains: test_that, httr2, version
  </verify>
  <done>Version endpoint integration test created</done>
</task>

<task type="auto">
  <name>Task 2: Create pagination integration tests</name>
  <files>api/tests/testthat/test-integration-pagination.R</files>
  <action>
Create test-integration-pagination.R:

```r
# api/tests/testthat/test-integration-pagination.R
# Integration tests for cursor-based pagination

library(testthat)
library(httr2)

skip_if_not_running <- function() {
  tryCatch({
    request("http://localhost:8000/health") %>%
      req_timeout(2) %>%
      req_perform()
    TRUE
  }, error = function(e) FALSE)
}

test_that("entity endpoint returns pagination structure", {
  skip_if(!skip_if_not_running(), "API not running")

  resp <- request("http://localhost:8000/api/entity") %>%
    req_url_query(page_size = 5) %>%
    req_perform()

  expect_equal(resp_status(resp), 200)

  body <- resp_body_json(resp)

  # Verify pagination structure
  expect_true("links" %in% names(body))
  expect_true("meta" %in% names(body))
  expect_true("data" %in% names(body))

  # Verify meta fields
  expect_equal(body$meta$perPage, 5)
})

test_that("pagination respects max page_size limit", {
  skip_if(!skip_if_not_running(), "API not running")

  # Request with page_size > max (500)
  resp <- request("http://localhost:8000/api/entity") %>%
    req_url_query(page_size = 1000) %>%
    req_perform()

  body <- resp_body_json(resp)

  # Should be capped at 500
  expect_lte(body$meta$perPage, 500)
})

test_that("pagination cursor navigation works", {
  skip_if(!skip_if_not_running(), "API not running")

  # Get first page
  resp1 <- request("http://localhost:8000/api/entity") %>%
    req_url_query(page_size = 2, page_after = 0) %>%
    req_perform()

  body1 <- resp_body_json(resp1)

  # Skip if not enough data for multiple pages
  skip_if(body1$links$`next` == "null", "Not enough data for pagination test")

  # Get next page using cursor
  next_link <- body1$links$`next`
  # Extract page_after from next link
  page_after <- as.integer(gsub(".*page_after=(\\d+).*", "\\1", next_link))

  resp2 <- request("http://localhost:8000/api/entity") %>%
    req_url_query(page_size = 2, page_after = page_after) %>%
    req_perform()

  body2 <- resp_body_json(resp2)

  # Verify different data returned
  expect_false(identical(body1$data, body2$data))
})
```
  </action>
  <verify>
File exists: api/tests/testthat/test-integration-pagination.R
Contains: test_that, pagination, page_size
  </verify>
  <done>Pagination integration tests created</done>
</task>

<task type="auto">
  <name>Task 3: Create password migration and async tests</name>
  <files>api/tests/testthat/test-unit-password-migration.R, api/tests/testthat/test-integration-async.R</files>
  <action>
1. Create test-unit-password-migration.R:

```r
# api/tests/testthat/test-unit-password-migration.R
# Unit tests for password migration (plaintext to Argon2id)

library(testthat)
library(sodium)

# Source security module
source("../../core/security.R")

test_that("Argon2id hash is created correctly", {
  password <- "test_password_123"
  hash <- hash_password(password)

  # Sodium creates $7$ hashes
  expect_true(grepl("^\\$7\\$", hash))
  expect_true(nchar(hash) > 50)
})

test_that("Argon2id hash verification works", {
  password <- "test_password_123"
  hash <- hash_password(password)

  expect_true(verify_password(password, hash))
  expect_false(verify_password("wrong_password", hash))
})

test_that("Legacy plaintext detection works", {
  # Argon2id hash (starts with $7$)
  argon_hash <- "$7$C6....."

  expect_true(is_argon2_hash(argon_hash))
  expect_false(is_argon2_hash("plaintext_password"))
  expect_false(is_argon2_hash(""))
})

test_that("verify_password handles both formats", {
  password <- "test_password"

  # Argon2id hash
  argon_hash <- hash_password(password)
  expect_true(verify_password(password, argon_hash))

  # Plaintext (legacy) - should match exactly
  expect_true(verify_password(password, password))
})
```

2. Create test-integration-async.R:

```r
# api/tests/testthat/test-integration-async.R
# Integration tests for async operations

library(testthat)
library(httr2)

skip_if_not_running <- function() {
  tryCatch({
    request("http://localhost:8000/health") %>%
      req_timeout(2) %>%
      req_perform()
    TRUE
  }, error = function(e) FALSE)
}

test_that("async clustering returns 202 with job_id", {
  skip_if(!skip_if_not_running(), "API not running")
  skip("Requires authentication - manual test")

  # This test requires valid JWT - skip in automated runs
  # Manual verification: POST to /api/jobs/clustering/submit
})

test_that("job status endpoint returns valid status", {
  skip_if(!skip_if_not_running(), "API not running")

  # Test with non-existent job (should return 404)
  resp <- request("http://localhost:8000/api/jobs/status/nonexistent-job-id") %>%
    req_error(is_error = ~ FALSE) %>%
    req_perform()

  expect_equal(resp_status(resp), 404)
})
```
  </action>
  <verify>
Files exist: test-unit-password-migration.R, test-integration-async.R
  </verify>
  <done>Password migration and async tests created</done>
</task>

</tasks>

<verification>
- [ ] test-integration-version.R passes when API running
- [ ] test-integration-pagination.R passes when API running
- [ ] test-unit-password-migration.R passes (unit tests, no API needed)
- [ ] test-integration-async.R documents async behavior
- [ ] All tests skippable when API not running (CI flexibility)
- [ ] Run: Rscript -e "testthat::test_dir('tests/testthat')"
</verification>

<success_criteria>
TEST-03: API integration tests pass for all refactored endpoints
TEST-04: Async operation tests (job submission, status polling)
TEST-05: Password migration tests (plaintext to Argon2id verification)
</success_criteria>

<output>
After completion, create `.planning/phases/24-versioning-pagination-cleanup/24-07-SUMMARY.md`
</output>
