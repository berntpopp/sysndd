---
phase: 24-versioning-pagination-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/endpoints/version_endpoints.R
  - api/start_sysndd_api.R
  - api/Dockerfile
autonomous: true
user_setup: []

must_haves:
  truths:
    - "/api/version returns semantic version from version_spec.json"
    - "/api/version returns git commit hash (short format)"
    - "Swagger UI displays API version in header"
    - "Docker build injects git commit via ARG"
  artifacts:
    - path: "api/endpoints/version_endpoints.R"
      provides: "Version endpoint returning version and commit"
      exports: ["GET /"]
    - path: "api/start_sysndd_api.R"
      provides: "Version endpoint mounting"
      contains: "pr_mount.*version"
  key_links:
    - from: "api/endpoints/version_endpoints.R"
      to: "version_spec.json"
      via: "jsonlite::fromJSON"
      pattern: "fromJSON.*version_spec"
    - from: "api/Dockerfile"
      to: "api/start_sysndd_api.R"
      via: "GIT_COMMIT env var"
      pattern: "ARG GIT_COMMIT"
---

<objective>
Create /api/version endpoint that returns semantic version and git commit hash

Purpose: Enable deployment tracking and API version discovery (VER-01, VER-02)
Output: Working version endpoint accessible at /api/version
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-versioning-pagination-cleanup/24-RESEARCH.md

# Existing version loading pattern
@api/start_sysndd_api.R (lines 208-210 - version_json loading)
@api/version_spec.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create version endpoint with git integration</name>
  <files>api/endpoints/version_endpoints.R</files>
  <action>
Create new version_endpoints.R with:

1. GET / endpoint that returns:
   - version: from version_spec.json (already loaded as version_json global)
   - commit: short git hash via system2("git", c("rev-parse", "--short", "HEAD"))
   - title: from version_spec.json
   - description: from version_spec.json

2. Use Docker-compatible approach:
   - Check Sys.getenv("GIT_COMMIT") first (Docker build injection)
   - Fallback to system2 git command (development)
   - Return "unknown" if neither available

3. Pattern follows existing endpoint structure:
   - @tag version
   - @serializer json
   - @get /

No authentication required (public endpoint).
  </action>
  <verify>
File exists: api/endpoints/version_endpoints.R
Contains: @tag version, @get /, system2("git")
  </verify>
  <done>Version endpoint file created with git commit retrieval logic</done>
</task>

<task type="auto">
  <name>Task 2: Mount version endpoint and update Dockerfile</name>
  <files>api/start_sysndd_api.R, api/Dockerfile</files>
  <action>
1. In start_sysndd_api.R:
   - Add version endpoint to AUTH_ALLOWLIST:
     Add "^/api/version" to the allowlist patterns
   - Mount version endpoint:
     pr_mount("/api/version", pr("endpoints/version_endpoints.R"))
   - Place mount after health endpoint (public endpoints together)

2. In api/Dockerfile:
   - Add ARG GIT_COMMIT=unknown before final stage
   - Add ENV GIT_COMMIT=${GIT_COMMIT} to expose at runtime
   - Place after ARG TARGETPLATFORM line

This enables `docker build --build-arg GIT_COMMIT=$(git rev-parse --short HEAD)` pattern.
  </action>
  <verify>
grep -q "version_endpoints.R" api/start_sysndd_api.R
grep -q "GIT_COMMIT" api/Dockerfile
  </verify>
  <done>Version endpoint mounted at /api/version, Dockerfile accepts GIT_COMMIT build arg</done>
</task>

<task type="auto">
  <name>Task 3: Verify version endpoint works</name>
  <files>N/A</files>
  <action>
1. Start API locally:
   cd /home/bernt-popp/development/sysndd/api
   Rscript -e "plumber::pr_run(plumber::pr('start_sysndd_api.R'), port=8000)"

2. Test version endpoint:
   curl http://localhost:8000/api/version

3. Expected response:
   {
     "version": "0.2.0",
     "commit": "1254f6a" (or similar short hash),
     "title": "SysNDD API",
     "description": "This is the API powering..."
   }

4. Verify Swagger UI shows version at http://localhost:8000/__docs__/
   - Version should appear in the API info section (already configured via pr_set_api_spec)

Note: If API fails to start, check for syntax errors in version_endpoints.R
  </action>
  <verify>
curl response contains "version" and "commit" fields
Swagger UI accessible and shows version in header
  </verify>
  <done>Version endpoint returns correct version and commit, visible in Swagger UI</done>
</task>

</tasks>

<verification>
- [ ] GET /api/version returns 200 with version, commit, title, description
- [ ] commit field shows actual git hash (not "unknown") in development
- [ ] Swagger UI shows version in API info header
- [ ] Dockerfile has GIT_COMMIT ARG/ENV for production builds
- [ ] No authentication required for /api/version
</verification>

<success_criteria>
VER-01: /api/version endpoint returns semantic version and last commit
VER-02: Version displayed in Swagger UI (via existing pr_set_api_spec)

**Deferred requirements (future phase):**
- VER-03: URL path versioning (/api/v1/) - Requires mounting at both paths, bigger architectural change. Deferred to future versioning phase when breaking changes necessitate v2.
- VER-04: Version displayed in frontend - Can be added after /api/version endpoint exists. Low priority, deferred.
</success_criteria>

<output>
After completion, create `.planning/phases/24-versioning-pagination-cleanup/24-01-SUMMARY.md`
</output>
