---
phase: 57.1-pubtator-async-repository-refactor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/functions/pubtator-functions.R
autonomous: true

must_haves:
  truths:
    - "Async PubTator update uses parameterized queries for all SQL operations"
    - "No sprintf/paste SQL construction exists in pubtator_db_update_async"
    - "Gene symbol computation uses parameterized JOIN query"
    - "Async job submission endpoint still works correctly"
  artifacts:
    - path: "api/functions/pubtator-functions.R"
      provides: "pubtator_db_update_async() with parameterized queries"
      contains: "db_execute_query|db_execute_statement"
  key_links:
    - from: "api/functions/pubtator-functions.R"
      to: "api/functions/db-helpers.R"
      via: "db_execute_query and db_execute_statement with conn parameter"
      pattern: "db_execute_(query|statement)\\(.*conn\\s*=\\s*conn"
---

<objective>
Refactor pubtator_db_update_async() to use db-helpers with parameterized queries

Purpose: Eliminate SQL injection risk from sprintf-based SQL construction in async PubTator operations
Output: Secure, parameterized database operations using established repository pattern
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key reference files
@api/functions/db-helpers.R (db_execute_query, db_execute_statement signatures)
@api/functions/pubtator-functions.R (lines 408-661 - the function to refactor)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor pubtator_db_update_async query operations</name>
  <files>api/functions/pubtator-functions.R</files>
  <action>
Refactor all SELECT queries in pubtator_db_update_async() to use db_execute_query() with parameterized queries and conn parameter.

**Specific replacements (all within the function, lines 408-661):**

1. **Line 462-465 - Check existing query:**
```r
# FROM:
existing <- DBI::dbGetQuery(conn, sprintf(
  "SELECT query_id, queried_page_number FROM pubtator_query_cache WHERE query_hash = '%s'",
  q_hash
))

# TO:
existing <- db_execute_query(
  "SELECT query_id, queried_page_number FROM pubtator_query_cache WHERE query_hash = ?",
  list(q_hash), conn = conn
)
```

2. **Line 478 - Get LAST_INSERT_ID:**
```r
# FROM:
query_id <- DBI::dbGetQuery(conn, "SELECT LAST_INSERT_ID() AS id")$id[1]

# TO:
query_id <- db_execute_query("SELECT LAST_INSERT_ID() AS id", list(), conn = conn)$id[1]
```

3. **Line 558-561 - Get PMIDs:**
```r
# FROM:
pmid_rows <- DBI::dbGetQuery(conn, sprintf(
  "SELECT pmid FROM pubtator_search_cache WHERE query_id=%d AND pmid IS NOT NULL GROUP BY pmid",
  query_id
))

# TO:
pmid_rows <- db_execute_query(
  "SELECT pmid FROM pubtator_search_cache WHERE query_id = ? AND pmid IS NOT NULL GROUP BY pmid",
  list(query_id), conn = conn
)
```

4. **Line 572-574 - Get search mapping:**
```r
# FROM:
srch_map <- DBI::dbGetQuery(conn, sprintf(
  "SELECT search_id, pmid FROM pubtator_search_cache WHERE query_id=%d", query_id
))

# TO:
srch_map <- db_execute_query(
  "SELECT search_id, pmid FROM pubtator_search_cache WHERE query_id = ?",
  list(query_id), conn = conn
)
```

5. **Line 638-645 - Get final stats:**
```r
# FROM:
final_stats <- DBI::dbGetQuery(conn, sprintf(
  "SELECT queried_page_number, total_page_number FROM pubtator_query_cache WHERE query_id = %d",
  query_id
))
pub_count <- DBI::dbGetQuery(conn, sprintf(
  "SELECT COUNT(*) as cnt FROM pubtator_search_cache WHERE query_id = %d", query_id
))$cnt[1]

# TO:
final_stats <- db_execute_query(
  "SELECT queried_page_number, total_page_number FROM pubtator_query_cache WHERE query_id = ?",
  list(query_id), conn = conn
)
pub_count <- db_execute_query(
  "SELECT COUNT(*) as cnt FROM pubtator_search_cache WHERE query_id = ?",
  list(query_id), conn = conn
)$cnt[1]
```

**IMPORTANT:** Keep manual DBI::dbBegin/dbCommit/dbRollback for transaction handling (the db_with_transaction helper uses pool, not direct connections). Only replace the query execution within the transaction.
  </action>
  <verify>grep -c "db_execute_query.*conn = conn" api/functions/pubtator-functions.R shows at least 7 occurrences (5 in Task 1 + 2 in Task 3)</verify>
  <done>All SELECT operations in pubtator_db_update_async use db_execute_query with parameterized queries</done>
</task>

<task type="auto">
  <name>Task 2: Refactor pubtator_db_update_async statement operations</name>
  <files>api/functions/pubtator-functions.R</files>
  <action>
Refactor all INSERT/UPDATE/DELETE statements in pubtator_db_update_async() to use db_execute_statement() with parameterized queries and conn parameter.

**Specific replacements:**

1. **Line 473-477 - Insert new query record:**
```r
# FROM:
DBI::dbExecute(conn, sprintf(
  "INSERT INTO pubtator_query_cache (query_text, query_hash, total_page_number, queried_page_number, page_size)
   VALUES ('%s', '%s', %d, %d, 10)",
  gsub("'", "''", query), q_hash, total_pages, max_pages
))

# TO:
db_execute_statement(
  "INSERT INTO pubtator_query_cache (query_text, query_hash, total_page_number, queried_page_number, page_size)
   VALUES (?, ?, ?, ?, 10)",
  list(query, q_hash, total_pages, max_pages), conn = conn
)
```

2. **Line 487-492 - Delete annotations (for full update):**
```r
# FROM:
DBI::dbExecute(conn, sprintf(
  "DELETE a FROM pubtator_annotation_cache a
   JOIN pubtator_search_cache s ON a.search_id = s.search_id
   WHERE s.query_id = %d", query_id
))

# TO:
db_execute_statement(
  "DELETE a FROM pubtator_annotation_cache a
   JOIN pubtator_search_cache s ON a.search_id = s.search_id
   WHERE s.query_id = ?",
  list(query_id), conn = conn
)
```

3. **Line 492 - Delete search cache:**
```r
# FROM:
DBI::dbExecute(conn, sprintf("DELETE FROM pubtator_search_cache WHERE query_id = %d", query_id))

# TO:
db_execute_statement(
  "DELETE FROM pubtator_search_cache WHERE query_id = ?",
  list(query_id), conn = conn
)
```

4. **Line 493-496 - Update query cache (full update):**
```r
# FROM:
DBI::dbExecute(conn, sprintf(
  "UPDATE pubtator_query_cache SET total_page_number=%d, queried_page_number=%d WHERE query_id=%d",
  total_pages, max_pages, query_id
))

# TO:
db_execute_statement(
  "UPDATE pubtator_query_cache SET total_page_number = ?, queried_page_number = ? WHERE query_id = ?",
  list(total_pages, max_pages, query_id), conn = conn
)
```

5. **Line 548-551 - Update queried pages:**
```r
# FROM:
DBI::dbExecute(conn, sprintf(
  "UPDATE pubtator_query_cache SET queried_page_number=%d, total_page_number=%d WHERE query_id=%d",
  max_pages, total_pages, query_id
))

# TO:
db_execute_statement(
  "UPDATE pubtator_query_cache SET queried_page_number = ?, total_page_number = ? WHERE query_id = ?",
  list(max_pages, total_pages, query_id), conn = conn
)
```

6. **Line 531-546 - Insert search results (row-by-row loop):**
```r
# FROM: Complex sprintf with NULL handling and manual escaping

# TO:
for (r in seq_len(nrow(df_insert))) {
  row <- df_insert[r, ]
  db_execute_statement(
    "INSERT INTO pubtator_search_cache (query_id, id, pmid, doi, title, journal, date, score, text_hl)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
    list(
      row$query_id,
      if (is.na(row$id)) NA else row$id,
      if (is.na(row$pmid)) NA else row$pmid,
      if (is.na(row$doi)) NA else row$doi,
      if (is.na(row$title)) NA else substr(row$title, 1, 500),
      if (is.na(row$journal)) NA else substr(row$journal, 1, 255),
      if (is.na(row$date)) NA else row$date,
      if (is.na(row$score)) NA else row$score,
      if (is.na(row$text_hl)) NA else substr(row$text_hl, 1, 5000)
    ),
    conn = conn
  )
}
```

7. **Line 584-606 - Insert annotations (row-by-row loop):**
```r
# FROM: Complex sprintf with NULL handling

# TO:
for (r in seq_len(nrow(df_ann))) {
  row <- df_ann[r, ]
  db_execute_statement(
    "INSERT INTO pubtator_annotation_cache
     (search_id, pmid, id, text, identifier, type, ncbi_homologene, valid,
      normalized, `database`, normalized_id, biotype, name, accession)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
    list(
      if (is.na(row$search_id)) NA else row$search_id,
      if (is.na(row$pmid)) NA else row$pmid,
      if (is.na(row$id)) NA else substr(as.character(row$id), 1, 100),
      if (is.na(row$text)) NA else substr(as.character(row$text), 1, 500),
      if (is.na(row$identifier)) NA else substr(as.character(row$identifier), 1, 255),
      if (is.na(row$type)) NA else row$type,
      if (is.na(row$ncbi_homologene)) NA else row$ncbi_homologene,
      if (is.na(row$valid)) 0L else as.integer(row$valid),
      if (is.na(row$normalized)) NA else substr(as.character(row$normalized), 1, 100),
      if (is.na(row$`database`)) NA else substr(as.character(row$`database`), 1, 100),
      if (is.na(row$normalized_id)) NA else substr(as.character(row$normalized_id), 1, 100),
      if (is.na(row$biotype)) NA else substr(as.character(row$biotype), 1, 100),
      if (is.na(row$name)) NA else substr(as.character(row$name), 1, 255),
      if (is.na(row$accession)) NA else substr(as.character(row$accession), 1, 100)
    ),
    conn = conn
  )
}
```

**Note:** DBI's parameterized queries handle NA values correctly (converts to SQL NULL). No manual NULL/NA handling needed in sprintf-style.
  </action>
  <verify>grep -c "db_execute_statement.*conn = conn" api/functions/pubtator-functions.R shows at least 8 occurrences</verify>
  <done>All INSERT/UPDATE/DELETE operations in pubtator_db_update_async use db_execute_statement with parameterized queries</done>
</task>

<task type="auto">
  <name>Task 3: Refactor gene symbol computation and verify no sprintf SQL remains</name>
  <files>api/functions/pubtator-functions.R</files>
  <action>
1. **Refactor gene symbol computation query (lines 613-622):**

```r
# FROM:
gene_df <- DBI::dbGetQuery(conn, sprintf(
  "SELECT s.search_id,
          GROUP_CONCAT(DISTINCT nal.symbol ORDER BY nal.symbol SEPARATOR ',') AS gene_symbols
   FROM pubtator_search_cache s
   JOIN pubtator_annotation_cache a ON s.search_id = a.search_id
   JOIN non_alt_loci_set nal ON nal.entrez_id = a.normalized_id
   WHERE s.query_id = %d AND a.type = 'Gene' AND a.normalized_id IS NOT NULL
   GROUP BY s.search_id",
  query_id
))

# TO:
gene_df <- db_execute_query(
  "SELECT s.search_id,
          GROUP_CONCAT(DISTINCT nal.symbol ORDER BY nal.symbol SEPARATOR ',') AS gene_symbols
   FROM pubtator_search_cache s
   JOIN pubtator_annotation_cache a ON s.search_id = a.search_id
   JOIN non_alt_loci_set nal ON nal.entrez_id = a.normalized_id
   WHERE s.query_id = ? AND a.type = 'Gene' AND a.normalized_id IS NOT NULL
   GROUP BY s.search_id",
  list(query_id), conn = conn
)
```

2. **Refactor gene symbol UPDATE (lines 627-630):**

```r
# FROM:
for (r in seq_len(nrow(gene_df))) {
  DBI::dbExecute(conn, sprintf(
    "UPDATE pubtator_search_cache SET gene_symbols = '%s' WHERE search_id = %d",
    gsub("'", "''", gene_df$gene_symbols[r]), gene_df$search_id[r]
  ))
}

# TO:
for (r in seq_len(nrow(gene_df))) {
  db_execute_statement(
    "UPDATE pubtator_search_cache SET gene_symbols = ? WHERE search_id = ?",
    list(gene_df$gene_symbols[r], gene_df$search_id[r]),
    conn = conn
  )
}
```

3. **Final verification - ensure NO sprintf SQL remains in the function:**

After all refactoring, search for any remaining sprintf patterns within pubtator_db_update_async that construct SQL:
- No `sprintf.*SELECT`
- No `sprintf.*INSERT`
- No `sprintf.*UPDATE`
- No `sprintf.*DELETE`
- No `DBI::dbExecute(conn, sprintf`
- No `DBI::dbGetQuery(conn, sprintf`

The only remaining DBI calls should be:
- `DBI::dbConnect` (connection creation)
- `DBI::dbDisconnect` (connection cleanup)
- `DBI::dbBegin` / `DBI::dbCommit` / `DBI::dbRollback` (transaction control)

4. **Run linter and tests:**

```bash
cd /home/bernt-popp/development/sysndd
make lint-api
make test-api
```

Fix any lintr issues (line length, spacing).
  </action>
  <verify>
Run: awk '/^pubtator_db_update_async/,/^[a-z_]+\s*<-\s*function/' api/functions/pubtator-functions.R | grep -cE "sprintf.*(SELECT|INSERT|UPDATE|DELETE)"
Expected: 0 (no sprintf SQL construction in the async function)

Run: make lint-api (passes)
Run: make test-api (all tests pass)
  </verify>
  <done>
Gene symbol computation uses parameterized queries.
No sprintf SQL construction remains in pubtator_db_update_async.
All linter checks pass. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. **Security verification:**
   - `grep -c "sprintf.*VALUES" api/functions/pubtator-functions.R` in async function = 0
   - `grep -c "gsub.*''.*" api/functions/pubtator-functions.R` in async function = 0 (no manual escaping)

2. **Pattern verification:**
   - All db_execute_query calls pass `conn = conn`
   - All db_execute_statement calls pass `conn = conn`

3. **Functional verification:**
   - Start dev environment: `make docker-dev-db`
   - Submit async job: `curl -X POST http://localhost:8000/api/jobs/pubtator_update/submit`
   - Job should complete successfully (check job status endpoint)

4. **Test verification:**
   - `make test-api` passes
   - `make lint-api` passes
</verification>

<success_criteria>
1. pubtator_db_update_async() uses db_execute_query() for all SELECT operations with conn parameter
2. pubtator_db_update_async() uses db_execute_statement() for all INSERT/UPDATE/DELETE operations with conn parameter
3. All SQL uses ? placeholders (no sprintf, no manual escaping with gsub)
4. Gene symbol computation JOIN query uses parameterized approach
5. Manual transaction handling (dbBegin/dbCommit/dbRollback) preserved (works with direct connections)
6. Async job submission endpoint (/api/jobs/pubtator_update/submit) continues to work
7. All linter checks pass
8. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/57.1-pubtator-async-repository-refactor/57.1-01-SUMMARY.md`
</output>
