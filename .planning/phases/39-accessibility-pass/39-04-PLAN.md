---
phase: 39-accessibility-pass
plan: 04
type: execute
wave: 3
depends_on: ["39-02", "39-03"]
files_modified:
  - app/src/views/curate/ApproveUser.a11y.spec.ts
  - app/src/views/curate/ApproveReview.a11y.spec.ts
  - app/src/views/curate/ApproveStatus.a11y.spec.ts
  - app/src/views/curate/ModifyEntity.a11y.spec.ts
  - app/src/views/curate/ManageReReview.a11y.spec.ts
  - app/src/views/review/Review.a11y.spec.ts
autonomous: true

must_haves:
  truths:
    - "Each of the 6 curation views has a vitest-axe accessibility test file"
    - "Tests use axe-core to detect WCAG 2.2 AA violations"
    - "Tests verify aria-live regions exist with correct attributes"
    - "Tests verify icon legends are rendered when applicable"
    - "Tests verify decorative icons have aria-hidden attribute"
    - "Tests verify all BModal instances have accessible titles (title prop, aria-label, or aria-labelledby)"
    - "Tests verify keyboard-reachable interactive elements have proper tabindex and roles"
  artifacts:
    - path: "app/src/views/curate/ApproveUser.a11y.spec.ts"
      provides: "Accessibility tests for ApproveUser"
      min_lines: 30
    - path: "app/src/views/curate/ApproveReview.a11y.spec.ts"
      provides: "Accessibility tests for ApproveReview"
      min_lines: 30
    - path: "app/src/views/curate/ApproveStatus.a11y.spec.ts"
      provides: "Accessibility tests for ApproveStatus"
      min_lines: 30
    - path: "app/src/views/curate/ModifyEntity.a11y.spec.ts"
      provides: "Accessibility tests for ModifyEntity"
      min_lines: 30
    - path: "app/src/views/curate/ManageReReview.a11y.spec.ts"
      provides: "Accessibility tests for ManageReReview"
      min_lines: 30
    - path: "app/src/views/review/Review.a11y.spec.ts"
      provides: "Accessibility tests for Review"
      min_lines: 30
  key_links:
    - from: "app/src/views/curate/ApproveUser.a11y.spec.ts"
      to: "app/src/test-utils/a11y-helpers.ts"
      via: "expectNoA11yViolations import"
      pattern: "expectNoA11yViolations"
---

<objective>
Create vitest-axe accessibility tests for all 6 curation views to verify WCAG 2.2 AA compliance, including modal title verification and keyboard navigation checks.

Purpose: Automated accessibility regression testing catches ~30% of WCAG issues. Tests verify aria-live regions, icon legends, aria-hidden attributes, modal titles, and keyboard reachability of interactive elements.
Output: 6 a11y test files using the existing test pattern from Footer.a11y.spec.ts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/39-accessibility-pass/39-CONTEXT.md
@.planning/phases/39-accessibility-pass/39-RESEARCH.md
@.planning/phases/39-accessibility-pass/39-02-SUMMARY.md
@.planning/phases/39-accessibility-pass/39-03-SUMMARY.md
@app/src/components/Footer.a11y.spec.ts
@app/src/test-utils/a11y-helpers.ts
@app/src/test-utils/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create a11y tests for ApproveUser, ApproveReview, ApproveStatus</name>
  <files>
    app/src/views/curate/ApproveUser.a11y.spec.ts
    app/src/views/curate/ApproveReview.a11y.spec.ts
    app/src/views/curate/ApproveStatus.a11y.spec.ts
  </files>
  <action>
Create accessibility test files following the existing Footer.a11y.spec.ts pattern. Each test file should:

1. **Follow the established pattern:**
```typescript
import { describe, it, vi } from 'vitest';
import { mount, flushPromises } from '@vue/test-utils';
import { expectNoA11yViolations, bootstrapStubs } from '@/test-utils';
import ComponentName from './ComponentName.vue';
```

2. **Mock API calls** with `vi.mock` or provide global mocks for `this.axios` since these views make API calls on mount. The simplest approach: mock the global `axios` property and provide route/router stubs.

3. **Stub complex child components** that make their own API calls or have complex dependencies. Use `bootstrapStubs` from test-utils and add custom stubs for:
   - `TreeMultiSelect` (ApproveReview only)
   - `EntityBadge`, `GeneBadge`, `DiseaseBadge`, `InheritanceBadge`, `CategoryIcon`
   - `AriaLiveRegion` -> stub with accessible HTML: `<div role="status" aria-live="polite"></div>`
   - `IconLegend` -> stub with: `<div class="icon-legend"><strong>Icon Legend:</strong></div>`
   - `AutocompleteInput` (ModifyEntity only)
   - `BatchCriteriaForm` (ManageReReview only)

4. **Disable the `region` axe rule** for isolated component tests (components are tested outside full page context):
```typescript
const axeOptions = {
  rules: { region: { enabled: false } },
};
```

5. **Each test file has these test cases:**

```typescript
describe('ComponentName accessibility', () => {
  const axeOptions = { rules: { region: { enabled: false } } };

  const mountComponent = async () => {
    const wrapper = mount(ComponentName, {
      global: {
        stubs: {
          ...bootstrapStubs,
          // View-specific stubs
          AriaLiveRegion: {
            template: '<div role="status" aria-live="polite"></div>',
          },
          IconLegend: {
            template: '<div class="icon-legend"><strong>Icon Legend:</strong></div>',
          },
          // ... other stubs
        },
        mocks: {
          axios: {
            get: vi.fn().mockResolvedValue({ data: [] }),
            put: vi.fn().mockResolvedValue({ data: {} }),
            post: vi.fn().mockResolvedValue({ data: {} }),
          },
        },
      },
    });
    await flushPromises();
    return wrapper;
  };

  it('has no accessibility violations', async () => {
    const wrapper = await mountComponent();
    await expectNoA11yViolations(wrapper.element, axeOptions);
  });

  it('has aria-live region for status announcements', async () => {
    const wrapper = await mountComponent();
    const liveRegion = wrapper.find('[role="status"]');
    expect(liveRegion.exists()).toBe(true);
    expect(liveRegion.attributes('aria-live')).toBe('polite');
  });

  it('decorative icons have aria-hidden', async () => {
    const wrapper = await mountComponent();
    // Check that icon elements inside buttons with aria-label have aria-hidden
    const buttons = wrapper.findAll('button[aria-label] i, [role="button"][aria-label] i');
    buttons.forEach((icon) => {
      expect(icon.attributes('aria-hidden')).toBe('true');
    });
  });

  // --- Modal title verification (A11Y-03) ---
  it('all modals have accessible titles', async () => {
    const wrapper = await mountComponent();
    // Find all modal elements (BModal renders as [role="dialog"] or stubs may vary)
    // Check that each modal has aria-labelledby, aria-label, or title attribute
    const modals = wrapper.findAll('[role="dialog"]');
    modals.forEach((modal) => {
      const hasAriaLabel = modal.attributes('aria-label');
      const hasAriaLabelledby = modal.attributes('aria-labelledby');
      const hasTitle = modal.attributes('title');
      expect(
        hasAriaLabel || hasAriaLabelledby || hasTitle,
        `Modal missing accessible title: ${modal.html().substring(0, 100)}`
      ).toBeTruthy();
    });
  });

  // --- Keyboard navigation verification (A11Y-05) ---
  it('all action buttons are keyboard-reachable (not tabindex=-1)', async () => {
    const wrapper = await mountComponent();
    // Find all buttons and verify none have tabindex="-1" (which would remove from tab order)
    const buttons = wrapper.findAll('button, [role="button"], a[href]');
    buttons.forEach((btn) => {
      const tabindex = btn.attributes('tabindex');
      // tabindex should be undefined (default, in tab order) or >= 0
      if (tabindex !== undefined) {
        expect(
          parseInt(tabindex) >= 0,
          `Interactive element removed from tab order: ${btn.html().substring(0, 100)}`
        ).toBe(true);
      }
    });
  });

  it('form inputs have associated labels or aria-label', async () => {
    const wrapper = await mountComponent();
    const inputs = wrapper.findAll('input, select, textarea');
    inputs.forEach((input) => {
      const id = input.attributes('id');
      const ariaLabel = input.attributes('aria-label');
      const ariaLabelledby = input.attributes('aria-labelledby');
      // Input should have either aria-label, aria-labelledby, or an associated <label>
      const hasLabel = id ? wrapper.find(`label[for="${id}"]`).exists() : false;
      expect(
        ariaLabel || ariaLabelledby || hasLabel,
        `Form input missing label: ${input.html().substring(0, 100)}`
      ).toBeTruthy();
    });
  });
});
```

6. **Additional view-specific tests:**

For **ApproveReview** and **ApproveStatus**, add:
```typescript
it('has icon legend for symbolic icons', async () => {
  const wrapper = await mountComponent();
  const legend = wrapper.find('.icon-legend');
  expect(legend.exists()).toBe(true);
});
```

7. **Handle the Options API setup pattern:** These views use `this.axios` via global property. Mock it via `global.mocks`. Also mock `useToast`, `useColorAndSymbols`, and `useText` composables if they cause issues - or let them run since they return simple objects.

8. **NOTE:** Tests may need `vi.mock` for API imports at the top. Check the existing test patterns. If the axios mock via `global.mocks` doesn't work (because the views use `this.axios`), try providing it as a global property:
```typescript
global: {
  config: {
    globalProperties: {
      axios: { get: vi.fn()... },
    },
  },
}
```

The goal is NOT 100% pass rate on first try. The goal is to create well-structured test files that check accessibility. Some tests may need adjustment during execution. Focus on the `expectNoA11yViolations` core test and the structural checks (aria-live, aria-hidden, icon-legend, modal titles, keyboard reachability).
  </action>
  <verify>
All 3 test files exist. Run: `cd /home/bernt-popp/development/sysndd/app && npx vitest run --reporter=verbose src/views/curate/ApproveUser.a11y.spec.ts src/views/curate/ApproveReview.a11y.spec.ts src/views/curate/ApproveStatus.a11y.spec.ts 2>&1 | tail -30`
Tests should pass or fail with clear messages. Fix any failures that are due to test setup (mocking, stubs) rather than actual accessibility issues.
  </verify>
  <done>3 a11y test files created and passing for ApproveUser, ApproveReview, ApproveStatus with modal title and keyboard reachability checks</done>
</task>

<task type="auto">
  <name>Task 2: Create a11y tests for ModifyEntity, ManageReReview, Review</name>
  <files>
    app/src/views/curate/ModifyEntity.a11y.spec.ts
    app/src/views/curate/ManageReReview.a11y.spec.ts
    app/src/views/review/Review.a11y.spec.ts
  </files>
  <action>
Create accessibility test files for the remaining 3 views following the same pattern as Task 1:

1. **Same base structure** as Task 1 (import pattern, axeOptions, mountComponent helper)

2. **View-specific stubs:**

For **ModifyEntity:**
- Stub `AutocompleteInput` with: `<div><label for="entity-select">Entity</label><input id="entity-select" type="text" /></div>`
- Stub badge components (EntityBadge, GeneBadge, DiseaseBadge, InheritanceBadge, CategoryIcon)
- Mock entity form composables if used

For **ManageReReview:**
- Stub `BatchCriteriaForm` with: `<div><label>Batch Form</label></div>`
- Stub all badge components
- Mock batch-related API calls

For **Review:**
- Stub `TreeMultiSelect`, `ReviewFormFields` if present
- Stub badge components
- Mock re-review API calls
- Mock `this.$route.params` for entity_id

3. **Same test cases for all 3 views:**
- `has no accessibility violations` (axe-core check)
- `has aria-live region for status announcements`
- `decorative icons have aria-hidden`
- `all modals have accessible titles` (A11Y-03 -- same pattern as Task 1)
- `all action buttons are keyboard-reachable (not tabindex=-1)` (A11Y-05 -- same pattern as Task 1)
- `form inputs have associated labels or aria-label` (A11Y-05 -- same pattern as Task 1)

4. **Additional view-specific tests:**

For **ModifyEntity:**
```typescript
it('has icon legend when entity is loaded', async () => {
  // May need to set data to simulate entity_loaded state
  const wrapper = await mountComponent();
  // If entity not loaded by default, set data
  await wrapper.setData({ entity_loaded: true, entity_info: { entity_id: 1 } });
  await flushPromises();
  const legend = wrapper.find('.icon-legend');
  expect(legend.exists()).toBe(true);
});

// Modal title test specific to ModifyEntity's many modals
it('all entity modification modals have descriptive titles', async () => {
  const wrapper = await mountComponent();
  const modals = wrapper.findAll('[role="dialog"]');
  modals.forEach((modal) => {
    const hasAriaLabel = modal.attributes('aria-label');
    const hasAriaLabelledby = modal.attributes('aria-labelledby');
    const hasTitle = modal.attributes('title');
    expect(
      hasAriaLabel || hasAriaLabelledby || hasTitle,
      `Modal missing accessible title: ${modal.html().substring(0, 100)}`
    ).toBeTruthy();
  });
});
```

For **ManageReReview:**
```typescript
it('has icon legend for batch icons', async () => {
  const wrapper = await mountComponent();
  const legend = wrapper.find('.icon-legend');
  expect(legend.exists()).toBe(true);
});
```

For **Review:**
```typescript
it('has icon legend for category icons', async () => {
  const wrapper = await mountComponent();
  const legend = wrapper.find('.icon-legend');
  expect(legend.exists()).toBe(true);
});

// Review uses form, not modals -- verify form is keyboard-submittable
it('review form submit button is keyboard-accessible', async () => {
  const wrapper = await mountComponent();
  const submitBtn = wrapper.find('button[type="submit"], [role="button"]');
  if (submitBtn.exists()) {
    const tabindex = submitBtn.attributes('tabindex');
    expect(tabindex === undefined || parseInt(tabindex) >= 0).toBe(true);
  }
});
```

5. **Run tests and fix setup issues.** If a test fails due to missing mock/stub, fix the test setup. If it fails due to actual accessibility violation, note it for potential follow-up but don't modify the source views (those were already updated in Plans 02/03).
  </action>
  <verify>
All 3 test files exist. Run: `cd /home/bernt-popp/development/sysndd/app && npx vitest run --reporter=verbose src/views/curate/ModifyEntity.a11y.spec.ts src/views/curate/ManageReReview.a11y.spec.ts src/views/review/Review.a11y.spec.ts 2>&1 | tail -30`
Tests should pass or fail with clear messages. Fix any failures due to test setup.
  </verify>
  <done>3 a11y test files created and passing for ModifyEntity, ManageReReview, Review with modal title and keyboard reachability checks</done>
</task>

</tasks>

<verification>
- All 6 test files exist with `.a11y.spec.ts` naming convention
- All tests use expectNoA11yViolations from test-utils
- All tests check for aria-live region presence
- All tests check for aria-hidden on decorative icons
- Tests for views with IconLegend verify legend presence
- All tests verify modal accessible titles (A11Y-03)
- All tests verify keyboard reachability of interactive elements (A11Y-05)
- All tests verify form inputs have associated labels (A11Y-05)
- Run full suite: `cd /home/bernt-popp/development/sysndd/app && npx vitest run --reporter=verbose "**/*.a11y.spec.ts" 2>&1 | tail -40`

**Manual Keyboard Navigation Verification Checklist (A11Y-05):**
After all plans execute, manually verify the following end-to-end keyboard workflows.
This checklist is for human verification during UAT, not automated tests:

1. [ ] Tab from page load reaches skip link -> pressing Enter jumps to main content
2. [ ] Tab through ApproveUser table -> reach approve/reject buttons -> press Enter to activate
3. [ ] Tab into ApproveReview -> open edit modal via Enter/Space -> Tab cycles within modal -> Escape closes and returns focus to trigger button
4. [ ] Tab into ApproveStatus -> open edit modal -> complete form with Tab only -> submit with Enter
5. [ ] Tab into ModifyEntity -> open each modification modal (status, review, phenotype, variation) -> verify focus trap and return
6. [ ] Tab into ManageReReview -> create batch via keyboard -> assign reviewer via keyboard
7. [ ] Tab through Review form -> fill all fields with Tab -> submit with Enter
8. [ ] Shift+Tab navigates backwards through all interactive elements in correct reverse order
9. [ ] No keyboard traps anywhere (can always Tab out of any component except modals, which require Escape)
</verification>

<success_criteria>
- 6 a11y test files exist, one per curation view
- axe-core runs against each component without errors
- Structural assertions verify aria-live, aria-hidden, icon-legend, modal titles, and keyboard reachability
- Tests follow established project pattern (Footer.a11y.spec.ts)
- Modal title tests cover A11Y-03 requirement
- Keyboard reachability tests cover automated portion of A11Y-05
- Manual keyboard checklist documented for UAT verification of end-to-end A11Y-05
</success_criteria>

<output>
After completion, create `.planning/phases/39-accessibility-pass/39-04-SUMMARY.md`
</output>
