---
phase: 37-form-modernization
plan: 03
type: execute
wave: 2
depends_on: ["37-01", "37-02"]
files_modified:
  - app/src/views/curate/composables/useReviewForm.ts
  - app/src/views/curate/composables/useStatusForm.ts
  - app/src/views/review/Review.vue
  - app/src/views/curate/ModifyEntity.vue
autonomous: true

must_haves:
  truths:
    - "Modification forms auto-save drafts to localStorage after 2s debounce"
    - "User is prompted to restore draft when opening form with existing draft"
    - "Draft is cleared only on successful submission"
    - "Modals reset form state on @show event (not just @hide)"
    - "No stale data visible when opening modal for different entity"
  artifacts:
    - path: "app/src/views/curate/composables/useReviewForm.ts"
      provides: "Review form with draft persistence"
      contains: "useFormDraft"
    - path: "app/src/views/curate/composables/useStatusForm.ts"
      provides: "Status form with draft persistence"
      contains: "useFormDraft"
  key_links:
    - from: "useReviewForm.ts"
      to: "useFormDraft"
      via: "composable composition"
      pattern: "useFormDraft"
    - from: "app/src/views/review/Review.vue"
      to: "@show handler"
      via: "modal event"
      pattern: "@show"
---

<objective>
Add draft persistence to modification forms and fix form reset on modal @show

Purpose: Prevent loss of curator work when navigating away or closing modals accidentally. Ensure clean form state when opening modals for different entities (FORM-07 requirement).

Output:
- useReviewForm integrated with useFormDraft for auto-save
- useStatusForm integrated with useFormDraft for auto-save
- Draft restoration prompt in Review.vue and ModifyEntity.vue
- Modal @show handlers that reset forms before displaying
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-form-modernization/37-CONTEXT.md
@.planning/phases/37-form-modernization/37-RESEARCH.md

# Existing draft pattern
@app/src/composables/useFormDraft.ts

# Files from Plan 01 and 02 (assumes complete)
@app/src/views/curate/composables/useReviewForm.ts
@app/src/views/curate/composables/useStatusForm.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate useFormDraft into useReviewForm</name>
  <files>app/src/views/curate/composables/useReviewForm.ts</files>
  <action>
Add draft persistence to useReviewForm composable:

1. Import useFormDraft:
```typescript
import useFormDraft from '@/composables/useFormDraft';
```

2. Initialize draft composable with entity-specific key:
```typescript
export default function useReviewForm(entityId?: string | number) {
  // Existing form state...

  // Draft persistence (key includes entity ID for entity-specific drafts)
  const draftKey = entityId ? `review-form-${entityId}` : 'review-form-new';
  const formDraft = useFormDraft<ReviewFormData>(draftKey);
  const {
    hasDraft,
    lastSavedFormatted,
    isSaving,
    saveDraft,
    loadDraft,
    clearDraft,
    checkForDraft,
    scheduleSave,
  } = formDraft;
```

3. Add watch to auto-save on changes with debounce:
```typescript
watch(
  () => getFormSnapshot(),
  (newData) => {
    // Only schedule save if form has meaningful content
    if (newData.synopsis || newData.phenotypes.length || newData.publications.length) {
      scheduleSave(newData);
    }
  },
  { deep: true }
);
```

4. Add draft restoration method:
```typescript
const restoreFromDraft = (): boolean => {
  const draft = loadDraft();
  if (draft) {
    restoreFromSnapshot(draft);
    return true;
  }
  return false;
};
```

5. Update submitForm to clear draft on success:
```typescript
const submitForm = async (isUpdate: boolean, reReview: boolean) => {
  // ... existing submission logic ...

  // Clear draft on successful submission
  clearDraft();

  return response;
};
```

6. Export draft-related state and methods:
```typescript
return {
  // Existing exports...

  // Draft persistence
  hasDraft,
  lastSavedFormatted,
  isSaving,
  checkForDraft,
  restoreFromDraft,
  clearDraft,
};
```
  </action>
  <verify>
- useReviewForm imports and uses useFormDraft
- Draft auto-saves after form changes
- clearDraft called on successful submission
- `cd app && npx tsc --noEmit` passes
  </verify>
  <done>
useReviewForm composable integrated with useFormDraft for auto-save with 2s debounce, draft cleared on successful submission
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate useFormDraft into useStatusForm</name>
  <files>app/src/views/curate/composables/useStatusForm.ts</files>
  <action>
Add draft persistence to useStatusForm composable:

1. Import useFormDraft:
```typescript
import useFormDraft from '@/composables/useFormDraft';
```

2. Initialize draft composable with entity-specific key:
```typescript
export default function useStatusForm(entityId?: string | number) {
  // Existing form state...

  // Draft persistence
  const draftKey = entityId ? `status-form-${entityId}` : 'status-form-new';
  const formDraft = useFormDraft<StatusFormData>(draftKey);
  const {
    hasDraft,
    lastSavedFormatted,
    isSaving,
    saveDraft,
    loadDraft,
    clearDraft,
    checkForDraft,
    scheduleSave,
  } = formDraft;
```

3. Add watch to auto-save on changes:
```typescript
watch(
  () => ({ ...formData }),
  (newData) => {
    // Only schedule save if form has meaningful content
    if (newData.category_id !== null || newData.comment) {
      scheduleSave(newData);
    }
  },
  { deep: true }
);
```

4. Add draft restoration method:
```typescript
const restoreFromDraft = (): boolean => {
  const draft = loadDraft();
  if (draft) {
    Object.assign(formData, draft);
    return true;
  }
  return false;
};
```

5. Update submitForm to clear draft on success:
```typescript
const submitForm = async (isUpdate: boolean, reReview: boolean) => {
  // ... existing submission logic ...

  // Clear draft on successful submission
  clearDraft();

  return response;
};
```

6. Export draft-related state and methods:
```typescript
return {
  // Existing exports...

  // Draft persistence
  hasDraft,
  lastSavedFormatted,
  isSaving,
  checkForDraft,
  restoreFromDraft,
  clearDraft,
};
```
  </action>
  <verify>
- useStatusForm imports and uses useFormDraft
- Draft auto-saves after form changes
- clearDraft called on successful submission
- `cd app && npx tsc --noEmit` passes
  </verify>
  <done>
useStatusForm composable integrated with useFormDraft for auto-save with 2s debounce, draft cleared on successful submission
  </done>
</task>

<task type="auto">
  <name>Task 3: Add draft restoration prompts and @show handlers to modals</name>
  <files>
app/src/views/review/Review.vue
app/src/views/curate/ModifyEntity.vue
  </files>
  <action>
Add draft restoration UI and form reset on @show for all modification modals:

**Review.vue changes:**

1. Add @show handlers to review and status modals:
```vue
<BModal
  :id="reviewModal.id"
  @show="onReviewModalShow"
  @ok="submitReviewChange"
>
```

```vue
<BModal
  :id="statusModal.id"
  @show="onStatusModalShow"
  @ok="submitStatusChange"
>
```

2. Implement @show handlers:
```javascript
methods: {
  onReviewModalShow() {
    // Reset form state immediately on show (FORM-07)
    this.reviewForm.resetForm();
    // Then load fresh data (already called in infoReview, but belt-and-suspenders)
  },

  onStatusModalShow() {
    // Reset form state immediately on show
    this.statusForm.resetForm();
  },
}
```

3. Add draft restoration check in infoReview (after loading data):
```javascript
async infoReview(item, index, button) {
  this.reviewModal.title = `sysndd:${item.entity_id}`;
  await this.getEntity(item.entity_id);

  // Check for existing draft before loading server data
  if (this.reviewForm.checkForDraft()) {
    // Show confirmation dialog
    const restore = await this.confirmDraftRestore();
    if (restore) {
      this.reviewForm.restoreFromDraft();
    } else {
      this.reviewForm.clearDraft();
      await this.reviewForm.loadReviewData(item.review_id, item.re_review_review_saved);
    }
  } else {
    await this.reviewForm.loadReviewData(item.review_id, item.re_review_review_saved);
  }

  showModal(this.reviewModal.id);
}
```

4. Add confirmDraftRestore helper (using native confirm or toast):
```javascript
confirmDraftRestore() {
  return window.confirm(
    'You have unsaved changes from a previous session. Would you like to restore them?'
  );
}
```

5. Add visual indicator for draft save status in modal footer (optional but helpful):
```vue
<span v-if="reviewForm.isSaving" class="text-muted small">
  <BSpinner small /> Saving draft...
</span>
<span v-else-if="reviewForm.lastSavedFormatted" class="text-muted small">
  Draft saved {{ reviewForm.lastSavedFormatted }}
</span>
```

**ModifyEntity.vue changes:**

1. Add @show handlers to all modals:
```vue
<BModal id="modifyReviewModal" @show="onModifyReviewModalShow" ...>
<BModal id="modifyStatusModal" @show="onModifyStatusModalShow" ...>
<BModal id="renameModal" @show="onRenameModalShow" ...>
<BModal id="deactivateModal" @show="onDeactivateModalShow" ...>
```

2. Implement @show handlers:
```javascript
onModifyReviewModalShow() {
  // Reset form on show (prevents stale data flash - FORM-07)
  this.reviewForm?.resetForm();
},

onModifyStatusModalShow() {
  this.statusForm?.resetForm();
},

onRenameModalShow() {
  // Reset rename-specific state
  this.ontology_input = null;
  this.ontology_display = '';
  this.ontology_search_results = [];
},

onDeactivateModalShow() {
  // Reset deactivate-specific state
  this.deactivate_check = false;
  this.replace_check = false;
  this.replace_entity_input = null;
  this.replace_entity_display = '';
}
```

3. Add draft check in showReviewModify:
```javascript
async showReviewModify() {
  await this.getEntity();
  if (!this.entity_info?.entity_id) return;

  // Check for draft
  if (this.reviewForm.checkForDraft()) {
    const restore = window.confirm('Restore unsaved changes?');
    if (restore) {
      this.reviewForm.restoreFromDraft();
    } else {
      this.reviewForm.clearDraft();
      await this.getReview();
    }
  } else {
    await this.getReview();
  }

  this.$refs.modifyReviewModal.show();
}
```

4. Similar draft check in showStatusModify
  </action>
  <verify>
- All modals have @show handlers
- Form state resets on modal show (no stale data)
- Draft restoration prompt appears when draft exists
- Draft cleared when user declines restore
- `cd app && npm run lint -- --fix` passes
  </verify>
  <done>
Modals reset forms on @show (FORM-07), draft restoration prompts work, drafts persist between sessions and clear on successful submission
  </done>
</task>

</tasks>

<verification>
Overall phase verification:
1. TypeScript compiles: `cd app && npx tsc --noEmit`
2. Lint passes: `cd app && npm run lint`
3. App builds: `cd app && npm run build`
4. Manual test: Open review modal, make changes, close without saving, reopen - draft prompt appears
5. Manual test: Open modal for entity A, then entity B - no stale data from A visible
6. Manual test: Submit form - draft cleared
</verification>

<success_criteria>
- Draft auto-saves after form changes (2s debounce)
- Draft restoration prompt appears when opening form with existing draft
- User can accept or decline draft restoration
- Draft cleared only on successful submission (not on close/cancel)
- Modals reset form state on @show event (FORM-07)
- No stale data visible when switching between entities
- TypeScript and lint pass without errors
</success_criteria>

<output>
After completion, create `.planning/phases/37-form-modernization/37-03-SUMMARY.md`
</output>
