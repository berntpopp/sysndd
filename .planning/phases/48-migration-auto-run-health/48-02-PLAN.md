---
phase: 48-migration-auto-run-health
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - api/endpoints/health_endpoints.R
  - api/core/middleware.R
autonomous: true

must_haves:
  truths:
    - "Health endpoint reports pending migrations count"
    - "Health endpoint returns HTTP 503 when migrations are pending"
    - "Health endpoint returns HTTP 200 when ready to serve"
    - "Health endpoint is publicly accessible (no authentication required)"
  artifacts:
    - path: "api/endpoints/health_endpoints.R"
      provides: "Readiness endpoint for Kubernetes probes"
      exports: ["GET /ready"]
    - path: "api/core/middleware.R"
      provides: "Public access for /health/ready endpoint"
      contains: "/health/ready"
  key_links:
    - from: "api/endpoints/health_endpoints.R"
      to: "migration_status"
      via: "global variable access"
      pattern: "migration_status\\$pending_migrations"
    - from: "api/core/middleware.R"
      to: "/health/ready"
      via: "AUTH_ALLOWLIST entry"
      pattern: '"/health/ready"'
---

<objective>
Add readiness health endpoint for migration status visibility

Purpose: Provides a Kubernetes-compatible readiness probe that reports migration status. Returns HTTP 503 when migrations are pending (not ready) and HTTP 200 when ready to serve traffic. Enables container orchestration to wait for schema to be current before routing traffic.

Output: New /health/ready endpoint in health_endpoints.R, AUTH_ALLOWLIST updated in middleware.R for public access.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/48-migration-auto-run-health/48-CONTEXT.md
@.planning/phases/48-migration-auto-run-health/48-RESEARCH.md

# Source files to modify
@api/endpoints/health_endpoints.R
@api/core/middleware.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add /ready endpoint to health_endpoints.R</name>
  <files>api/endpoints/health_endpoints.R</files>
  <action>
Add a new readiness endpoint to api/endpoints/health_endpoints.R after the existing liveness endpoint (around line 21).

Insert the following endpoint definition:

```r
#* Readiness check for Kubernetes probes
#*
#* Returns HTTP 200 when ready to serve traffic, HTTP 503 when not ready.
#* Reports pending migration count for monitoring and diagnostics.
#*
#* # `Response Codes`
#* - 200: API ready to serve traffic (migrations current)
#* - 503: API not ready (migrations pending or not yet run)
#*
#* # `Details`
#* This endpoint checks if database migrations have been applied. The
#* migration_status global variable is set during API startup by the
#* migration runner. If migrations haven't run yet (startup in progress)
#* or if migrations are pending, returns HTTP 503 to signal not ready.
#*
#* Use this endpoint for Kubernetes readiness probes to ensure traffic
#* is only routed to containers with current database schema.
#*
#* @tag health
#* @serializer json
#*
#* @response 200 OK. API ready to serve traffic.
#* @response 503 Service Unavailable. Migrations pending or not yet run.
#*
#* @get /ready
function(req, res) {
  # Check if migrations have run (variable set during API startup)
  if (!exists("migration_status", envir = .GlobalEnv) ||
      is.null(get("migration_status", envir = .GlobalEnv))) {
    res$status <- 503L
    return(list(
      status = "not_ready",
      reason = "migrations_not_run",
      pending_migrations = NA,
      timestamp = format(Sys.time(), "%Y-%m-%dT%H:%M:%SZ", tz = "UTC")
    ))
  }

  # Get migration status from global
  status <- get("migration_status", envir = .GlobalEnv)
  pending <- status$pending_migrations

  # If there are pending migrations, not ready
  if (!is.null(pending) && pending > 0) {
    res$status <- 503L
    return(list(
      status = "not_ready",
      reason = "migrations_pending",
      pending_migrations = pending,
      timestamp = format(Sys.time(), "%Y-%m-%dT%H:%M:%SZ", tz = "UTC")
    ))
  }

  # Ready to serve
  list(
    status = "ready",
    pending_migrations = 0,
    total_migrations = status$total_migrations,
    timestamp = format(Sys.time(), "%Y-%m-%dT%H:%M:%SZ", tz = "UTC")
  )
}
```

Key implementation notes:
- Use `exists("migration_status", envir = .GlobalEnv)` to safely check global
- Use `get("migration_status", envir = .GlobalEnv)` to access global variable
- Return HTTP 503 (Service Unavailable) when not ready - standard for readiness probes
- Return HTTP 200 with status details when ready
- Include timestamp for debugging/monitoring
- Include total_migrations count for visibility into applied state
  </action>
  <verify>
Verify endpoint syntax is correct:
```bash
# Check that the endpoint file can be parsed
docker exec sysndd_api Rscript -e "plumber::pr('endpoints/health_endpoints.R')" 2>&1 | head -5
```
  </verify>
  <done>
- /ready endpoint returns HTTP 200 when migrations current
- /ready endpoint returns HTTP 503 when migrations pending
- /ready endpoint returns HTTP 503 when migrations not yet run
- Response includes pending_migrations count
- Response includes timestamp for debugging
  </done>
</task>

<task type="auto">
  <name>Task 2: Add /health/ready to AUTH_ALLOWLIST</name>
  <files>api/core/middleware.R</files>
  <action>
Add the new /health/ready endpoint to AUTH_ALLOWLIST in api/core/middleware.R to allow public access without authentication.

Find the AUTH_ALLOWLIST array (starts around line 19) and add the new entries:

1. Locate the existing health entries:
```r
  "/health",
  "/health/",
```

2. Add the new /health/ready entries immediately after:
```r
  "/health",
  "/health/",
  "/health/ready",
  "/health/ready/",
```

This ensures both the path with and without trailing slash are allowed (consistent with existing pattern for other endpoints).

Note: The existing /health/performance endpoint doesn't need AUTH_ALLOWLIST entry because GET requests without auth are already allowed by the middleware (line 87-91: "GET requests without auth get public read access").
  </action>
  <verify>
Verify AUTH_ALLOWLIST contains /health/ready:
```bash
grep -n '"/health/ready"' api/core/middleware.R
```
Should show the line with /health/ready in AUTH_ALLOWLIST.
  </verify>
  <done>
- /health/ready added to AUTH_ALLOWLIST
- /health/ready/ (with trailing slash) added to AUTH_ALLOWLIST
- Readiness endpoint accessible without authentication
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Verify endpoint exists in health_endpoints.R:**
   ```bash
   grep -n "@get /ready" api/endpoints/health_endpoints.R
   ```

2. **Verify AUTH_ALLOWLIST updated:**
   ```bash
   grep '"/health/ready"' api/core/middleware.R
   ```

3. **Test readiness endpoint (after API restart):**
   ```bash
   docker restart sysndd_api && sleep 10
   curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/health/ready
   # Should return 200 if migrations are current

   curl -s http://localhost:3000/health/ready | jq .
   # Should return JSON with status, pending_migrations, total_migrations, timestamp
   ```

4. **Test liveness endpoint still works:**
   ```bash
   curl -s http://localhost:3000/health | jq .
   # Should return healthy status
   ```
</verification>

<success_criteria>
1. GET /health/ready returns HTTP 200 with `{"status": "ready", "pending_migrations": 0, ...}`
2. GET /health/ready returns HTTP 503 if migration_status is not set
3. GET /health/ready is accessible without Bearer token
4. Existing /health endpoint unchanged and still works
5. Response includes timestamp and total_migrations for monitoring
</success_criteria>

<output>
After completion, create `.planning/phases/48-migration-auto-run-health/48-02-SUMMARY.md`
</output>
