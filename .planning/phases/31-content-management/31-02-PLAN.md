---
phase: 31-content-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/package.json
  - app/src/types/cms.ts
  - app/src/types/index.ts
  - app/src/composables/useMarkdownRenderer.ts
  - app/src/composables/useCmsContent.ts
  - app/src/composables/index.ts
autonomous: true

must_haves:
  truths:
    - "markdown-it, dompurify, vue-dompurify-html, vuedraggable@next are installed"
    - "TypeScript interfaces define CMS data structures"
    - "useMarkdownRenderer converts markdown to sanitized HTML with 300ms debounce"
    - "useCmsContent provides API integration for draft/publish workflow"
  artifacts:
    - path: "app/src/types/cms.ts"
      provides: "CMS TypeScript interfaces"
      exports: ["AboutSection", "AboutDraft", "AboutPublished"]
    - path: "app/src/composables/useMarkdownRenderer.ts"
      provides: "Markdown to HTML with sanitization"
      exports: ["useMarkdownRenderer"]
    - path: "app/src/composables/useCmsContent.ts"
      provides: "CMS API integration"
      exports: ["useCmsContent"]
  key_links:
    - from: "app/src/composables/useMarkdownRenderer.ts"
      to: "markdown-it"
      via: "import"
      pattern: "from 'markdown-it'"
    - from: "app/src/composables/useCmsContent.ts"
      to: "/api/about"
      via: "axios calls"
      pattern: "/api/about"
---

<objective>
Install CMS libraries and create TypeScript types and composables for markdown rendering and API integration.

Purpose: Establish the frontend foundation (libraries, types, composables) that all CMS components will depend on. This enables clean separation between data logic and UI.
Output: Installed dependencies, TypeScript interfaces, and two composables (useMarkdownRenderer, useCmsContent).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-content-management/31-CONTEXT.md
@.planning/phases/31-content-management/31-RESEARCH.md

# Relevant source patterns
@app/src/composables/useFormDraft.ts (composable pattern)
@app/src/types/index.ts (type exports pattern)
@app/package.json (current dependencies)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install CMS dependencies</name>
  <files>app/package.json</files>
  <action>
Install the required libraries from the research document:

```bash
cd /home/bernt-popp/development/sysndd/app
npm install markdown-it dompurify vue-dompurify-html vuedraggable@next
npm install -D @types/dompurify @types/markdown-it
```

This adds:
- markdown-it: Markdown parsing to HTML
- dompurify: XSS sanitization for rendered HTML
- vue-dompurify-html: Safe v-html directive replacement
- vuedraggable@next: Drag-and-drop for section reordering
- Type definitions for TypeScript support

Do NOT install any rich text editor libraries (no TipTap, no md-editor-v3). Per CONTEXT.md decisions, we use plain textarea + toolbar.
  </action>
  <verify>npm ls markdown-it dompurify vue-dompurify-html vuedraggable@next shows all installed</verify>
  <done>All 4 runtime dependencies and 2 dev dependencies installed in package.json</done>
</task>

<task type="auto">
  <name>Task 2: Create CMS TypeScript types</name>
  <files>app/src/types/cms.ts, app/src/types/index.ts</files>
  <action>
Create app/src/types/cms.ts with interfaces for CMS data structures:

```typescript
// types/cms.ts
/**
 * CMS-related TypeScript interfaces for About page content management.
 */

/**
 * Single section in the About page content.
 * Maps to accordion sections in the public About.vue.
 */
export interface AboutSection {
  section_id: string;        // Unique ID (e.g., 'creators', 'citation')
  title: string;             // Display title
  icon: string;              // Bootstrap icon class (e.g., 'bi-people')
  content: string;           // Markdown content
  sort_order: number;        // Display order (0-indexed)
}

/**
 * Draft content for a specific user.
 * Each admin has their own isolated draft.
 */
export interface AboutDraft {
  id: number;
  user_id: number;
  sections: AboutSection[];
  status: 'draft';
  created_at: string;
  updated_at: string;
}

/**
 * Published content with version tracking.
 */
export interface AboutPublished {
  id: number;
  user_id: number;
  sections: AboutSection[];
  status: 'published';
  version: number;
  published_at: string;
  created_at: string;
  updated_at: string;
}

/**
 * API response when loading draft (may be draft or published as fallback).
 */
export type AboutContent = AboutDraft | AboutPublished;

/**
 * Toolbar action for markdown editor.
 */
export interface ToolbarAction {
  icon: string;              // Bootstrap icon class
  title: string;             // Tooltip text
  prefix: string;            // Text before selection
  suffix: string;            // Text after selection
  placeholder?: string;      // Default text if no selection
}

/**
 * Curated list of icons for section selection.
 * Limited set to avoid overwhelming users.
 */
export const SECTION_ICONS = [
  'bi-people',
  'bi-journal-text',
  'bi-cash-stack',
  'bi-megaphone',
  'bi-award',
  'bi-shield-exclamation',
  'bi-envelope',
  'bi-info-circle',
  'bi-question-circle',
  'bi-book',
  'bi-gear',
  'bi-graph-up',
  'bi-building',
  'bi-globe',
  'bi-link',
  'bi-file-text',
  'bi-chat-dots',
  'bi-calendar',
  'bi-clock',
  'bi-star',
] as const;

export type SectionIcon = typeof SECTION_ICONS[number];
```

Update app/src/types/index.ts to export CMS types:
- Add `export * from './cms';` line
  </action>
  <verify>tsc --noEmit completes without errors for types/cms.ts</verify>
  <done>CMS types exported from types/index.ts, AboutSection/AboutDraft/AboutPublished available</done>
</task>

<task type="auto">
  <name>Task 3: Create useMarkdownRenderer and useCmsContent composables</name>
  <files>app/src/composables/useMarkdownRenderer.ts, app/src/composables/useCmsContent.ts, app/src/composables/index.ts</files>
  <action>
Create app/src/composables/useMarkdownRenderer.ts:

```typescript
// composables/useMarkdownRenderer.ts
/**
 * Composable for markdown rendering with XSS sanitization.
 * Uses markdown-it for parsing and DOMPurify for security.
 */
import { ref, watch } from 'vue';
import { useDebounceFn } from '@vueuse/core';
import MarkdownIt from 'markdown-it';
import DOMPurify from 'dompurify';

// Configure markdown-it with safe defaults
const md = new MarkdownIt({
  html: false,        // Disable raw HTML in source
  breaks: true,       // Convert \n to <br>
  linkify: true,      // Auto-link URLs
  typographer: true,  // Smart quotes and dashes
});

// Configure DOMPurify allowlist
const SANITIZE_CONFIG = {
  ALLOWED_TAGS: [
    'p', 'br', 'strong', 'b', 'em', 'i', 'a',
    'ul', 'ol', 'li', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
    'blockquote', 'code', 'pre', 'hr',
    'table', 'thead', 'tbody', 'tr', 'th', 'td',
  ],
  ALLOWED_ATTR: ['href', 'target', 'rel', 'class'],
  ADD_ATTR: ['target'],
  FORBID_TAGS: ['script', 'style', 'iframe', 'form', 'input'],
  FORBID_ATTR: ['onerror', 'onclick', 'onload'],
};

/**
 * Render markdown to sanitized HTML.
 * @param source - Markdown source string
 * @returns Sanitized HTML string
 */
export function renderMarkdown(source: string): string {
  const rawHtml = md.render(source);
  return DOMPurify.sanitize(rawHtml, SANITIZE_CONFIG);
}

/**
 * Composable providing reactive markdown rendering with debounce.
 * @param debounceMs - Debounce delay in milliseconds (default: 300)
 */
export function useMarkdownRenderer(debounceMs = 300) {
  const rawMarkdown = ref('');
  const renderedHtml = ref('');
  const isRendering = ref(false);

  const debouncedRender = useDebounceFn((source: string) => {
    isRendering.value = true;
    renderedHtml.value = renderMarkdown(source);
    isRendering.value = false;
  }, debounceMs);

  watch(rawMarkdown, (newVal) => {
    debouncedRender(newVal);
  });

  /**
   * Immediately render without debounce (for initial load).
   */
  function renderImmediate(source: string): string {
    const html = renderMarkdown(source);
    renderedHtml.value = html;
    return html;
  }

  return {
    rawMarkdown,
    renderedHtml,
    isRendering,
    renderImmediate,
    renderMarkdown,  // Export static function too
  };
}

export default useMarkdownRenderer;
```

Create app/src/composables/useCmsContent.ts:

```typescript
// composables/useCmsContent.ts
/**
 * Composable for CMS content API integration.
 * Handles draft save/load and publish workflow.
 */
import { ref, computed } from 'vue';
import axios from 'axios';
import type { AboutSection, AboutContent } from '@/types';

const API_URL = import.meta.env.VITE_API_URL || '';

/**
 * Composable for About page CMS content management.
 */
export function useCmsContent() {
  const sections = ref<AboutSection[]>([]);
  const isLoading = ref(false);
  const isSaving = ref(false);
  const isPublishing = ref(false);
  const error = ref<string | null>(null);
  const lastSavedAt = ref<Date | null>(null);
  const currentVersion = ref<number | null>(null);
  const isDraft = ref(false);

  const hasUnsavedChanges = computed(() => {
    // Compare with last saved state (simplified: just track via lastSavedAt)
    return lastSavedAt.value === null && sections.value.length > 0;
  });

  /**
   * Get auth header from localStorage.
   */
  function getAuthHeader() {
    const token = localStorage.getItem('token');
    return token ? { Authorization: `Bearer ${token}` } : {};
  }

  /**
   * Load draft or published content for editing.
   */
  async function loadDraft(): Promise<void> {
    isLoading.value = true;
    error.value = null;

    try {
      const response = await axios.get<AboutContent>(
        `${API_URL}/api/about/draft`,
        { headers: getAuthHeader() }
      );

      if (response.data && response.data.sections) {
        sections.value = response.data.sections;
        isDraft.value = response.data.status === 'draft';
        if ('version' in response.data) {
          currentVersion.value = response.data.version;
        }
        lastSavedAt.value = new Date();
      } else {
        // No content exists, start with empty sections
        sections.value = [];
        isDraft.value = true;
      }
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Failed to load content';
      console.error('Failed to load draft:', err);
    } finally {
      isLoading.value = false;
    }
  }

  /**
   * Save current sections as draft.
   */
  async function saveDraft(): Promise<boolean> {
    if (sections.value.length === 0) {
      error.value = 'Cannot save empty content';
      return false;
    }

    isSaving.value = true;
    error.value = null;

    try {
      await axios.put(
        `${API_URL}/api/about/draft`,
        { sections: sections.value },
        { headers: getAuthHeader() }
      );

      lastSavedAt.value = new Date();
      isDraft.value = true;
      return true;
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Failed to save draft';
      console.error('Failed to save draft:', err);
      return false;
    } finally {
      isSaving.value = false;
    }
  }

  /**
   * Publish current sections (creates new version).
   */
  async function publish(): Promise<boolean> {
    if (sections.value.length === 0) {
      error.value = 'Cannot publish empty content';
      return false;
    }

    isPublishing.value = true;
    error.value = null;

    try {
      const response = await axios.post<{ message: string; version: number }>(
        `${API_URL}/api/about/publish`,
        { sections: sections.value },
        { headers: getAuthHeader() }
      );

      currentVersion.value = response.data.version;
      lastSavedAt.value = new Date();
      isDraft.value = false;
      return true;
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Failed to publish';
      console.error('Failed to publish:', err);
      return false;
    } finally {
      isPublishing.value = false;
    }
  }

  /**
   * Load published content (for public About page).
   */
  async function loadPublished(): Promise<AboutSection[]> {
    isLoading.value = true;
    error.value = null;

    try {
      const response = await axios.get<{ sections: AboutSection[] }>(
        `${API_URL}/api/about/published`
      );

      return response.data?.sections || [];
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Failed to load content';
      console.error('Failed to load published content:', err);
      return [];
    } finally {
      isLoading.value = false;
    }
  }

  /**
   * Add a new section.
   */
  function addSection(section: Omit<AboutSection, 'sort_order'>): void {
    const newSection: AboutSection = {
      ...section,
      sort_order: sections.value.length,
    };
    sections.value = [...sections.value, newSection];
  }

  /**
   * Update an existing section.
   */
  function updateSection(index: number, updates: Partial<AboutSection>): void {
    if (index >= 0 && index < sections.value.length) {
      const updated = [...sections.value];
      updated[index] = { ...updated[index], ...updates };
      sections.value = updated;
    }
  }

  /**
   * Remove a section.
   */
  function removeSection(index: number): void {
    if (index >= 0 && index < sections.value.length) {
      const updated = sections.value.filter((_, i) => i !== index);
      // Recalculate sort_order
      sections.value = updated.map((s, i) => ({ ...s, sort_order: i }));
    }
  }

  /**
   * Reorder sections (for drag-and-drop).
   */
  function reorderSections(newOrder: AboutSection[]): void {
    sections.value = newOrder.map((s, i) => ({ ...s, sort_order: i }));
  }

  return {
    // State
    sections,
    isLoading,
    isSaving,
    isPublishing,
    error,
    lastSavedAt,
    currentVersion,
    isDraft,
    hasUnsavedChanges,

    // Methods
    loadDraft,
    saveDraft,
    publish,
    loadPublished,
    addSection,
    updateSection,
    removeSection,
    reorderSections,
  };
}

export default useCmsContent;
```

Update app/src/composables/index.ts to export new composables:
- Add `export { useMarkdownRenderer, renderMarkdown } from './useMarkdownRenderer';`
- Add `export { useCmsContent } from './useCmsContent';`
  </action>
  <verify>npm run type-check passes without errors</verify>
  <done>useMarkdownRenderer and useCmsContent composables exported and type-safe</done>
</task>

</tasks>

<verification>
1. npm ls shows markdown-it, dompurify, vue-dompurify-html, vuedraggable@next installed
2. types/cms.ts defines AboutSection, AboutDraft, AboutPublished interfaces
3. useMarkdownRenderer provides debounced markdown rendering with sanitization
4. useCmsContent provides full CRUD operations for CMS content
5. npm run type-check passes
</verification>

<success_criteria>
- All required npm packages installed
- TypeScript types compile without errors
- Composables follow existing patterns (useFormDraft, etc.)
- No runtime errors when importing composables
</success_criteria>

<output>
After completion, create `.planning/phases/31-content-management/31-02-SUMMARY.md`
</output>
