---
phase: 31-content-management
plan: 03
type: execute
wave: 2
depends_on:
  - 31-02
files_modified:
  - app/src/components/cms/MarkdownEditor.vue
  - app/src/components/cms/MarkdownPreview.vue
  - app/src/components/cms/SectionEditor.vue
  - app/src/components/cms/SectionList.vue
  - app/src/components/cms/MarkdownCheatsheet.vue
autonomous: true

must_haves:
  truths:
    - "MarkdownEditor has textarea with toolbar buttons for formatting"
    - "MarkdownPreview shows rendered HTML with scroll sync"
    - "SectionEditor allows editing title, icon, and content"
    - "SectionList supports drag-and-drop reordering"
    - "MarkdownCheatsheet shows collapsible syntax reference"
  artifacts:
    - path: "app/src/components/cms/MarkdownEditor.vue"
      provides: "Textarea with formatting toolbar"
      min_lines: 100
    - path: "app/src/components/cms/MarkdownPreview.vue"
      provides: "Rendered HTML preview"
      min_lines: 50
    - path: "app/src/components/cms/SectionEditor.vue"
      provides: "Single section editing"
      min_lines: 80
    - path: "app/src/components/cms/SectionList.vue"
      provides: "Draggable section list"
      min_lines: 60
    - path: "app/src/components/cms/MarkdownCheatsheet.vue"
      provides: "Syntax reference panel"
      min_lines: 40
  key_links:
    - from: "app/src/components/cms/MarkdownEditor.vue"
      to: "useMarkdownRenderer"
      via: "import composable"
      pattern: "useMarkdownRenderer"
    - from: "app/src/components/cms/SectionList.vue"
      to: "vuedraggable"
      via: "import"
      pattern: "from 'vuedraggable'"
---

<objective>
Create CMS UI components: MarkdownEditor, MarkdownPreview, SectionEditor, SectionList, and MarkdownCheatsheet.

Purpose: Build the reusable UI components that ManageAbout.vue will compose to create the full CMS editor experience. Each component has a single responsibility.
Output: Five Vue components in app/src/components/cms/ directory.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-content-management/31-CONTEXT.md
@.planning/phases/31-content-management/31-RESEARCH.md
@.planning/phases/31-content-management/31-02-SUMMARY.md

# Relevant patterns
@app/src/composables/useMarkdownRenderer.ts (rendering composable)
@app/src/types/cms.ts (TypeScript interfaces)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MarkdownEditor and MarkdownPreview components</name>
  <files>app/src/components/cms/MarkdownEditor.vue, app/src/components/cms/MarkdownPreview.vue</files>
  <action>
Create app/src/components/cms/ directory if not exists.

Create MarkdownEditor.vue - textarea with formatting toolbar:

```vue
<template>
  <div class="markdown-editor">
    <!-- Toolbar -->
    <div class="toolbar d-flex flex-wrap gap-1 mb-2 p-2 bg-light rounded border">
      <BButton
        v-for="action in toolbarActions"
        :key="action.title"
        size="sm"
        variant="outline-secondary"
        :title="action.title"
        @click="insertFormatting(action)"
      >
        <i :class="action.icon" />
      </BButton>
      <div class="vr mx-2" />
      <BButton
        size="sm"
        variant="outline-info"
        title="Markdown Help"
        @click="showCheatsheet = !showCheatsheet"
      >
        <i class="bi bi-question-circle" />
      </BButton>
    </div>

    <!-- Cheatsheet (collapsible) -->
    <BCollapse v-model="showCheatsheet" class="mb-2">
      <MarkdownCheatsheet />
    </BCollapse>

    <!-- Textarea -->
    <BFormTextarea
      ref="textareaRef"
      v-model="localContent"
      class="markdown-textarea"
      :rows="rows"
      :style="{ minHeight: minHeight, maxHeight: maxHeight, resize: 'vertical' }"
      placeholder="Enter markdown content..."
      @blur="$emit('blur')"
      @input="onInput"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, watch, computed } from 'vue';
import type { ToolbarAction } from '@/types';
import MarkdownCheatsheet from './MarkdownCheatsheet.vue';

const props = withDefaults(defineProps<{
  modelValue: string;
  rows?: number;
  minHeight?: string;
  maxHeight?: string;
}>(), {
  rows: 15,
  minHeight: '300px',
  maxHeight: '500px',
});

const emit = defineEmits<{
  'update:modelValue': [value: string];
  'blur': [];
}>();

const textareaRef = ref<HTMLTextAreaElement | null>(null);
const showCheatsheet = ref(false);
const localContent = ref(props.modelValue);

// Sync with v-model
watch(() => props.modelValue, (newVal) => {
  if (newVal !== localContent.value) {
    localContent.value = newVal;
  }
});

function onInput() {
  emit('update:modelValue', localContent.value);
}

// Toolbar actions per CONTEXT.md: bold, italic, link, headers, lists
const toolbarActions: ToolbarAction[] = [
  { icon: 'bi bi-type-bold', title: 'Bold (Ctrl+B)', prefix: '**', suffix: '**', placeholder: 'bold text' },
  { icon: 'bi bi-type-italic', title: 'Italic (Ctrl+I)', prefix: '_', suffix: '_', placeholder: 'italic text' },
  { icon: 'bi bi-link', title: 'Link', prefix: '[', suffix: '](url)', placeholder: 'link text' },
  { icon: 'bi bi-type-h1', title: 'Heading 1', prefix: '# ', suffix: '', placeholder: '' },
  { icon: 'bi bi-type-h2', title: 'Heading 2', prefix: '## ', suffix: '', placeholder: '' },
  { icon: 'bi bi-type-h3', title: 'Heading 3', prefix: '### ', suffix: '', placeholder: '' },
  { icon: 'bi bi-list-ul', title: 'Bullet List', prefix: '- ', suffix: '', placeholder: '' },
  { icon: 'bi bi-list-ol', title: 'Numbered List', prefix: '1. ', suffix: '', placeholder: '' },
  { icon: 'bi bi-quote', title: 'Blockquote', prefix: '> ', suffix: '', placeholder: '' },
  { icon: 'bi bi-code', title: 'Code', prefix: '`', suffix: '`', placeholder: 'code' },
];

function insertFormatting(action: ToolbarAction) {
  const textarea = textareaRef.value?.$el || textareaRef.value;
  if (!textarea) return;

  const start = textarea.selectionStart;
  const end = textarea.selectionEnd;
  const selectedText = localContent.value.substring(start, end) || action.placeholder || '';
  const replacement = `${action.prefix}${selectedText}${action.suffix}`;

  localContent.value =
    localContent.value.substring(0, start) +
    replacement +
    localContent.value.substring(end);

  emit('update:modelValue', localContent.value);

  // Restore cursor position
  const newCursorPos = start + action.prefix.length + selectedText.length;
  setTimeout(() => {
    textarea.focus();
    textarea.setSelectionRange(newCursorPos, newCursorPos);
  }, 0);
}
</script>

<style scoped>
.markdown-textarea {
  font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace;
  font-size: 0.9rem;
  line-height: 1.6;
  tab-size: 2;
}

.toolbar .btn {
  min-width: 32px;
}
</style>
```

Create MarkdownPreview.vue - rendered HTML with sanitization:

```vue
<template>
  <div
    ref="previewRef"
    class="markdown-preview p-3 border rounded bg-white"
    :style="{ minHeight: minHeight, maxHeight: maxHeight, overflowY: 'auto' }"
  >
    <div v-if="isRendering" class="text-center text-muted py-4">
      <BSpinner small class="me-2" />
      Rendering...
    </div>
    <div
      v-else-if="renderedHtml"
      class="markdown-content"
      v-dompurify-html="renderedHtml"
    />
    <div v-else class="text-muted fst-italic py-4 text-center">
      Preview will appear here as you type...
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, watch, onMounted } from 'vue';
import { useMarkdownRenderer } from '@/composables';
import VueDOMPurifyHTML from 'vue-dompurify-html';

const props = withDefaults(defineProps<{
  content: string;
  minHeight?: string;
  maxHeight?: string;
}>(), {
  minHeight: '300px',
  maxHeight: '500px',
});

const previewRef = ref<HTMLElement | null>(null);
const { rawMarkdown, renderedHtml, isRendering, renderImmediate } = useMarkdownRenderer();

// Sync content with renderer
watch(() => props.content, (newVal) => {
  rawMarkdown.value = newVal;
}, { immediate: true });

// Initial render without debounce
onMounted(() => {
  if (props.content) {
    renderImmediate(props.content);
  }
});
</script>

<style scoped>
.markdown-preview {
  word-wrap: break-word;
}

.markdown-content :deep(h1) {
  font-size: 1.5rem;
  border-bottom: 1px solid #dee2e6;
  padding-bottom: 0.3rem;
  margin-bottom: 1rem;
}

.markdown-content :deep(h2) {
  font-size: 1.3rem;
  margin-top: 1.5rem;
  margin-bottom: 0.75rem;
}

.markdown-content :deep(h3) {
  font-size: 1.1rem;
  margin-top: 1.25rem;
  margin-bottom: 0.5rem;
}

.markdown-content :deep(p) {
  margin-bottom: 0.75rem;
}

.markdown-content :deep(ul),
.markdown-content :deep(ol) {
  padding-left: 1.5rem;
  margin-bottom: 0.75rem;
}

.markdown-content :deep(blockquote) {
  border-left: 4px solid var(--bs-primary);
  padding-left: 1rem;
  margin-left: 0;
  color: var(--bs-secondary);
}

.markdown-content :deep(code) {
  background: #f4f4f4;
  padding: 0.125rem 0.25rem;
  border-radius: 0.25rem;
  font-size: 0.875em;
}

.markdown-content :deep(pre) {
  background: #f4f4f4;
  padding: 1rem;
  border-radius: 0.375rem;
  overflow-x: auto;
}

.markdown-content :deep(a) {
  color: var(--bs-primary);
}

.markdown-content :deep(hr) {
  margin: 1.5rem 0;
}

.markdown-content :deep(table) {
  width: 100%;
  margin-bottom: 1rem;
  border-collapse: collapse;
}

.markdown-content :deep(th),
.markdown-content :deep(td) {
  border: 1px solid #dee2e6;
  padding: 0.5rem;
}

.markdown-content :deep(th) {
  background: #f8f9fa;
}
</style>
```

Note: MarkdownPreview uses vue-dompurify-html directive. Register it in app's main.ts if not already (or use local directive registration).
  </action>
  <verify>Both component files exist and have no TypeScript errors (npm run type-check)</verify>
  <done>MarkdownEditor and MarkdownPreview components ready for use</done>
</task>

<task type="auto">
  <name>Task 2: Create SectionEditor and SectionList components</name>
  <files>app/src/components/cms/SectionEditor.vue, app/src/components/cms/SectionList.vue</files>
  <action>
Create SectionEditor.vue - single section editing (title, icon, content):

```vue
<template>
  <BCard class="section-editor mb-3" :class="{ 'border-primary': isExpanded }">
    <template #header>
      <div class="d-flex align-items-center gap-2">
        <!-- Drag handle -->
        <span class="drag-handle text-muted" title="Drag to reorder">
          <i class="bi bi-grip-vertical" />
        </span>

        <!-- Section icon preview -->
        <i :class="section.icon" class="fs-5" />

        <!-- Section title (editable inline when expanded) -->
        <div class="flex-grow-1">
          <strong v-if="!isExpanded">{{ section.title || 'Untitled Section' }}</strong>
          <BFormInput
            v-else
            v-model="localSection.title"
            size="sm"
            placeholder="Section title"
            @update:model-value="emitUpdate"
          />
        </div>

        <!-- Actions -->
        <div class="d-flex gap-1">
          <BButton
            size="sm"
            :variant="isExpanded ? 'primary' : 'outline-secondary'"
            @click="isExpanded = !isExpanded"
          >
            <i :class="isExpanded ? 'bi bi-chevron-up' : 'bi bi-chevron-down'" />
          </BButton>
          <BButton
            size="sm"
            variant="outline-danger"
            title="Delete section"
            @click="$emit('delete')"
          >
            <i class="bi bi-trash" />
          </BButton>
        </div>
      </div>
    </template>

    <BCollapse v-model="isExpanded">
      <BCardBody>
        <!-- Icon selector -->
        <BFormGroup label="Icon" label-cols="2" class="mb-3">
          <BFormSelect
            v-model="localSection.icon"
            :options="iconOptions"
            size="sm"
            @update:model-value="emitUpdate"
          />
        </BFormGroup>

        <!-- Side-by-side editor and preview -->
        <BRow>
          <BCol md="6">
            <label class="form-label fw-semibold">Content (Markdown)</label>
            <MarkdownEditor
              v-model="localSection.content"
              :rows="12"
              min-height="250px"
              max-height="400px"
              @update:model-value="emitUpdate"
              @blur="$emit('blur')"
            />
          </BCol>
          <BCol md="6">
            <label class="form-label fw-semibold">Preview</label>
            <MarkdownPreview
              :content="localSection.content"
              min-height="250px"
              max-height="400px"
            />
          </BCol>
        </BRow>
      </BCardBody>
    </BCollapse>
  </BCard>
</template>

<script setup lang="ts">
import { ref, watch, computed } from 'vue';
import type { AboutSection } from '@/types';
import { SECTION_ICONS } from '@/types/cms';
import MarkdownEditor from './MarkdownEditor.vue';
import MarkdownPreview from './MarkdownPreview.vue';

const props = defineProps<{
  section: AboutSection;
  expanded?: boolean;
}>();

const emit = defineEmits<{
  'update': [section: AboutSection];
  'delete': [];
  'blur': [];
}>();

const isExpanded = ref(props.expanded ?? false);
const localSection = ref<AboutSection>({ ...props.section });

// Sync with prop changes
watch(() => props.section, (newVal) => {
  localSection.value = { ...newVal };
}, { deep: true });

function emitUpdate() {
  emit('update', { ...localSection.value });
}

// Icon options for dropdown
const iconOptions = computed(() =>
  SECTION_ICONS.map(icon => ({
    value: icon,
    text: icon.replace('bi-', '').replace(/-/g, ' '),
  }))
);
</script>

<style scoped>
.drag-handle {
  cursor: grab;
  padding: 0.25rem;
}

.drag-handle:active {
  cursor: grabbing;
}

.section-editor.ghost {
  opacity: 0.5;
  background: var(--bs-primary-bg-subtle);
}
</style>
```

Create SectionList.vue - draggable section list using vuedraggable:

```vue
<template>
  <div class="section-list">
    <draggable
      v-model="localSections"
      item-key="section_id"
      handle=".drag-handle"
      animation="200"
      ghost-class="ghost"
      @change="onOrderChange"
    >
      <template #item="{ element, index }">
        <SectionEditor
          :section="element"
          :expanded="expandedIndex === index"
          @update="(updated) => updateSection(index, updated)"
          @delete="deleteSection(index)"
          @blur="$emit('section-blur')"
        />
      </template>
    </draggable>

    <!-- Add section button -->
    <div class="text-center mt-3">
      <BButton variant="outline-primary" @click="addSection">
        <i class="bi bi-plus-lg me-1" />
        Add Section
      </BButton>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, watch } from 'vue';
import draggable from 'vuedraggable';
import type { AboutSection } from '@/types';
import SectionEditor from './SectionEditor.vue';

const props = defineProps<{
  sections: AboutSection[];
}>();

const emit = defineEmits<{
  'update:sections': [sections: AboutSection[]];
  'section-blur': [];
}>();

const localSections = ref<AboutSection[]>([...props.sections]);
const expandedIndex = ref<number | null>(null);

// Sync with parent
watch(() => props.sections, (newVal) => {
  localSections.value = [...newVal];
}, { deep: true });

function emitUpdate() {
  // Recalculate sort_order
  const updated = localSections.value.map((s, i) => ({
    ...s,
    sort_order: i,
  }));
  emit('update:sections', updated);
}

function onOrderChange() {
  emitUpdate();
}

function updateSection(index: number, updated: AboutSection) {
  localSections.value[index] = updated;
  emitUpdate();
}

function deleteSection(index: number) {
  localSections.value.splice(index, 1);
  emitUpdate();
}

function addSection() {
  const newId = `section-${Date.now()}`;
  const newSection: AboutSection = {
    section_id: newId,
    title: 'New Section',
    icon: 'bi-info-circle',
    content: '',
    sort_order: localSections.value.length,
  };
  localSections.value.push(newSection);
  expandedIndex.value = localSections.value.length - 1;
  emitUpdate();
}
</script>

<style scoped>
.ghost {
  opacity: 0.5;
  background: var(--bs-primary-bg-subtle);
  border-color: var(--bs-primary) !important;
}
</style>
```
  </action>
  <verify>Both component files exist and have proper TypeScript types</verify>
  <done>SectionEditor and SectionList components with drag-and-drop support</done>
</task>

<task type="auto">
  <name>Task 3: Create MarkdownCheatsheet component</name>
  <files>app/src/components/cms/MarkdownCheatsheet.vue</files>
  <action>
Create MarkdownCheatsheet.vue - collapsible markdown syntax reference:

```vue
<template>
  <BCard class="markdown-cheatsheet bg-light">
    <BCardBody class="py-2">
      <h6 class="mb-2 fw-semibold">
        <i class="bi bi-markdown me-1" />
        Markdown Quick Reference
      </h6>
      <BRow>
        <BCol sm="6" md="4">
          <h6 class="small text-muted mb-1">Text Formatting</h6>
          <ul class="list-unstyled small mb-2">
            <li><code>**bold**</code> = <strong>bold</strong></li>
            <li><code>_italic_</code> = <em>italic</em></li>
            <li><code>`code`</code> = <code>code</code></li>
            <li><code>~~strike~~</code> = <s>strike</s></li>
          </ul>
        </BCol>
        <BCol sm="6" md="4">
          <h6 class="small text-muted mb-1">Headers</h6>
          <ul class="list-unstyled small mb-2">
            <li><code># Heading 1</code></li>
            <li><code>## Heading 2</code></li>
            <li><code>### Heading 3</code></li>
          </ul>
        </BCol>
        <BCol sm="6" md="4">
          <h6 class="small text-muted mb-1">Lists</h6>
          <ul class="list-unstyled small mb-2">
            <li><code>- Item</code> (bullet)</li>
            <li><code>1. Item</code> (numbered)</li>
            <li><code>- [ ] Task</code> (checkbox)</li>
          </ul>
        </BCol>
        <BCol sm="6" md="4">
          <h6 class="small text-muted mb-1">Links & Images</h6>
          <ul class="list-unstyled small mb-2">
            <li><code>[text](url)</code> = link</li>
            <li><code>![alt](url)</code> = image</li>
          </ul>
        </BCol>
        <BCol sm="6" md="4">
          <h6 class="small text-muted mb-1">Blockquote</h6>
          <ul class="list-unstyled small mb-2">
            <li><code>> Quote text</code></li>
            <li><code>---</code> = horizontal line</li>
          </ul>
        </BCol>
        <BCol sm="6" md="4">
          <h6 class="small text-muted mb-1">Code Block</h6>
          <ul class="list-unstyled small mb-2">
            <li><code>```</code></li>
            <li><code>code here</code></li>
            <li><code>```</code></li>
          </ul>
        </BCol>
      </BRow>
    </BCardBody>
  </BCard>
</template>

<script setup lang="ts">
// No logic needed - pure presentation component
</script>

<style scoped>
.markdown-cheatsheet code {
  background: #fff;
  padding: 0.125rem 0.375rem;
  border-radius: 0.25rem;
  font-size: 0.8rem;
}

.markdown-cheatsheet ul {
  padding-left: 0;
}

.markdown-cheatsheet li {
  margin-bottom: 0.25rem;
}
</style>
```
  </action>
  <verify>Component file exists and renders correctly</verify>
  <done>MarkdownCheatsheet component provides syntax reference for users</done>
</task>

</tasks>

<verification>
1. All 5 component files exist in app/src/components/cms/
2. Components import from correct paths (@/composables, @/types)
3. npm run type-check passes with no errors
4. MarkdownEditor has toolbar with bold/italic/link/headers/lists buttons
5. MarkdownPreview uses vue-dompurify-html for safe rendering
6. SectionList uses vuedraggable for drag-and-drop
</verification>

<success_criteria>
- All CMS components are created and properly typed
- Components follow Bootstrap-Vue-Next patterns
- Drag-and-drop reordering works via vuedraggable
- Markdown rendering is XSS-safe via DOMPurify
- Side-by-side editor/preview layout per CONTEXT.md decisions
</success_criteria>

<output>
After completion, create `.planning/phases/31-content-management/31-03-SUMMARY.md`
</output>
