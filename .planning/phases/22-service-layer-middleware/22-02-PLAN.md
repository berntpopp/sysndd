---
phase: 22-service-layer-middleware
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - api/services/auth-service.R
  - api/start_sysndd_api.R
autonomous: true

must_haves:
  truths:
    - "auth_signin validates credentials and returns JWT token"
    - "auth_verify confirms token validity and returns user info"
    - "auth_refresh extends token expiry for valid refresh tokens"
    - "Password verification uses both legacy and Argon2id hashing"
  artifacts:
    - path: "api/services/auth-service.R"
      provides: "Authentication business logic"
      exports: ["auth_signin", "auth_verify", "auth_refresh", "auth_validate_token"]
      min_lines: 120
  key_links:
    - from: "api/services/auth-service.R"
      to: "api/core/security.R"
      via: "Uses verify_password for credential validation"
      pattern: "verify_password"
    - from: "api/services/auth-service.R"
      to: "pool"
      via: "Database queries for user lookup (passed as parameter)"
      pattern: "pool"
    - from: "api/services/auth-service.R"
      to: "jose"
      via: "JWT token encoding with jose::jwt_encode_hmac"
      pattern: "jose::jwt_encode_hmac|jwt_decode_hmac"
---

<objective>
Create authentication service layer with business logic for signin, verify, and refresh operations.

Purpose: Extract authentication logic from authentication_endpoints.R into a dedicated service. This follows the thin-endpoint pattern where endpoints parse requests and call services, while services contain business logic. The auth service handles token generation, validation, and password verification.

Output: `api/services/auth-service.R` with core authentication functions, sourced in `start_sysndd_api.R`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-service-layer-middleware/22-RESEARCH.md
@api/endpoints/authentication_endpoints.R
@api/core/security.R
@api/core/errors.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create services directory and auth-service.R</name>
  <files>api/services/auth-service.R</files>
  <action>
Create `api/services/` directory and `auth-service.R` with authentication business logic:

**1. Create directory:**
```bash
mkdir -p api/services
```

**2. Create auth-service.R with these functions:**

**auth_signin(user_name, password, pool, config):**
```r
#' Authenticate user and return JWT token
#'
#' @param user_name Username to authenticate
#' @param password Plain text password
#' @param pool Database connection pool
#' @param config Configuration object with JWT secret and expiry
#' @return List with token, user info, and expires_in
auth_signin <- function(user_name, password, pool, config) {
  # Validate inputs
  if (missing(user_name) || nchar(trimws(user_name)) == 0) {
    stop_for_bad_request("user_name is required")
  }
  if (missing(password) || nchar(password) == 0) {
    stop_for_bad_request("password is required")
  }

  # Look up user
  user <- pool %>%
    tbl("user") %>%
    filter(user_name == !!user_name) %>%
    collect()

  if (nrow(user) == 0) {
    stop_for_unauthorized("Invalid username or password")
  }

  user <- user[1, ]

  # Check account status
  if (user$account_status != "active") {
    stop_for_unauthorized("Account is not active")
  }

  # Verify password using security.R helper (handles legacy + Argon2id)
  if (!verify_password(password, user$password)) {
    stop_for_unauthorized("Invalid username or password")
  }

  # Generate JWT token using jose::jwt_encode_hmac
  token <- auth_generate_token(user, config)

  logger::log_info("User signed in", user_id = user$user_id)

  list(
    access_token = token$access_token,
    refresh_token = token$refresh_token,
    token_type = "Bearer",
    expires_in = config$token_expiry %||% 3600,
    user = list(
      user_id = user$user_id,
      user_name = user$user_name,
      user_role = user$user_role,
      email = user$email
    )
  )
}
```

**auth_verify(jwt, config):**
Validate token and return user info without database lookup.

**auth_refresh(refresh_token, pool, config):**
Generate new access token from valid refresh token.

**auth_generate_token(user, config):**
Internal helper to create JWT with claims using jose::jwt_encode_hmac.

**auth_validate_token(jwt, config):**
Decode and validate JWT using jose::jwt_decode_hmac, return user claims or NULL on error.

**Key implementation details:**
- Accept pool and config as parameters (dependency injection)
- Use verify_password from core/security.R (supports legacy + Argon2id)
- Use jose::jwt_encode_hmac/jwt_decode_hmac for JWT operations
- Use core/errors.R helpers for RFC 9457 errors
- Log authentication events at INFO level
  </action>
  <verify>
- Directory exists: api/services/
- File exists: api/services/auth-service.R
- Contains auth_signin, auth_verify, auth_refresh, auth_generate_token, auth_validate_token
- Uses verify_password from security.R
- Uses jose:: functions for JWT operations
- Uses error helpers from errors.R
  </verify>
  <done>
- services/ directory created
- auth-service.R created with 5 authentication functions
- Dependency injection pattern used (pool, config as params)
  </done>
</task>

<task type="auto">
  <name>Task 2: Source auth-service.R in start_sysndd_api.R</name>
  <files>api/start_sysndd_api.R</files>
  <action>
Add source line for auth-service.R in start_sysndd_api.R.

Insert after the core/ sources (after line ~129, after core/logging_sanitizer.R or core/middleware.R):
```r
# Service layer
source("services/auth-service.R", local = TRUE)
```

This ensures auth-service.R is loaded after:
- Core security modules (verify_password available)
- Database pool (pool variable available)
- Config (dw variable available)
  </action>
  <verify>
- `grep -n "auth-service.R" api/start_sysndd_api.R` shows source line
- Line appears after core/ sources
  </verify>
  <done>
- auth-service.R sourced in start_sysndd_api.R
- Loaded in correct dependency order
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify auth-service syntax and structure</name>
  <files></files>
  <action>
Verify the auth-service.R file has no syntax errors and exports expected functions.

**Verification commands:**
```bash
# Check syntax
Rscript -e "tryCatch({ source('api/services/auth-service.R'); cat('Syntax OK\n') }, error = function(e) cat('Syntax Error:', conditionMessage(e), '\n'))"

# Check function exports (if API is running)
Rscript -e "source('api/services/auth-service.R'); cat('Functions:', paste(c('auth_signin', 'auth_verify', 'auth_refresh') %in% ls(), collapse=', '))"
```

If verification fails due to dependencies (pool not available), note as expected behavior for isolated syntax check.
  </action>
  <verify>
- Syntax check passes or notes expected dependency issues
- Functions defined: auth_signin, auth_verify, auth_refresh
  </verify>
  <done>
- auth-service.R has valid R syntax
- All expected functions are defined
  </done>
</task>

</tasks>

<verification>
- [ ] api/services/ directory exists
- [ ] api/services/auth-service.R exists with ~120+ lines
- [ ] Contains auth_signin, auth_verify, auth_refresh, auth_generate_token
- [ ] Uses jose:: package for JWT encoding/decoding
- [ ] start_sysndd_api.R sources auth-service.R
- [ ] No syntax errors in isolated check
</verification>

<success_criteria>
- Auth service layer provides centralized authentication logic
- Functions accept pool/config as parameters (dependency injection)
- Existing authentication behavior preserved
- Ready for authentication_endpoints.R to call these functions
</success_criteria>

<output>
After completion, create `.planning/phases/22-service-layer-middleware/22-02-SUMMARY.md`
</output>
