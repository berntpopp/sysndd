---
phase: 22-service-layer-middleware
plan: 05
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - api/services/user-service.R
  - api/services/status-service.R
  - api/services/search-service.R
  - api/start_sysndd_api.R
autonomous: true

must_haves:
  truths:
    - "user_get_list returns user list filtered by role permissions"
    - "user_approve handles user approval workflow"
    - "status_create creates new entity status"
    - "search_entities provides entity search functionality"
  artifacts:
    - path: "api/services/user-service.R"
      provides: "User management business logic"
      exports: ["user_get_list", "user_get_by_id", "user_approve", "user_update_role"]
      min_lines: 120
    - path: "api/services/status-service.R"
      provides: "Entity status business logic"
      exports: ["status_create", "status_update"]
      min_lines: 80
    - path: "api/services/search-service.R"
      provides: "Search functionality"
      exports: ["search_entities", "search_genes", "search_phenotypes"]
      min_lines: 60
  key_links:
    - from: "api/services/user-service.R"
      to: "api/endpoints/user_endpoints.R"
      via: "Extracts business logic from user endpoint handlers"
      pattern: "pool.*tbl.*user"
    - from: "api/services/status-service.R"
      to: "database-functions.R"
      via: "Migrates put_post_db_status"
      pattern: "ndd_entity_status"
---

<objective>
Create user, status, and search service layers.

Purpose: Extract remaining business logic from endpoints and database-functions.R into dedicated services. This completes the service layer infrastructure for Phase 22.

Output: `api/services/user-service.R`, `api/services/status-service.R`, and `api/services/search-service.R`, sourced in `start_sysndd_api.R`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-service-layer-middleware/22-RESEARCH.md
@api/functions/database-functions.R (lines 731-857 for status functions)
@api/endpoints/user_endpoints.R
@api/endpoints/search_endpoints.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create user-service.R</name>
  <files>api/services/user-service.R</files>
  <action>
Create `api/services/user-service.R` with user management logic.

**Functions to implement:**

**1. user_get_list(requesting_role, pool):**
Returns user list based on requesting user's role:
```r
#' Get user list filtered by requester's permissions
#'
#' @param requesting_role Role of user making request
#' @param pool Database connection pool
#' @return Tibble of users (filtered by role visibility)
user_get_list <- function(requesting_role, pool) {
  base_query <- pool %>%
    tbl("user") %>%
    filter(account_status == "active")

  if (requesting_role == "Administrator") {
    # Admins see all users with full details
    base_query %>%
      select(user_id, user_name, email, user_role, orcid_id, abbreviation) %>%
      collect()
  } else if (requesting_role == "Curator") {
    # Curators see reviewers/viewers
    base_query %>%
      filter(user_role %in% c("Reviewer", "Viewer")) %>%
      select(user_id, user_name, user_role) %>%
      collect()
  } else {
    # Reviewers/Viewers see limited info
    base_query %>%
      select(user_id, user_name) %>%
      collect()
  }
}
```

**2. user_get_by_id(user_id, pool):**
Get single user by ID.

**3. user_approve(user_id, approving_user_id, approve, pool):**
Approve or reject user registration:
- Sets account_status to "active" or "rejected"
- Records approving_user_id

**4. user_update_role(user_id, new_role, requesting_role, pool):**
Update user role with permission checks:
- Administrator can set any role
- Curator can promote to Reviewer only
- Returns error for invalid role changes

**5. user_change_password(user_id, old_password, new_password, requesting_role, pool):**
Change user password:
- Admin can change any password without old_password
- Others must provide correct old_password
- Uses hash_password from security.R
  </action>
  <verify>
- File exists: api/services/user-service.R
- Contains user_get_list, user_get_by_id, user_approve, user_update_role
- Uses pool for database
  </verify>
  <done>
- user-service.R created with 5 user functions
- Role-based filtering implemented
  </done>
</task>

<task type="auto">
  <name>Task 2: Create status-service.R</name>
  <files>api/services/status-service.R</files>
  <action>
Create `api/services/status-service.R` with entity status logic.

**Functions to implement:**

**1. status_create(status_data, pool, re_review = FALSE):**
Creates new entity status:
- Validates category_id present
- Inserts into ndd_entity_status
- If re_review, updates re_review_entity_connect
- Based on put_post_db_status POST branch

**2. status_update(status_data, pool):**
Updates existing status:
- Validates status_id present
- Builds parameterized UPDATE
- Based on put_post_db_status PUT branch

**Key implementation:**
```r
#' Create entity status
#'
#' @param status_data List with entity_id, category_id, etc.
#' @param pool Database connection pool
#' @param re_review Logical - is this a re-review status
#' @return List with status, message, entry
status_create <- function(status_data, pool, re_review = FALSE) {
  # Validate
  if (!("category_id" %in% names(status_data))) {
    stop_for_bad_request("category_id is required")
  }

  # Prepare data
  status_tibble <- purrr::compact(status_data) %>%
    tibble::as_tibble() %>%
    select(-any_of("status_id"))

  conn <- pool::poolCheckout(pool)
  on.exit(pool::poolReturn(conn), add = TRUE)

  # Insert
  DBI::dbAppendTable(conn, "ndd_entity_status", status_tibble)
  status_id <- DBI::dbGetQuery(conn, "SELECT LAST_INSERT_ID() as status_id")$status_id

  # Re-review update
  if (re_review) {
    DBI::dbExecute(conn,
      "UPDATE re_review_entity_connect SET re_review_status_saved = 1, status_id = ? WHERE entity_id = ?",
      params = list(status_id, status_data$entity_id)
    )
  }

  list(status = 200, message = "OK. Entry created.", entry = status_id)
}
```
  </action>
  <verify>
- File exists: api/services/status-service.R
- Contains status_create, status_update
- Uses pool for database
  </verify>
  <done>
- status-service.R created with status functions
- Handles re-review workflow
  </done>
</task>

<task type="auto">
  <name>Task 3: Create search-service.R and source all services</name>
  <files>api/services/search-service.R, api/start_sysndd_api.R</files>
  <action>
**Create search-service.R:**

Simple search functionality extracted from search_endpoints.R:

```r
#' Search entities by gene symbol or disease
#'
#' @param query Search query string
#' @param pool Database connection pool
#' @return Tibble of matching entities
search_entities <- function(query, pool) {
  if (nchar(query) < 2) {
    stop_for_bad_request("Search query must be at least 2 characters")
  }

  search_pattern <- paste0("%", query, "%")

  pool %>%
    tbl("view_entity_curated") %>%
    filter(
      symbol %like% !!search_pattern |
      disease_ontology_name %like% !!search_pattern
    ) %>%
    head(100) %>%
    collect()
}

#' Search genes
search_genes <- function(query, pool) {
  # Similar pattern
}

#' Search phenotypes
search_phenotypes <- function(query, pool) {
  # Similar pattern
}
```

**Update start_sysndd_api.R:**

Add source lines for all three new services:
```r
source("services/user-service.R", local = TRUE)
source("services/status-service.R", local = TRUE)
source("services/search-service.R", local = TRUE)
```
  </action>
  <verify>
- File exists: api/services/search-service.R
- Contains search_entities, search_genes, search_phenotypes
- `grep -n "user-service.R\|status-service.R\|search-service.R" api/start_sysndd_api.R` shows all three
  </verify>
  <done>
- search-service.R created with search functions
- All three services sourced in start_sysndd_api.R
  </done>
</task>

</tasks>

<verification>
- [ ] api/services/user-service.R exists with ~120+ lines
- [ ] api/services/status-service.R exists with ~80+ lines
- [ ] api/services/search-service.R exists with ~60+ lines
- [ ] All services contain documented functions
- [ ] start_sysndd_api.R sources all three files
- [ ] No syntax errors
</verification>

<success_criteria>
- Complete service layer infrastructure in place
- User service handles user management with role filtering
- Status service handles entity status CRUD
- Search service provides search functionality
- All services use dependency injection (pool as parameter)
</success_criteria>

<output>
After completion, create `.planning/phases/22-service-layer-middleware/22-05-SUMMARY.md`
</output>
