---
phase: 22-service-layer-middleware
plan: 06
type: execute
wave: 3
depends_on: ["22-01", "22-02", "22-05"]
files_modified:
  - api/endpoints/user_endpoints.R
  - api/endpoints/admin_endpoints.R
  - api/endpoints/authentication_endpoints.R
autonomous: true

must_haves:
  truths:
    - "user_endpoints.R uses require_role for authorization checks"
    - "admin_endpoints.R uses require_role for Administrator-only endpoints"
    - "authentication_endpoints.R calls auth-service.R for signin/verify/refresh"
    - "Duplicated role checks eliminated from these files"
  artifacts:
    - path: "api/endpoints/user_endpoints.R"
      provides: "Refactored user endpoints with service layer"
      contains: "require_role"
    - path: "api/endpoints/admin_endpoints.R"
      provides: "Refactored admin endpoints with middleware"
      contains: "require_role"
    - path: "api/endpoints/authentication_endpoints.R"
      provides: "Refactored auth endpoints calling auth-service"
      contains: "auth_signin"
  key_links:
    - from: "api/endpoints/user_endpoints.R"
      to: "api/core/middleware.R"
      via: "Uses require_role for authorization"
      pattern: "require_role"
    - from: "api/endpoints/authentication_endpoints.R"
      to: "api/services/auth-service.R"
      via: "Calls auth service functions"
      pattern: "auth_signin|auth_verify"
---

<objective>
Refactor user, admin, and authentication endpoints to use middleware and service layer.

Purpose: This is the first batch of endpoint refactoring. We start with user management and authentication endpoints because they have the most role checks and will benefit most from the require_role helper.

Output: Refactored endpoints using require_role and service layer functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-service-layer-middleware/22-01-SUMMARY.md
@.planning/phases/22-service-layer-middleware/22-02-SUMMARY.md
@api/core/middleware.R
@api/services/auth-service.R
@api/endpoints/user_endpoints.R
@api/endpoints/admin_endpoints.R
@api/endpoints/authentication_endpoints.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Capture baseline responses for user endpoints</name>
  <files></files>
  <action>
Before refactoring, document current API responses for regression testing.

**Capture baseline (if API running):**
```bash
# GET /api/user/ (unauthenticated)
curl -s http://localhost:7778/api/user/ | head -c 500

# GET /api/user/list (authenticated as Admin - needs valid token)
# Document expected response structure

# POST /api/user/approve (Admin only)
# Document expected 401/403 responses for unauthorized access
```

**Document expected behaviors:**
| Endpoint | Auth Required | Min Role | Expected Response |
|----------|---------------|----------|-------------------|
| GET /api/user/ | No | - | List of active users |
| GET /api/user/list | Yes | Reviewer | Filtered user list by role |
| PUT /api/user/approve | Yes | Curator | Approval result |
| PUT /api/user/role | Yes | Curator | Role update result |
| PUT /api/user/password/change | Yes | self or Admin | Password change result |
| DELETE /api/user/delete | Yes | Administrator | Deletion result |

If API not running, note "baseline captured from code analysis".
  </action>
  <verify>
- Baseline behavior documented
- Expected role requirements identified
  </verify>
  <done>
- Pre-refactoring behavior captured
- Ready for safe refactoring
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor user_endpoints.R to use middleware</name>
  <files>api/endpoints/user_endpoints.R</files>
  <action>
Refactor user_endpoints.R to use require_role and service layer.

**Changes to make:**

1. **Replace scattered role checks with require_role:**

Before (lines ~28, 48, 91, 148, 243, etc.):
```r
if (req$user_role %in% c("Administrator")) {
  # admin logic
} else if (req$user_role %in% c("Curator")) {
  # curator logic
} else {
  # error
}
```

After:
```r
# For endpoints requiring Curator+
require_role(req, res, "Curator")
# proceed with logic
```

2. **Call user-service.R functions:**
Replace inline database queries with service calls:
```r
# Before
users <- pool %>%
  tbl("user") %>%
  filter(account_status == "active") %>%
  collect()

# After
users <- user_get_list(req$user_role, pool)
```

3. **Specific endpoint refactoring:**

**GET /list** (line ~18):
- Add: `require_role(req, res, "Reviewer")`
- Replace inline query with: `user_get_list(req$user_role, pool)`

**PUT /approve** (line ~140):
- Add: `require_role(req, res, "Curator")`
- Call: `user_approve(user_id, req$user_id, user_approved, pool)`

**PUT /role** (line ~230):
- Add: `require_role(req, res, "Curator")`
- Call: `user_update_role(user_id, user_role, req$user_role, pool)`

**DELETE /delete** (line ~640, 700):
- Add: `require_role(req, res, "Administrator")`

4. **Keep password change logic inline** for now (complex self-vs-admin logic).
  </action>
  <verify>
- `grep -c "req\$user_role %in%" api/endpoints/user_endpoints.R` reduced (was ~20+, target <5)
- `grep -c "require_role" api/endpoints/user_endpoints.R` shows new pattern usage
- No syntax errors
  </verify>
  <done>
- user_endpoints.R refactored to use require_role
- Service layer calls added where applicable
- Duplicated role checks reduced
  </done>
</task>

<task type="auto">
  <name>Task 3: Refactor admin_endpoints.R and authentication_endpoints.R</name>
  <files>api/endpoints/admin_endpoints.R, api/endpoints/authentication_endpoints.R</files>
  <action>
**admin_endpoints.R refactoring:**

Replace role checks at lines ~53 and ~202:
```r
# Before
if (req$user_role != "Administrator") {
  res$status <- 403
  return(list(error = "Not authorized."))
}

# After
require_role(req, res, "Administrator")
```

**authentication_endpoints.R refactoring:**

Replace inline auth logic with service calls:

1. **POST /signin** (lines ~150-210):
```r
# Before: 60+ lines of inline auth logic

# After:
function(req, res, user_name, password) {
  result <- auth_signin(user_name, password, pool, dw)
  response_success(result)
}
```

2. **GET /verify** (lines ~220-260):
```r
# After:
function(req, res) {
  result <- auth_verify(req$HTTP_AUTHORIZATION, dw)
  response_success(result)
}
```

3. **POST /refresh** (lines ~280-320):
```r
# After:
function(req, res) {
  result <- auth_refresh(req$HTTP_AUTHORIZATION, pool, dw)
  response_success(result)
}
```

Keep the @preempt annotations for public endpoints that bypass auth filter.
  </action>
  <verify>
- `grep -c "require_role" api/endpoints/admin_endpoints.R` shows usage
- `grep -c "auth_signin\|auth_verify" api/endpoints/authentication_endpoints.R` shows service calls
- No syntax errors
  </verify>
  <done>
- admin_endpoints.R uses require_role
- authentication_endpoints.R calls auth-service.R
- Code significantly cleaner
  </done>
</task>

</tasks>

<verification>
- [ ] user_endpoints.R uses require_role for authorization
- [ ] admin_endpoints.R uses require_role for Administrator checks
- [ ] authentication_endpoints.R calls auth-service functions
- [ ] No syntax errors in refactored files
- [ ] Role check count reduced in user_endpoints.R
</verification>

<success_criteria>
- First batch of endpoints refactored
- Duplicated role checks consolidated
- Service layer integration working
- Baseline behavior preserved
</success_criteria>

<output>
After completion, create `.planning/phases/22-service-layer-middleware/22-06-SUMMARY.md`
</output>
