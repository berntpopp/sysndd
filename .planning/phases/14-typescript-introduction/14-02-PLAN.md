---
phase: 14-typescript-introduction
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/src/types/utils.ts
  - app/src/types/models.ts
  - app/src/types/api.ts
  - app/src/types/components.ts
  - app/src/types/index.ts
autonomous: true

must_haves:
  truths:
    - "Domain model types exist for Entity, Gene, User, Phenotype"
    - "API response types exist for all endpoints"
    - "Branded types prevent ID mixing at compile time"
    - "Types are re-exported from central index"
  artifacts:
    - path: "app/src/types/models.ts"
      provides: "Domain model interfaces"
      exports: ["Entity", "Gene", "User", "GeneId", "EntityId"]
    - path: "app/src/types/api.ts"
      provides: "API response types"
      exports: ["ApiResponse", "StatisticsResponse", "NewsItem"]
    - path: "app/src/types/utils.ts"
      provides: "Branded type helper"
      exports: ["Brand"]
    - path: "app/src/types/index.ts"
      provides: "Central type exports"
      contains: "export * from"
  key_links:
    - from: "app/src/types/models.ts"
      to: "app/src/types/utils.ts"
      via: "Brand import"
      pattern: "import type.*Brand.*from.*utils"
---

<objective>
Create comprehensive type definitions for models, API responses, and components

Purpose: Establish a complete type system for the SysNDD domain, enabling type-safe API interactions and preventing common errors like mixing different ID types.

Output: src/types/ directory with models.ts, api.ts, components.ts, utils.ts, and index.ts
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-typescript-introduction/14-CONTEXT.md
@.planning/phases/14-typescript-introduction/14-RESEARCH.md
@app/src/assets/js/constants/init_obj_constants.js
@app/src/assets/js/services/apiService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create utility types and branded ID types</name>
  <files>app/src/types/utils.ts</files>
  <action>
Create app/src/types/ directory and utils.ts with branded type infrastructure:

```typescript
// app/src/types/utils.ts
/**
 * Utility types for SysNDD application
 * Includes branded types for compile-time type safety
 */

declare const __brand: unique symbol;

/**
 * Create a branded type - adds compile-time type safety without runtime cost
 * Use this to create distinct types for different kinds of IDs
 * @example
 * type GeneId = Brand<string, 'GeneId'>;
 * type EntityId = Brand<string, 'EntityId'>;
 */
export type Brand<T, TBrand extends string> = T & { [__brand]: TBrand };

/**
 * Generic nullable type
 */
export type Nullable<T> = T | null;

/**
 * Make specific properties optional
 */
export type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

/**
 * Make specific properties required
 */
export type RequiredBy<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;
```

This provides the branded type pattern from RESEARCH.md for domain IDs.
  </action>
  <verify>
```bash
test -f app/src/types/utils.ts && echo "utils.ts exists" && grep -q "Brand<T, TBrand" app/src/types/utils.ts && echo "Brand type defined"
```
  </verify>
  <done>utils.ts created with Brand type helper and utility types</done>
</task>

<task type="auto">
  <name>Task 2: Create domain model types</name>
  <files>app/src/types/models.ts</files>
  <action>
Create models.ts with all domain model interfaces. Analyze existing code (init_obj_constants.js, apiService.js, routes.js) to identify data structures:

```typescript
// app/src/types/models.ts
/**
 * Domain model type definitions for SysNDD
 * Based on analysis of existing constants and API responses
 */

import type { Brand } from './utils';

// ============================================================================
// Branded ID Types - Prevent mixing different ID types at compile time
// ============================================================================

/** Gene identifier (HGNC format) */
export type GeneId = Brand<string, 'GeneId'>;

/** Entity identifier (numeric) */
export type EntityId = Brand<number, 'EntityId'>;

/** User identifier */
export type UserId = Brand<string, 'UserId'>;

/** Disease ontology identifier */
export type DiseaseId = Brand<string, 'DiseaseId'>;

/** HPO term identifier */
export type HpoTermId = Brand<string, 'HpoTermId'>;

// Factory functions for creating branded IDs from raw values
export function createGeneId(id: string): GeneId {
  return id as GeneId;
}

export function createEntityId(id: number): EntityId {
  return id as EntityId;
}

export function createUserId(id: string): UserId {
  return id as UserId;
}

// ============================================================================
// Core Domain Models
// ============================================================================

/** User roles in the system */
export type UserRole = 'Administrator' | 'Curator' | 'Reviewer' | 'Viewer';

/** Entity categories for curation status */
export type EntityCategory = 'Definitive' | 'Moderate' | 'Limited' | 'Refuted';

/** Inheritance filter values */
export type InheritanceFilter =
  | 'All'
  | 'Autosomal dominant'
  | 'Autosomal recessive'
  | 'X-linked'
  | 'Other';

/** NDD phenotype indicator */
export type NddPhenotypeWord = 'Yes' | 'No';

/**
 * User model
 */
export interface User {
  user_id: UserId;
  email: string;
  user_name?: string;
  user_role: UserRole[];
  exp?: number; // JWT expiration timestamp
}

/**
 * Gene model
 */
export interface Gene {
  hgnc_id: GeneId;
  symbol: string;
  name?: string;
  // Additional gene properties from API
  entrez_id?: string;
  ensembl_gene_id?: string;
}

/**
 * Entity model - a gene-disease association with curation status
 */
export interface Entity {
  entity_id: EntityId;
  hgnc_id: GeneId;
  symbol: string;
  disease_ontology_id_version: DiseaseId;
  disease_ontology_name: string;
  hpo_mode_of_inheritance_term: HpoTermId;
  hpo_mode_of_inheritance_term_name: string;
  inheritance_filter: InheritanceFilter;
  ndd_phenotype: 0 | 1;
  ndd_phenotype_word: NddPhenotypeWord;
  entry_date: string;
  category: EntityCategory;
  category_id: number;
}

/**
 * Phenotype model
 */
export interface Phenotype {
  hpo_id: HpoTermId;
  hpo_term_name: string;
  definition?: string;
}

/**
 * Category statistics group
 */
export interface CategoryGroup {
  category: EntityCategory;
  category_id: number;
  inheritance: InheritanceFilter;
  n: number;
}

/**
 * Category statistics with groups
 */
export interface CategoryStat {
  category: EntityCategory;
  n: number;
  inheritance: InheritanceFilter;
  groups: CategoryGroup[];
}

/**
 * Statistics metadata
 */
export interface StatisticsMeta {
  last_update: string;
  executionTime: number | null;
}

/**
 * News item (recent entity)
 */
export interface NewsItem extends Entity {
  // NewsItem is essentially an Entity with all fields
}

// ============================================================================
// Navigation and Permissions
// ============================================================================

/** Navigation sections */
export type NavigationSection = 'Admin' | 'Curate' | 'Review' | 'View';

/**
 * Route meta information
 */
export interface RouteMeta {
  sitemap?: {
    priority: number;
    changefreq: 'always' | 'hourly' | 'daily' | 'weekly' | 'monthly' | 'yearly' | 'never';
    ignoreRoute?: boolean;
  };
  requiresAuth?: boolean;
  allowedRoles?: UserRole[];
}
```
  </action>
  <verify>
```bash
grep -c "export" app/src/types/models.ts
```
Should show 15+ exports (types and interfaces).
  </verify>
  <done>models.ts created with Entity, Gene, User, Phenotype interfaces and branded ID types</done>
</task>

<task type="auto">
  <name>Task 3: Create API and component types</name>
  <files>app/src/types/api.ts, app/src/types/components.ts, app/src/types/index.ts</files>
  <action>
Create api.ts with API response types for the 21 endpoints:

```typescript
// app/src/types/api.ts
/**
 * API request and response type definitions
 * Based on analysis of apiService.js and R plumber backend
 */

import type {
  Entity,
  Gene,
  CategoryStat,
  StatisticsMeta,
  NewsItem,
  EntityCategory,
  InheritanceFilter
} from './models';

// ============================================================================
// Generic API Response Wrappers
// ============================================================================

/**
 * Standard API response structure with meta and data
 */
export interface ApiResponse<T> {
  meta: StatisticsMeta[];
  data: T;
}

/**
 * Paginated API response
 */
export interface PaginatedResponse<T> {
  meta: StatisticsMeta[];
  data: T[];
  page?: number;
  page_size?: number;
  total?: number;
}

/**
 * Error response from API
 */
export interface ApiError {
  error: string;
  message?: string;
  status?: number;
}

// ============================================================================
// Statistics Endpoints
// ============================================================================

/** GET /api/statistics/category_count */
export interface StatisticsResponse {
  meta: StatisticsMeta[];
  data: CategoryStat[];
}

/** GET /api/statistics/news */
export interface NewsResponse {
  meta: StatisticsMeta[];
  data: NewsItem[];
}

// ============================================================================
// Entity Endpoints
// ============================================================================

/** GET /api/entity/:id */
export interface EntityResponse {
  meta: StatisticsMeta[];
  data: Entity[];
}

/** GET /api/entities (list with pagination) */
export interface EntitiesResponse extends PaginatedResponse<Entity> {}

// ============================================================================
// Gene Endpoints
// ============================================================================

/** GET /api/gene/:symbol */
export interface GeneResponse {
  meta: StatisticsMeta[];
  data: Gene[];
}

/** GET /api/genes (list with pagination) */
export interface GenesResponse extends PaginatedResponse<Gene> {}

// ============================================================================
// Search Endpoints
// ============================================================================

/** Search result item */
export interface SearchResultItem {
  type: 'gene' | 'entity' | 'disease' | 'phenotype';
  id: string;
  label: string;
  description?: string;
}

/** GET /api/search/:term */
export interface SearchResponse {
  meta: StatisticsMeta[];
  data: SearchResultItem[];
}

// ============================================================================
// Request Parameter Types
// ============================================================================

/** Statistics request parameters */
export interface StatisticsParams {
  type: 'entity' | 'gene';
}

/** News request parameters */
export interface NewsParams {
  n: number;
}

/** Search request parameters */
export interface SearchParams {
  searchInput: string;
  helper?: boolean;
}

/** Table query parameters (from route props) */
export interface TableQueryParams {
  sort?: string;
  filter?: string;
  fields?: string;
  pageAfter?: string;
  pageSize?: string;
  fspec?: string;
}

/** Panel route parameters */
export interface PanelParams {
  category_input?: EntityCategory | 'All';
  inheritance_input?: InheritanceFilter;
}
```

Create components.ts with component prop types:

```typescript
// app/src/types/components.ts
/**
 * Component prop and emit type definitions
 */

import type { Ref } from 'vue';
import type { Entity, Gene, EntityCategory, InheritanceFilter } from './models';

// ============================================================================
// Table Component Props
// ============================================================================

/** Sort configuration for Bootstrap-Vue-Next tables */
export interface SortBy {
  key: string;
  order: 'asc' | 'desc';
}

/** Table field definition */
export interface TableField {
  key: string;
  label: string;
  sortable?: boolean;
  class?: string;
  thClass?: string;
  tdClass?: string;
  formatter?: (value: unknown, key: string, item: unknown) => string;
}

/** Table props common to data tables */
export interface TableProps {
  items: unknown[];
  fields: TableField[];
  sortBy?: SortBy[];
  loading?: boolean;
  emptyText?: string;
}

// ============================================================================
// Modal Component Props
// ============================================================================

/** Modal props */
export interface ModalProps {
  id: string;
  title?: string;
  size?: 'sm' | 'md' | 'lg' | 'xl';
  centered?: boolean;
  hideHeader?: boolean;
  hideFooter?: boolean;
}

// ============================================================================
// Toast Types
// ============================================================================

/** Toast variant */
export type ToastVariant = 'success' | 'danger' | 'warning' | 'info' | 'primary' | 'secondary';

/** Toast notification options */
export interface ToastOptions {
  title?: string;
  body: string;
  variant?: ToastVariant;
  autoHide?: boolean;
  autoHideDelay?: number;
}

// ============================================================================
// Form Component Props
// ============================================================================

/** Form input props */
export interface FormInputProps {
  modelValue: string | number;
  label?: string;
  placeholder?: string;
  required?: boolean;
  disabled?: boolean;
  state?: boolean | null;
  invalidFeedback?: string;
}

/** Select option */
export interface SelectOption {
  value: string | number;
  text: string;
  disabled?: boolean;
}

// ============================================================================
// Composable Return Types
// ============================================================================

/** Modal controls composable return type */
export interface ModalControls {
  showModal: (id: string) => void;
  hideModal: (id: string) => void;
  confirm: (options: unknown) => Promise<boolean>;
}

/** Toast notifications composable return type */
export interface ToastNotifications {
  makeToast: (
    message: string | { message: string },
    title?: string | null,
    variant?: ToastVariant | null,
    autoHide?: boolean,
    autoHideDelay?: number
  ) => void;
}

/** UI Store type (for typing Pinia store usage) */
export interface UIStoreState {
  scrollbarUpdateTrigger: number;
}

export interface UIStoreActions {
  requestScrollbarUpdate(): void;
}

export type UIStore = UIStoreState & UIStoreActions;
```

Create index.ts to re-export all types:

```typescript
// app/src/types/index.ts
/**
 * Central export point for all type definitions
 * Import types from here for consistency:
 * import type { Entity, Gene, ApiResponse } from '@/types';
 */

export * from './utils';
export * from './models';
export * from './api';
export * from './components';
```
  </action>
  <verify>
```bash
ls -la app/src/types/ && echo "---" && head -5 app/src/types/index.ts
```
All 5 files should exist: utils.ts, models.ts, api.ts, components.ts, index.ts
  </verify>
  <done>api.ts with endpoint types, components.ts with prop types, index.ts re-exporting all</done>
</task>

</tasks>

<verification>
1. Types directory exists with all files:
   ```bash
   ls app/src/types/
   ```
   Should list: api.ts, components.ts, index.ts, models.ts, utils.ts

2. Types can be imported:
   ```bash
   cd app && npx tsc --noEmit src/types/index.ts
   ```
   Should compile without errors

3. Branded types are defined:
   ```bash
   grep "Brand<" app/src/types/models.ts | head -5
   ```
   Should show GeneId, EntityId, etc.
</verification>

<success_criteria>
- src/types/ directory created with 5 files
- models.ts has Entity, Gene, User, Phenotype interfaces
- models.ts has branded ID types (GeneId, EntityId, UserId)
- api.ts has response types for statistics, news, search endpoints
- components.ts has table, modal, toast prop types
- utils.ts has Brand type helper
- index.ts re-exports all types
- All type files compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-typescript-introduction/14-02-SUMMARY.md`
</output>
