---
phase: 58-llm-foundation
plan: 02
type: execute
wave: 2
depends_on: [58-01]
files_modified:
  - api/functions/llm-validation.R
  - api/functions/llm-service.R
  - api/tests/testthat/test-llm-validation.R
autonomous: true

must_haves:
  truths:
    - "Gene symbols in LLM output are validated against non_alt_loci_set"
    - "Invalid gene symbols cause summary rejection"
    - "Pathways are validated against input enrichment terms"
    - "Validation errors are logged with specific details"
    - "Validation functions have unit test coverage"
  artifacts:
    - path: "api/functions/llm-validation.R"
      provides: "Entity validation functions"
      exports: ["validate_summary_entities", "validate_gene_symbols", "validate_pathways"]
    - path: "api/tests/testthat/test-llm-validation.R"
      provides: "Validation unit tests"
      contains: "test_that"
  key_links:
    - from: "api/functions/llm-validation.R"
      to: "non_alt_loci_set table"
      via: "db_execute_query"
      pattern: "non_alt_loci_set"
    - from: "api/functions/llm-service.R"
      to: "api/functions/llm-validation.R"
      via: "validate_summary_entities call"
      pattern: "validate_summary_entities"
    - from: "api/functions/llm-validation.R"
      to: "api/functions/llm-cache-repository.R"
      via: "log_generation_attempt for failures"
      pattern: "log_generation_attempt|validation_failed"
---

<objective>
Implement entity validation pipeline to ensure all gene symbols in LLM output exist in the database, preventing hallucinated gene names from being stored.

Purpose: Guarantee data integrity by validating all LLM-mentioned entities against authoritative sources before storage.

Output: Validation functions integrated into LLM service with comprehensive unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/58-llm-foundation/58-CONTEXT.md
@.planning/phases/58-llm-foundation/58-RESEARCH.md
@.planning/phases/58-llm-foundation/58-01-SUMMARY.md
@api/functions/external-proxy-functions.R
@api/functions/llm-service.R
@api/functions/llm-cache-repository.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Entity validation functions</name>
  <files>api/functions/llm-validation.R</files>
  <action>
Create `api/functions/llm-validation.R` with strict entity validation:

1. Load dependencies:
   - require(tidyverse), require(stringr), require(logger)
   - Source db-helpers.R if not loaded

2. Define common word exclusions:
   ```r
   COMMON_WORDS <- c("THE", "AND", "FOR", "DNA", "RNA", "ATP", "GTP", "ADP",
                     "GDP", "NAD", "FAD", "NDD", "HPO", "GO", "KEGG", "OMIM")
   ```

3. Implement `extract_gene_symbols(text)`:
   - Use regex to find HGNC-style symbols: `\\b[A-Z][A-Z0-9-]{1,15}\\b`
   - Filter out COMMON_WORDS
   - Return unique character vector of potential gene symbols

4. Implement `validate_gene_symbols(symbols)`:
   - If empty vector, return list(is_valid = TRUE, valid = character(), invalid = character())
   - Query non_alt_loci_set: `SELECT symbol FROM non_alt_loci_set WHERE symbol IN (...)`
   - Return list(is_valid, valid, invalid) where is_valid = length(invalid) == 0

5. Implement `validate_pathways(pathways, enrichment_terms)`:
   - If pathways is NULL or empty, return list(is_valid = TRUE, valid = list(), invalid = list())
   - Check each pathway against enrichment_terms (case-insensitive)
   - Return list(is_valid, valid, invalid) where is_valid = length(invalid) == 0

6. Implement `validate_summary_entities(summary_result, cluster_data)`:
   - Extract genes from summary_result$summary using extract_gene_symbols()
   - Validate genes with validate_gene_symbols()
   - Validate pathways with validate_pathways() against cluster_data$term_enrichment$term
   - Aggregate errors into human-readable messages
   - Return list(
       is_valid = gene_result$is_valid && pathway_result$is_valid,
       mentioned_genes = gene_result$valid,
       invalid_genes = gene_result$invalid,
       mentioned_pathways = pathway_result$valid,
       invalid_pathways = pathway_result$invalid,
       errors = character vector of error messages
     )

CRITICAL: Validation is STRICT - any invalid gene symbol causes entire summary rejection.
This matches CONTEXT.md decision: "Strict - reject entire summary if any invalid gene symbols detected"

7. Add roxygen2 documentation for all exported functions with examples.
  </action>
  <verify>
Source the file and verify functions:
```r
source("api/functions/llm-validation.R")
exists("validate_summary_entities")
exists("validate_gene_symbols")
exists("validate_pathways")
exists("extract_gene_symbols")

# Test extraction
symbols <- extract_gene_symbols("The BRCA1 and TP53 genes are involved in DNA repair")
all(c("BRCA1", "TP53") %in% symbols) && !("DNA" %in% symbols)
```
All should return TRUE.
  </verify>
  <done>
llm-validation.R exports validate_summary_entities, validate_gene_symbols, validate_pathways, extract_gene_symbols with strict validation logic.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate validation into LLM service</name>
  <files>api/functions/llm-service.R</files>
  <action>
Update `api/functions/llm-service.R` to integrate validation:

1. Add source for validation:
   ```r
   if (!exists("validate_summary_entities", mode = "function")) {
     if (file.exists("functions/llm-validation.R")) {
       source("functions/llm-validation.R", local = TRUE)
     }
   }
   ```

2. Update `generate_cluster_summary()` to validate before returning:
   - After successful chat_structured() call, run validate_summary_entities()
   - If validation fails:
     - Log with log_generation_attempt(..., status = "validation_failed", validation_errors = ...)
     - Increment retry counter
     - Continue retry loop (up to max_retries)
   - If validation passes:
     - Log with status = "success"
     - Return validated summary

3. Update `get_or_generate_summary()` to handle validation status:
   - When saving to cache, include validation_status from generate_cluster_summary result
   - If all retries fail validation, still save last attempt with validation_status = 'rejected'
   - Return includes validation details for transparency

4. Add helper `calculate_derived_confidence(enrichment_data)`:
   - Compute average FDR across top terms
   - Count significant terms (FDR < 0.05)
   - Return score: high if avg_fdr < 1e-10 and term_count > 20, medium if < 1e-5 and > 10, else low
   - Add to summary_json as derived_confidence object

Example retry flow:
```r
while (retries < max_retries) {
  result <- chat$chat_structured(prompt, type = type_spec)
  validation <- validate_summary_entities(result, cluster_data)

  if (validation$is_valid) {
    log_generation_attempt(..., status = "success")
    return(list(success = TRUE, summary = result, validation = validation))
  }

  log_generation_attempt(..., status = "validation_failed",
                        validation_errors = paste(validation$errors, collapse = "; "))
  retries <- retries + 1
  Sys.sleep(2^retries + runif(1, 0, 1))  # backoff
}
```
  </action>
  <verify>
1. Check validation is integrated:
   ```r
   source("api/functions/llm-service.R")
   # Should source validation functions
   exists("validate_summary_entities")
   ```

2. Check generate_cluster_summary handles validation (manual code inspection):
   ```bash
   grep -n "validate_summary_entities" api/functions/llm-service.R
   grep -n "validation_failed" api/functions/llm-service.R
   ```
   Both should have matches.
  </verify>
  <done>
llm-service.R integrates validation into generate_cluster_summary with retry on validation failure, logs validation errors, and includes derived_confidence calculation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Unit tests for validation functions</name>
  <files>api/tests/testthat/test-llm-validation.R</files>
  <action>
Create `api/tests/testthat/test-llm-validation.R` with comprehensive unit tests:

1. Test extract_gene_symbols():
   - Extracts valid HGNC symbols (BRCA1, TP53, C9orf72)
   - Filters common words (DNA, RNA, ATP)
   - Handles empty text
   - Handles text with no gene symbols

2. Test validate_gene_symbols() (requires database):
   - Skip if database unavailable (skip_if_no_db pattern from existing tests)
   - Valid symbols return is_valid = TRUE
   - Invalid symbols (e.g., "FAKEGENE123") return is_valid = FALSE with invalid list
   - Empty vector returns is_valid = TRUE

3. Test validate_pathways():
   - Pathways in enrichment_terms return is_valid = TRUE
   - Pathways not in enrichment return is_valid = FALSE
   - Case-insensitive matching works
   - Empty pathways return is_valid = TRUE

4. Test validate_summary_entities():
   - Mock summary_result with valid content
   - Mock cluster_data with enrichment terms
   - Valid summary returns is_valid = TRUE
   - Summary with invalid gene returns is_valid = FALSE
   - Summary with invalid pathway returns is_valid = FALSE
   - Errors are human-readable

Use existing test patterns from api/tests/testthat/ for structure and database skip logic.

```r
test_that("extract_gene_symbols extracts HGNC-style symbols", {
  text <- "The BRCA1 and TP53 genes regulate DNA repair"
  symbols <- extract_gene_symbols(text)

  expect_true("BRCA1" %in% symbols)
  expect_true("TP53" %in% symbols)
  expect_false("DNA" %in% symbols)  # Common word excluded
  expect_false("The" %in% symbols)  # Lowercase excluded
})
```
  </action>
  <verify>
Run tests:
```bash
cd /home/bernt-popp/development/sysndd/api
Rscript -e "testthat::test_file('tests/testthat/test-llm-validation.R')"
```
All tests should pass (some may skip if database unavailable).
  </verify>
  <done>
test-llm-validation.R has tests for extract_gene_symbols, validate_gene_symbols, validate_pathways, and validate_summary_entities with database skip logic where needed.
  </done>
</task>

</tasks>

<verification>
1. Validation rejects invalid genes:
   ```r
   source("api/functions/llm-validation.R")
   result <- validate_gene_symbols(c("BRCA1", "FAKEGENE123"))
   stopifnot(result$is_valid == FALSE)
   stopifnot("FAKEGENE123" %in% result$invalid)
   ```

2. Integration test (with mock or real API):
   ```r
   # Create mock summary with hallucinated gene
   mock_summary <- list(
     summary = "The BRCA1 and HALLUCINATED1 genes are involved...",
     pathways = c("Oxidative phosphorylation"),
     tags = c("metabolism")
   )
   mock_cluster <- list(
     term_enrichment = tibble(term = c("Oxidative phosphorylation", "DNA repair"))
   )
   result <- validate_summary_entities(mock_summary, mock_cluster)
   stopifnot(result$is_valid == FALSE)
   ```

3. Unit tests pass: `make test-api` includes llm-validation tests
</verification>

<success_criteria>
1. validate_gene_symbols correctly identifies valid/invalid HGNC symbols via database lookup
2. validate_pathways correctly checks pathways against enrichment input
3. validate_summary_entities aggregates both validations with clear error messages
4. generate_cluster_summary retries on validation failure (up to max_retries)
5. Validation failures logged with status = "validation_failed" and error details
6. Unit tests cover extraction, gene validation, pathway validation, and integration
7. All gene symbols in stored summaries are guaranteed to exist in non_alt_loci_set
</success_criteria>

<output>
After completion, create `.planning/phases/58-llm-foundation/58-02-SUMMARY.md`
</output>
