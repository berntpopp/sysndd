---
phase: 71-viewlogs-database-filtering
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - api/functions/logging-repository.R
autonomous: true

must_haves:
  truths:
    - "build_offset_pagination_response() function exists and is exported"
    - "Pagination response includes all required metadata fields"
    - "hasMore correctly indicates whether more pages exist"
    - "totalPages handles edge case of total=0"
  artifacts:
    - path: "api/functions/logging-repository.R"
      provides: "Pagination helper function"
      exports: ["build_offset_pagination_response"]
  key_links:
    - from: "api/functions/logging-repository.R"
      to: "api/endpoints/logging_endpoints.R"
      via: "function call for pagination"
      pattern: "build_offset_pagination_response"
---

<objective>
Implement the offset-based pagination helper function.

Purpose: The pagination helper standardizes the response format for paginated endpoints, ensuring UI components receive consistent metadata (totalCount, pageSize, offset, currentPage, totalPages, hasMore) for pagination controls. This is a prerequisite for the logging endpoint refactor (Plan 71-04).

Output: Add `build_offset_pagination_response()` function to `api/functions/logging-repository.R`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/71-viewlogs-database-filtering/71-RESEARCH.md

# Pattern reference - similar pagination in llm-cache-repository:
@api/functions/llm-cache-repository.R

# Requirements PAG-01 and PAG-02 specify the exact response format
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add build_offset_pagination_response() function</name>
  <files>api/functions/logging-repository.R</files>
  <action>
Add the pagination response builder function to `api/functions/logging-repository.R`.

This function should be added AFTER the query builder functions (at the end of the file).

```r
#------------------------------------------------------------------------------
# Pagination Helpers
#------------------------------------------------------------------------------

#' Build offset-based pagination response
#'
#' Constructs a standardized pagination response object with data and metadata.
#' Provides all fields needed for UI pagination controls.
#'
#' @param data Tibble or data.frame, the paginated data for current page
#' @param total Integer, total count of matching rows (from COUNT query)
#' @param page Integer, current page number (1-indexed)
#' @param per_page Integer, page size (rows per page)
#'
#' @return List with:
#'   - data: The input data (unchanged)
#'   - meta: List with pagination metadata:
#'     - totalCount: Total matching rows
#'     - pageSize: Rows per page
#'     - offset: Row offset for current page
#'     - currentPage: Current page number
#'     - totalPages: Total number of pages
#'     - hasMore: Boolean, TRUE if more pages exist
#'
#' @details
#' - Handles edge case of total=0 (returns totalPages=0, hasMore=FALSE)
#' - offset is 0-indexed: page 1 has offset 0, page 2 has offset per_page, etc.
#' - totalPages uses ceiling() to handle partial last pages
#' - hasMore is TRUE when (offset + nrow(data)) < total
#'
#' @examples
#' \dontrun{
#' # Page 1 of 3, 10 items per page, 25 total
#' data <- tibble(id = 1:10)
#' response <- build_offset_pagination_response(data, total = 25, page = 1, per_page = 10)
#' # response$meta$totalPages = 3
#' # response$meta$hasMore = TRUE
#'
#' # Last page
#' response <- build_offset_pagination_response(data, total = 25, page = 3, per_page = 10)
#' # response$meta$hasMore = FALSE
#' }
#'
#' @export
build_offset_pagination_response <- function(data, total, page, per_page) {
  # Coerce to integer for safety
  page <- as.integer(page)
  per_page <- as.integer(per_page)
  total <- as.integer(total)

  # Calculate offset (0-indexed)
  offset <- (page - 1L) * per_page

  # Calculate total pages (handle total=0 edge case)
  total_pages <- if (total == 0L) 0L else ceiling(total / per_page)

  # Calculate hasMore: are there more rows beyond current page?
  rows_fetched <- if (is.data.frame(data)) nrow(data) else length(data)
  has_more <- (offset + rows_fetched) < total

  list(
    data = data,
    meta = list(
      totalCount = total,
      pageSize = per_page,
      offset = offset,
      currentPage = page,
      totalPages = total_pages,
      hasMore = has_more
    )
  )
}
```

Requirements satisfied:
- PAG-01: Function exists
- PAG-02: Response includes totalCount, pageSize, offset, currentPage, totalPages, hasMore
  </action>
  <verify>
```bash
# Function exists
grep "build_offset_pagination_response" api/functions/logging-repository.R

# All metadata fields present
grep "totalCount" api/functions/logging-repository.R
grep "pageSize" api/functions/logging-repository.R
grep "offset" api/functions/logging-repository.R
grep "currentPage" api/functions/logging-repository.R
grep "totalPages" api/functions/logging-repository.R
grep "hasMore" api/functions/logging-repository.R

# Has @export tag
grep -B 5 "build_offset_pagination_response" api/functions/logging-repository.R | grep "@export"
```
  </verify>
  <done>
build_offset_pagination_response() function added with all required metadata fields:
- totalCount, pageSize, offset (PAG-02)
- currentPage, totalPages, hasMore (PAG-02)
- Handles total=0 edge case
  </done>
</task>

<task type="auto">
  <name>Task 2: Add get_logs_paginated() main query function</name>
  <files>api/functions/logging-repository.R</files>
  <action>
Add the main query function that combines all the components to fetch paginated logs.

```r
#------------------------------------------------------------------------------
# Main Query Functions
#------------------------------------------------------------------------------

#' Get paginated log entries with filtering
#'
#' Fetches log entries from database with filtering and offset-based pagination.
#' Uses database-side filtering (WHERE clause) instead of loading all rows.
#'
#' @param status Integer or NULL, filter by HTTP status code (exact match)
#' @param request_method Character or NULL, filter by method (GET, POST, etc.)
#' @param path_prefix Character or NULL, filter by path prefix (LIKE 'prefix%')
#' @param timestamp_from Character or NULL, filter by minimum timestamp
#' @param timestamp_to Character or NULL, filter by maximum timestamp
#' @param address Character or NULL, filter by IP address (exact match)
#' @param page Integer, page number (1-indexed). Default: 1
#' @param per_page Integer, rows per page. Default: 50
#' @param sort_column Character, column to sort by. Default: "id"
#' @param sort_direction Character, ASC or DESC. Default: "DESC"
#'
#' @return List with data and meta (from build_offset_pagination_response)
#'
#' @details
#' - Validates sort column against LOGGING_ALLOWED_SORT_COLUMNS
#' - Validates sort direction (ASC/DESC only)
#' - Builds WHERE clause with parameterized values
#' - Executes COUNT query first for totalCount
#' - Then executes data query with LIMIT/OFFSET
#' - Returns standardized pagination response
#'
#' @examples
#' \dontrun{
#' # Get first page of 200 errors
#' result <- get_logs_paginated(status = 200, page = 1, per_page = 50)
#'
#' # Get logs from specific path prefix
#' result <- get_logs_paginated(path_prefix = "/api/entity", page = 2)
#'
#' # Get logs sorted by timestamp
#' result <- get_logs_paginated(sort_column = "timestamp", sort_direction = "ASC")
#' }
#'
#' @export
get_logs_paginated <- function(
  status = NULL,
  request_method = NULL,
  path_prefix = NULL,
  timestamp_from = NULL,
  timestamp_to = NULL,
  address = NULL,
  page = 1L,
  per_page = 50L,
  sort_column = "id",
  sort_direction = "DESC"
) {
  log_info("Fetching logs: page={page}, per_page={per_page}, sort={sort_column} {sort_direction}")

  # Coerce pagination params to integer
  page <- as.integer(page)
  per_page <- as.integer(per_page)

  # Validate sort parameters
  validate_logging_column(sort_column, LOGGING_ALLOWED_SORT_COLUMNS, "sort")
  sort_direction <- validate_sort_direction(sort_direction)

  # Build filters list
  filters <- list(
    status = status,
    request_method = request_method,
    path_prefix = path_prefix,
    timestamp_from = timestamp_from,
    timestamp_to = timestamp_to,
    address = address
  )

  # Build WHERE clause
  where_result <- build_logging_where_clause(filters)
  where_clause <- where_result$clause
  params <- where_result$params

  # Execute COUNT query for totalCount (LOG-06)
  count_sql <- paste("SELECT COUNT(*) as total FROM logging WHERE", where_clause)
  count_result <- db_execute_query(count_sql, params)
  total <- count_result$total[1] %||% 0L

  # Calculate offset
  offset <- (page - 1L) * per_page

  # Build ORDER BY clause
  order_clause <- paste("ORDER BY", sort_column, sort_direction)

  # Execute data query with LIMIT/OFFSET (LOG-05)
  data_sql <- paste(
    "SELECT id, timestamp, address, agent, host, request_method, path, query, post, status, duration, file, modified",
    "FROM logging WHERE", where_clause,
    order_clause,
    "LIMIT ? OFFSET ?"
  )
  data_params <- append(params, list(per_page, offset))
  data_result <- db_execute_query(data_sql, data_params)

  log_debug("Fetched {nrow(data_result)} rows, total={total}")

  # Return with pagination metadata
  build_offset_pagination_response(data_result, total, page, per_page)
}
```

This function satisfies:
- LOG-01: Uses database-side filtering (WHERE in SQL, not collect() then filter)
- LOG-05: Uses LIMIT/OFFSET for pagination
- LOG-06: Executes COUNT query for totalCount
  </action>
  <verify>
```bash
# Function exists
grep "get_logs_paginated" api/functions/logging-repository.R

# Uses database-side filtering
grep "WHERE" api/functions/logging-repository.R | grep -v "#"

# Uses LIMIT/OFFSET
grep "LIMIT.*OFFSET" api/functions/logging-repository.R

# Uses COUNT query
grep "COUNT" api/functions/logging-repository.R

# Calls db_execute_query (not collect)
grep "db_execute_query" api/functions/logging-repository.R

# Does NOT use collect() anywhere
! grep "collect()" api/functions/logging-repository.R && echo "No collect() found - good"
```
  </verify>
  <done>
get_logs_paginated() function added that:
- Uses database-side filtering with WHERE clause (LOG-01)
- Uses parameterized queries via db_execute_query (LOG-03)
- Uses LIMIT/OFFSET for pagination (LOG-05)
- Executes COUNT query for totalCount (LOG-06)
- Does NOT use collect() - queries database directly
  </done>
</task>

</tasks>

<verification>
1. build_offset_pagination_response() function exists (PAG-01)
2. Response includes totalCount, pageSize, offset, currentPage, totalPages, hasMore (PAG-02)
3. get_logs_paginated() uses WHERE clause in SQL (LOG-01)
4. get_logs_paginated() uses LIMIT/OFFSET (LOG-05)
5. get_logs_paginated() executes COUNT query for total (LOG-06)
6. No collect() usage - all filtering is database-side
</verification>

<success_criteria>
- build_offset_pagination_response() exists in api/functions/logging-repository.R (PAG-01)
- Pagination response has all 6 metadata fields (PAG-02)
- get_logs_paginated() performs database-side filtering (LOG-01, LOG-05, LOG-06)
- No collect() before filter pattern anywhere
</success_criteria>

<output>
After completion, create `.planning/phases/71-viewlogs-database-filtering/71-03-SUMMARY.md`
</output>
