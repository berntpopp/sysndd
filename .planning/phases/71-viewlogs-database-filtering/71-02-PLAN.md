---
phase: 71-viewlogs-database-filtering
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - api/functions/logging-repository.R
autonomous: true

must_haves:
  truths:
    - "Query builder validates columns against whitelist before SQL construction"
    - "Invalid column names are rejected with invalid_filter_error"
    - "SQL values use parameterized queries (? placeholders)"
    - "Sort direction is validated to only allow ASC/DESC"
  artifacts:
    - path: "api/functions/logging-repository.R"
      provides: "Query builder and column validation functions"
      exports: ["LOGGING_ALLOWED_COLUMNS", "validate_logging_column", "build_logging_where_clause"]
      min_lines: 100
  key_links:
    - from: "api/functions/logging-repository.R"
      to: "api/functions/db-helpers.R"
      via: "source() or function call"
      pattern: "db_execute_query"
---

<objective>
Create the logging repository with query builder functions that validate columns and build parameterized SQL.

Purpose: The query builder is the security layer that prevents SQL injection by validating column names against a whitelist and using parameterized queries for values. This is required before refactoring the logging endpoint (Plan 71-04).

Output: New file `api/functions/logging-repository.R` with column validation and WHERE clause builder functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/71-viewlogs-database-filtering/71-RESEARCH.md

# Pattern reference - existing repository with similar structure:
@api/functions/llm-cache-repository.R

# Database helpers to use:
@api/functions/db-helpers.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create logging-repository.R with column validation</name>
  <files>api/functions/logging-repository.R</files>
  <action>
Create `api/functions/logging-repository.R` following the pattern from `llm-cache-repository.R`.

Include these components:

1. **Header and dependencies:**
```r
# functions/logging-repository.R
#
# Database repository for logging table operations.
# Provides query building, column validation, and pagination.
#
# Key features:
# - Column whitelist validation to prevent SQL injection
# - Parameterized queries via db_execute_query()
# - Offset-based pagination with metadata

require(rlang)
require(logger)

# Load database helper functions
if (!exists("db_execute_query", mode = "function")) {
  if (file.exists("functions/db-helpers.R")) {
    source("functions/db-helpers.R", local = TRUE)
  }
}
```

2. **Column whitelist constant (LOG-02):**
```r
#' Allowed columns for logging queries
#'
#' Whitelist of column names that can be used in filter and sort operations.
#' Any column not in this list will be rejected to prevent SQL injection.
#'
#' @export
LOGGING_ALLOWED_COLUMNS <- c(
  "id",
  "timestamp",
  "address",
  "agent",
  "host",
  "request_method",
  "path",
  "query",
  "post",
  "status",
  "duration",
  "file",
  "modified"
)

#' Allowed sort columns (subset that makes sense for sorting)
#' @export
LOGGING_ALLOWED_SORT_COLUMNS <- c(
  "id",
  "timestamp",
  "status",
  "duration",
  "path",
  "request_method"
)
```

3. **Column validation function (LOG-02, LOG-04):**
```r
#' Validate column name against whitelist
#'
#' Checks if a column name is in the allowed list. Throws invalid_filter_error
#' if column is not allowed, preventing SQL injection via column names.
#'
#' @param column Character, the column name to validate
#' @param allowed Character vector, the whitelist of allowed columns
#' @param context Character, description for error message (default: "filter")
#'
#' @return The validated column name (unchanged)
#'
#' @details
#' - Column names cannot use parameterized queries (? placeholders)
#' - This whitelist approach is the security layer for dynamic SQL
#' - Throws rlang::abort with class "invalid_filter_error" on failure
#'
#' @export
validate_logging_column <- function(
  column,
  allowed = LOGGING_ALLOWED_COLUMNS,
  context = "filter"
) {
  if (!column %in% allowed) {
    rlang::abort(
      message = paste0(
        "Invalid ", context, " column: '", column, "'. ",
        "Allowed columns: ", paste(allowed, collapse = ", ")
      ),
      class = "invalid_filter_error"
    )
  }
  column
}
```

4. **Sort direction validation:**
```r
#' Validate sort direction
#'
#' Ensures sort direction is either ASC or DESC.
#'
#' @param direction Character, the sort direction
#'
#' @return The validated direction (uppercase)
#'
#' @export
validate_sort_direction <- function(direction) {
  direction <- toupper(trimws(direction))
  if (!direction %in% c("ASC", "DESC")) {
    rlang::abort(
      message = paste0("Invalid sort direction: '", direction, "'. Must be ASC or DESC."),
      class = "invalid_filter_error"
    )
  }
  direction
}
```

5. **WHERE clause builder (LOG-03):**
```r
#' Build WHERE clause with parameterized values
#'
#' Constructs a WHERE clause string and corresponding parameter list
#' for the logging table. All values use ? placeholders for parameterization.
#'
#' @param filters Named list of filter criteria:
#'   - status: Integer, exact match on HTTP status code
#'   - request_method: Character, exact match on method (GET, POST, etc.)
#'   - path_prefix: Character, prefix match on path (uses LIKE 'prefix%')
#'   - timestamp_from: Character, minimum timestamp (>= comparison)
#'   - timestamp_to: Character, maximum timestamp (<= comparison)
#'   - address: Character, exact match on IP address
#'
#' @return List with:
#'   - clause: Character, the WHERE clause (without "WHERE" keyword)
#'   - params: List, the parameter values in order
#'
#' @details
#' - Always starts with "1=1" to simplify AND concatenation
#' - All filter values use ? placeholders (parameterized)
#' - path_prefix uses LIKE with % suffix for index-friendly prefix search
#' - Empty or NULL filter values are ignored
#'
#' @examples
#' \dontrun{
#' result <- build_logging_where_clause(list(status = 200, path_prefix = "/api/"))
#' # result$clause: "1=1 AND status = ? AND path LIKE ?"
#' # result$params: list(200, "/api/%")
#' }
#'
#' @export
build_logging_where_clause <- function(filters = list()) {
  where_clause <- "1=1"
  params <- list()

  # Status filter (exact match)
  if (!is.null(filters$status) && filters$status != "") {
    where_clause <- paste(where_clause, "AND status = ?")
    params <- append(params, as.integer(filters$status))
  }

  # Request method filter (exact match)
  if (!is.null(filters$request_method) && filters$request_method != "") {
    where_clause <- paste(where_clause, "AND request_method = ?")
    params <- append(params, filters$request_method)
  }

  # Path prefix filter (LIKE with prefix for index use)
  if (!is.null(filters$path_prefix) && filters$path_prefix != "") {
    where_clause <- paste(where_clause, "AND path LIKE ?")
    params <- append(params, paste0(filters$path_prefix, "%"))
  }

  # Timestamp range filters
  if (!is.null(filters$timestamp_from) && filters$timestamp_from != "") {
    where_clause <- paste(where_clause, "AND timestamp >= ?")
    params <- append(params, filters$timestamp_from)
  }

  if (!is.null(filters$timestamp_to) && filters$timestamp_to != "") {
    where_clause <- paste(where_clause, "AND timestamp <= ?")
    params <- append(params, filters$timestamp_to)
  }

  # Address filter (exact match)
  if (!is.null(filters$address) && filters$address != "") {
    where_clause <- paste(where_clause, "AND address = ?")
    params <- append(params, filters$address)
  }

  list(
    clause = where_clause,
    params = params
  )
}
```

6. **ORDER BY clause builder:**
```r
#' Build ORDER BY clause
#'
#' Constructs an ORDER BY clause with validated column and direction.
#'
#' @param sort_column Character, column to sort by
#' @param sort_direction Character, ASC or DESC
#'
#' @return Character, the ORDER BY clause (e.g., "ORDER BY id DESC")
#'
#' @export
build_logging_order_clause <- function(
  sort_column = "id",
  sort_direction = "DESC"
) {
  # Validate column
  validate_logging_column(sort_column, LOGGING_ALLOWED_SORT_COLUMNS, "sort")

  # Validate direction
  direction <- validate_sort_direction(sort_direction)

  paste("ORDER BY", sort_column, direction)
}
```
  </action>
  <verify>
```bash
# File exists
test -f api/functions/logging-repository.R && echo "File exists"

# Contains required exports
grep "LOGGING_ALLOWED_COLUMNS" api/functions/logging-repository.R
grep "validate_logging_column" api/functions/logging-repository.R
grep "build_logging_where_clause" api/functions/logging-repository.R
grep "build_logging_order_clause" api/functions/logging-repository.R
grep "validate_sort_direction" api/functions/logging-repository.R

# Uses rlang::abort for errors
grep "rlang::abort" api/functions/logging-repository.R

# Uses invalid_filter_error class
grep "invalid_filter_error" api/functions/logging-repository.R
```
  </verify>
  <done>
File api/functions/logging-repository.R exists with:
- LOGGING_ALLOWED_COLUMNS constant with all logging table columns
- LOGGING_ALLOWED_SORT_COLUMNS constant with sortable columns
- validate_logging_column() that throws invalid_filter_error for unknown columns
- validate_sort_direction() that validates ASC/DESC
- build_logging_where_clause() that builds parameterized WHERE clauses
- build_logging_order_clause() that builds validated ORDER BY clauses
  </done>
</task>

<task type="auto">
  <name>Task 2: Add SQL injection test cases as comments</name>
  <files>api/functions/logging-repository.R</files>
  <action>
Add documentation comments showing how the validation prevents SQL injection:

```r
#' @section Security Notes:
#'
#' The column validation prevents SQL injection attacks that attempt to:
#' - Inject via column names: `sort_column = "id; DROP TABLE logging; --"`
#' - Inject via filter columns: `filters = list("status; DELETE FROM logging" = 1)`
#'
#' Example attack that would be blocked:
#' ```r
#' # This would throw invalid_filter_error, NOT execute the injection
#' validate_logging_column("id; DROP TABLE logging; --")
#' # Error: Invalid filter column: 'id; DROP TABLE logging; --'
#' ```
#'
#' Values are safe because they use parameterized queries (? placeholders).
```

Add this to the validate_logging_column function documentation.
  </action>
  <verify>
```bash
# Security documentation present
grep -A 5 "Security Notes" api/functions/logging-repository.R
grep "SQL injection" api/functions/logging-repository.R
```
  </verify>
  <done>
Security documentation added explaining how whitelist validation prevents SQL injection via column names.
  </done>
</task>

</tasks>

<verification>
1. File api/functions/logging-repository.R exists
2. LOGGING_ALLOWED_COLUMNS contains all logging table columns
3. validate_logging_column() throws invalid_filter_error for unknown columns
4. build_logging_where_clause() uses ? placeholders for all values
5. build_logging_order_clause() validates column and direction
6. Security documentation explains SQL injection prevention
</verification>

<success_criteria>
- api/functions/logging-repository.R created with query builder functions
- Column whitelist defined (LOG-02)
- Parameterized queries used for values (LOG-03)
- Invalid columns rejected with invalid_filter_error (LOG-04)
- ORDER BY builder validates column and direction
</success_criteria>

<output>
After completion, create `.planning/phases/71-viewlogs-database-filtering/71-02-SUMMARY.md`
</output>
