---
phase: 52-user-lifecycle-e2e
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/tests/testthat/helper-mailpit.R
  - api/tests/testthat/test-e2e-user-lifecycle.R
autonomous: true

must_haves:
  truths:
    - "User registration sends confirmation email captured in Mailpit"
    - "Curator approval sends password email captured in Mailpit"
    - "Tests skip gracefully when Mailpit or API unavailable"
    - "Test users are cleaned up even if tests fail"
  artifacts:
    - path: "api/tests/testthat/helper-mailpit.R"
      provides: "Token extraction helper for password reset"
      exports: ["extract_token_from_email"]
    - path: "api/tests/testthat/test-e2e-user-lifecycle.R"
      provides: "E2E tests for user registration and approval flows"
      contains: "test_that"
  key_links:
    - from: "api/tests/testthat/test-e2e-user-lifecycle.R"
      to: "/api/authentication/signup"
      via: "httr2 HTTP request"
      pattern: "req_url_query.*signup_data"
    - from: "api/tests/testthat/test-e2e-user-lifecycle.R"
      to: "/api/user/approval"
      via: "httr2 HTTP request"
      pattern: "user/approval"
    - from: "api/tests/testthat/test-e2e-user-lifecycle.R"
      to: "api/tests/testthat/helper-mailpit.R"
      via: "helper auto-loading"
      pattern: "mailpit_wait_for_message"
---

<objective>
Create user lifecycle E2E tests for registration and curator approval flows.

Purpose: Verify SMTP-03 (user registration sends email) and SMTP-04 (curator approval sends email) end-to-end using Mailpit infrastructure from Phase 51.

Output:
- Updated helper-mailpit.R with token extraction function
- test-e2e-user-lifecycle.R with registration and approval tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-user-lifecycle-e2e/52-CONTEXT.md
@.planning/phases/52-user-lifecycle-e2e/52-RESEARCH.md
@.planning/phases/51-smtp-testing-infrastructure/51-02-SUMMARY.md

# Existing helpers and patterns
@api/tests/testthat/helper-mailpit.R
@api/tests/testthat/helper-db.R
@api/tests/testthat/helper-auth.R
@api/tests/testthat/test-integration-email.R

# API endpoints being tested
@api/endpoints/authentication_endpoints.R
@api/endpoints/user_endpoints.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add token extraction helper to helper-mailpit.R</name>
  <files>api/tests/testthat/helper-mailpit.R</files>
  <action>
Add `extract_token_from_email()` function to helper-mailpit.R for extracting JWT tokens from password reset emails.

Append after the existing `mailpit_get_message()` function:

```r
#' Extract token from email body
#'
#' Extracts a JWT token from the email body using regex pattern matching.
#' Used for password reset flow where token is embedded in URL.
#'
#' @param message_id Mailpit message ID (from mailpit_wait_for_message)
#' @param pattern Regex pattern to extract token (default: /PasswordReset/ URLs)
#' @param mailpit_url Base URL for Mailpit
#' @return Extracted token string, or error if not found
extract_token_from_email <- function(
    message_id,
    pattern = "/PasswordReset/([A-Za-z0-9_-]+\\.[A-Za-z0-9_-]+\\.[A-Za-z0-9_-]+)",
    mailpit_url = "http://localhost:8025") {

  # Fetch full message content

full_message <- mailpit_get_message(message_id, mailpit_url)

  # Get text body (prefer plain text over HTML per CONTEXT.md)
  email_body <- full_message$Text
  if (is.null(email_body) || email_body == "") {
    email_body <- full_message$HTML
  }

  if (is.null(email_body) || email_body == "") {
    stop("Email body is empty - cannot extract token")
  }

  # Extract token using regex
  match <- regmatches(email_body, regexpr(pattern, email_body, perl = TRUE))

  if (length(match) == 0 || match == "") {
    stop(paste("Could not extract token from email body with pattern:", pattern))
  }

  # Extract just the token part (the captured group)
  token <- sub(".*/PasswordReset/", "", match)

  # Validate token format - JWT has 3 parts separated by dots
  if (!grepl("^[A-Za-z0-9_-]+\\.[A-Za-z0-9_-]+\\.[A-Za-z0-9_-]+$", token)) {
    stop(paste("Extracted token does not appear to be valid JWT format:", token))
  }

  token
}
```

Notes:
- Follows existing helper-mailpit.R documentation style
- Pattern default matches /PasswordReset/{jwt} URL format from user_endpoints.R
- Prefers plain text body over HTML (per CONTEXT.md decision)
- Validates JWT format (3 dot-separated parts) before returning
  </action>
  <verify>Run `Rscript -e "source('api/tests/testthat/helper-mailpit.R'); cat('Helper loaded with', length(ls()), 'functions\n')"` to confirm syntax</verify>
  <done>extract_token_from_email() function added to helper-mailpit.R</done>
</task>

<task type="auto">
  <name>Task 2: Create E2E test file with registration and approval tests</name>
  <files>api/tests/testthat/test-e2e-user-lifecycle.R</files>
  <action>
Create test-e2e-user-lifecycle.R with comprehensive E2E tests for user registration and curator approval flows.

```r
# tests/testthat/test-e2e-user-lifecycle.R
# End-to-end tests for user lifecycle flows
#
# Tests user registration (SMTP-03), curator approval (SMTP-04), and
# password reset (SMTP-05) using Mailpit to capture emails.
#
# Prerequisites:
#   - Mailpit running: docker compose -f docker-compose.dev.yml up -d mailpit
#   - API server running: make serve-api (port 7779)
#   - Test database running: docker compose -f docker-compose.dev.yml up -d db-test

library(testthat)
library(httr2)
library(jsonlite)

# =============================================================================
# Test Configuration
# =============================================================================

# Get API base URL from config (typically http://localhost:7779)
get_api_base_url <- function() {
  config <- get_test_config()
  config$api_base_url %||% "http://localhost:7779"
}

# Check if API server is available
api_available <- function() {
  tryCatch({
    resp <- httr2::request(paste0(get_api_base_url(), "/health")) |>
      httr2::req_timeout(2) |>
      httr2::req_error(is_error = function(resp) FALSE) |>
      httr2::req_perform()
    httr2::resp_status(resp) == 200
  }, error = function(e) FALSE)
}

# Skip if API not available
skip_if_no_api <- function() {
  if (!api_available()) {
    testthat::skip("API server not available (start with: make serve-api)")
  }
}

# Generate unique test user data
# Uses example.com domain (RFC 2606 reserved for testing)
generate_test_user <- function(prefix = "e2etest") {
  timestamp <- format(Sys.time(), "%Y%m%d%H%M%S")
  random_suffix <- floor(runif(1, 10000, 99999))

  list(
    user_name = paste0(prefix, random_suffix),
    first_name = "Test",
    family_name = "User",
    email = paste0(prefix, "-", timestamp, "-", random_suffix, "@example.com"),
    orcid = paste0("0000-0000-0000-", sprintf("%04d", random_suffix %% 10000)),
    comment = "Automated E2E test user - safe to delete",
    terms_agreed = "accepted"
  )
}

# Cleanup test user from database
cleanup_test_user <- function(email) {
  tryCatch({
    con <- get_test_db_connection()
    withr::defer(DBI::dbDisconnect(con), envir = parent.frame())
    DBI::dbExecute(con, "DELETE FROM user WHERE email = ?", list(email))
  }, error = function(e) {
    # Ignore cleanup errors - user may not exist
    message("Cleanup note: ", e$message)
  })
}

# Get user from database by email
get_user_by_email <- function(email) {
  con <- get_test_db_connection()
  withr::defer(DBI::dbDisconnect(con), envir = parent.frame())
  result <- DBI::dbGetQuery(
    con,
    "SELECT user_id, user_name, email, approved, password FROM user WHERE email = ?",
    list(email)
  )
  if (nrow(result) == 0) NULL else result[1, ]
}

# Create admin JWT for curator operations
get_admin_token <- function() {
  # Use create_test_jwt from helper-auth.R if available
  # Otherwise construct minimal admin token
  if (exists("create_test_jwt")) {
    create_test_jwt(user_id = 1, user_role = "Administrator")
  } else {
    # Fallback: construct token manually
    config <- get_test_config()
    key <- charToRaw(config$secret)

    claim <- jose::jwt_claim(
      user_id = 1,
      user_name = "admin",
      user_role = "Administrator",
      iat = as.integer(Sys.time()),
      exp = as.integer(Sys.time()) + 3600
    )
    jose::jwt_encode_hmac(claim, secret = key)
  }
}


# =============================================================================
# User Registration Tests (SMTP-03)
# =============================================================================

test_that("user registration sends confirmation email", {
  skip_if_no_mailpit()
  skip_if_no_api()
  skip_if_no_test_db()

  # Clean Mailpit inbox
  mailpit_delete_all()

  # Generate unique test user
  test_user <- generate_test_user("signup")

  # Register cleanup BEFORE creating user (withr::defer runs even on failure)
  withr::defer(cleanup_test_user(test_user$email))

  # Make signup request
  signup_json <- jsonlite::toJSON(test_user, auto_unbox = TRUE)

  resp <- httr2::request(paste0(get_api_base_url(), "/api/authentication/signup")) |>
    httr2::req_url_query(signup_data = signup_json) |>
    httr2::req_error(is_error = function(resp) FALSE) |>
    httr2::req_perform()

  # Signup should succeed (200)
  expect_equal(httr2::resp_status(resp), 200)

  # Wait for confirmation email in Mailpit
  message <- mailpit_wait_for_message(test_user$email, timeout_seconds = 10)

  expect_true(!is.null(message))
  expect_match(message$Subject, "registration request", ignore.case = TRUE)

  # Verify user was created in database with approved=0
  user <- get_user_by_email(test_user$email)
  expect_true(!is.null(user))
  expect_equal(user$approved, 0)
})


test_that("duplicate registration is rejected", {
  skip_if_no_mailpit()
  skip_if_no_api()
  skip_if_no_test_db()

  mailpit_delete_all()
  test_user <- generate_test_user("dupe")
  withr::defer(cleanup_test_user(test_user$email))

  signup_json <- jsonlite::toJSON(test_user, auto_unbox = TRUE)

  # First registration should succeed
  resp1 <- httr2::request(paste0(get_api_base_url(), "/api/authentication/signup")) |>
    httr2::req_url_query(signup_data = signup_json) |>
    httr2::req_error(is_error = function(resp) FALSE) |>
    httr2::req_perform()

  expect_equal(httr2::resp_status(resp1), 200)

  # Wait for first email
  mailpit_wait_for_message(test_user$email, timeout_seconds = 5)
  initial_count <- mailpit_message_count()

  # Second registration should fail (duplicate email/username)
  # Note: The endpoint may return 200 or error depending on implementation
  resp2 <- httr2::request(paste0(get_api_base_url(), "/api/authentication/signup")) |>
    httr2::req_url_query(signup_data = signup_json) |>
    httr2::req_error(is_error = function(resp) FALSE) |>
    httr2::req_perform()

  # Should not send additional email on duplicate attempt
  Sys.sleep(1)  # Brief wait for any async email
  final_count <- mailpit_message_count()
  expect_equal(final_count, initial_count)
})


test_that("invalid registration data is rejected", {
  skip_if_no_mailpit()
  skip_if_no_api()

  mailpit_delete_all()

  # Invalid data: username too short, no ORCID
  invalid_user <- list(
    user_name = "ab",  # Too short (min 5)
    first_name = "Test",
    family_name = "User",
    email = "invalid@example.com",
    orcid = "invalid-format",
    comment = "Test comment that is long enough",
    terms_agreed = "accepted"
  )

  signup_json <- jsonlite::toJSON(invalid_user, auto_unbox = TRUE)

  resp <- httr2::request(paste0(get_api_base_url(), "/api/authentication/signup")) |>
    httr2::req_url_query(signup_data = signup_json) |>
    httr2::req_error(is_error = function(resp) FALSE) |>
    httr2::req_perform()

  # Should return error status (404 per endpoint code)
  expect_equal(httr2::resp_status(resp), 404)

  # No email should be sent
  Sys.sleep(1)
  count <- mailpit_message_count()
  expect_equal(count, 0)
})


# =============================================================================
# Curator Approval Tests (SMTP-04)
# =============================================================================

test_that("curator approval sends password email", {
  skip_if_no_mailpit()
  skip_if_no_api()
  skip_if_no_test_db()

  mailpit_delete_all()
  test_user <- generate_test_user("approve")
  withr::defer(cleanup_test_user(test_user$email))

  # First register the user
  signup_json <- jsonlite::toJSON(test_user, auto_unbox = TRUE)

  httr2::request(paste0(get_api_base_url(), "/api/authentication/signup")) |>
    httr2::req_url_query(signup_data = signup_json) |>
    httr2::req_perform()

  # Wait for registration email
  mailpit_wait_for_message(test_user$email, timeout_seconds = 5)

  # Get user_id from database
  user <- get_user_by_email(test_user$email)
  expect_true(!is.null(user))
  expect_equal(user$approved, 0)

  # Clear inbox before approval
  mailpit_delete_all()

  # Approve user via API (requires admin/curator token)
  admin_token <- get_admin_token()

  resp <- httr2::request(paste0(get_api_base_url(), "/api/user/approval")) |>
    httr2::req_method("PUT") |>
    httr2::req_url_query(user_id = user$user_id, status_approval = "TRUE") |>
    httr2::req_headers(Authorization = paste("Bearer", admin_token)) |>
    httr2::req_error(is_error = function(resp) FALSE) |>
    httr2::req_perform()

  # Approval should succeed
  expect_true(httr2::resp_status(resp) %in% c(200, 204))

  # Wait for approval email with password
  message <- mailpit_wait_for_message(test_user$email, timeout_seconds = 10)

  expect_true(!is.null(message))
  expect_match(message$Subject, "approved", ignore.case = TRUE)

  # Verify user is now approved in database
  user_after <- get_user_by_email(test_user$email)
  expect_equal(user_after$approved, 1)

  # Verify password was set (not null/empty)
  expect_true(!is.null(user_after$password) && nchar(user_after$password) > 0)
})


test_that("curator rejection deletes user without email", {
  skip_if_no_mailpit()
  skip_if_no_api()
  skip_if_no_test_db()

  mailpit_delete_all()
  test_user <- generate_test_user("reject")
  # No defer cleanup needed - rejection deletes user

  # Register the user
  signup_json <- jsonlite::toJSON(test_user, auto_unbox = TRUE)

  httr2::request(paste0(get_api_base_url(), "/api/authentication/signup")) |>
    httr2::req_url_query(signup_data = signup_json) |>
    httr2::req_perform()

  # Wait for registration email
  mailpit_wait_for_message(test_user$email, timeout_seconds = 5)

  # Get user_id
  user <- get_user_by_email(test_user$email)
  expect_true(!is.null(user))

  # Clear inbox
  mailpit_delete_all()

  # Reject user (status_approval = FALSE)
  admin_token <- get_admin_token()

  resp <- httr2::request(paste0(get_api_base_url(), "/api/user/approval")) |>
    httr2::req_method("PUT") |>
    httr2::req_url_query(user_id = user$user_id, status_approval = "FALSE") |>
    httr2::req_headers(Authorization = paste("Bearer", admin_token)) |>
    httr2::req_error(is_error = function(resp) FALSE) |>
    httr2::req_perform()

  expect_true(httr2::resp_status(resp) %in% c(200, 204))

  # User should be deleted
  user_after <- get_user_by_email(test_user$email)
  expect_null(user_after)

  # No rejection email should be sent
  Sys.sleep(1)
  count <- mailpit_message_count()
  expect_equal(count, 0)
})
```

Notes:
- Follows existing test patterns (library, sections, skip_if_*)
- Uses RFC 2606 example.com domain for test emails (reserved for testing)
- withr::defer() ensures cleanup even on test failure
- Generates unique user data with timestamps to avoid collision
- Tests both success and failure scenarios per CONTEXT.md decisions
- Verifies email NOT sent on failures per CONTEXT.md security decision
  </action>
  <verify>Run `cd api && Rscript -e "testthat::test_file('tests/testthat/test-e2e-user-lifecycle.R')"` (tests will skip if prerequisites not running)</verify>
  <done>test-e2e-user-lifecycle.R created with user registration and curator approval E2E tests</done>
</task>

</tasks>

<verification>
1. Helper file syntax check:
   ```bash
   cd /home/bernt-popp/development/sysndd/api && Rscript -e "source('tests/testthat/helper-mailpit.R'); cat('extract_token_from_email exists:', exists('extract_token_from_email'), '\n')"
   ```
   Expected: extract_token_from_email exists: TRUE

2. Test file syntax check:
   ```bash
   cd /home/bernt-popp/development/sysndd/api && Rscript -e "testthat::test_file('tests/testthat/test-e2e-user-lifecycle.R')"
   ```
   Expected: Tests skip (prerequisites not running) or pass

3. lintr check:
   ```bash
   cd /home/bernt-popp/development/sysndd/api && Rscript -e "lintr::lint('tests/testthat/helper-mailpit.R')"
   cd /home/bernt-popp/development/sysndd/api && Rscript -e "lintr::lint('tests/testthat/test-e2e-user-lifecycle.R')"
   ```
   Expected: No lint errors

4. Full test suite still passes:
   ```bash
   cd /home/bernt-popp/development/sysndd && make test-api
   ```
   Expected: All tests pass (E2E tests skip if prerequisites not running)
</verification>

<success_criteria>
- SMTP-03 verified: User registration E2E test captures confirmation email in Mailpit
- SMTP-04 verified: Curator approval E2E test captures password email in Mailpit
- extract_token_from_email() helper added to helper-mailpit.R
- Tests skip gracefully when Mailpit, API, or database unavailable
- Test users cleaned up via withr::defer() even on failure
- No lint errors in modified/created files
</success_criteria>

<output>
After completion, create `.planning/phases/52-user-lifecycle-e2e/52-01-SUMMARY.md`
</output>
