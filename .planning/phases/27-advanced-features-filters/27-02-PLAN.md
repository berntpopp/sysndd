---
phase: 27-advanced-features-filters
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/src/components/filters/CategoryFilter.vue
  - app/src/components/filters/ScoreSlider.vue
  - app/src/components/filters/TermSearch.vue
autonomous: true

must_haves:
  truths:
    - "CategoryFilter provides dropdown selection for GO, KEGG, MONDO categories"
    - "ScoreSlider offers FDR preset thresholds (0.01, 0.05, 0.1) plus custom input"
    - "TermSearch wraps TableSearchInput with wildcard syntax help and no-match feedback"
    - "All components use v-model for two-way binding"
  artifacts:
    - path: "app/src/components/filters/CategoryFilter.vue"
      provides: "Dropdown categorical filter component"
      min_lines: 40
    - path: "app/src/components/filters/ScoreSlider.vue"
      provides: "Numeric range filter with presets"
      min_lines: 60
    - path: "app/src/components/filters/TermSearch.vue"
      provides: "Wildcard search input component"
      min_lines: 50
  key_links:
    - from: "app/src/components/filters/TermSearch.vue"
      to: "app/src/components/small/TableSearchInput.vue"
      via: "component import and wrapping"
      pattern: "TableSearchInput"
    - from: "app/src/components/filters/ScoreSlider.vue"
      to: "bootstrap-vue-next"
      via: "BFormSelect, BInputGroup components"
      pattern: "BFormSelect"
---

<objective>
Create reusable filter components for categorical, numeric, and wildcard search filtering

Purpose: Build the FILT-06 (CategoryFilter), FILT-07 (ScoreSlider), and FILT-08 (TermSearch) reusable components that will be integrated into analysis tables and views for consistent filtering UX

Output: Three Vue components in app/src/components/filters/ directory
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/27-advanced-features-filters/27-CONTEXT.md
@.planning/phases/27-advanced-features-filters/27-RESEARCH.md
@app/src/components/small/TableSearchInput.vue
@app/src/components/small/GenericTable.vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CategoryFilter component</name>
  <files>app/src/components/filters/CategoryFilter.vue</files>
  <action>
Create filters/ directory and CategoryFilter.vue component for dropdown categorical filtering.

First create directory:
```bash
mkdir -p /home/bernt-popp/development/sysndd/app/src/components/filters
```

Implementation (follow RESEARCH.md Example 1):
1. Use script setup with TypeScript
2. Props:
   - modelValue: string | null (v-model binding)
   - options: Array<{ value: string; text: string }> (dropdown options)
   - placeholder: string (default: 'All categories')

3. Template:
   - BFormSelect with size="sm"
   - First option slot for placeholder with null value
   - Apply 'filter-active' class when value is non-null

4. Style:
   - .filter-active: border-color: var(--bs-primary)

Code structure:
```vue
<template>
  <BFormSelect
    v-model="selected"
    :options="options"
    size="sm"
    :class="{ 'filter-active': selected !== null }"
  >
    <template #first>
      <BFormSelectOption :value="null">
        {{ placeholder }}
      </BFormSelectOption>
    </template>
  </BFormSelect>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { BFormSelect, BFormSelectOption } from 'bootstrap-vue-next';

interface Props {
  modelValue: string | null;
  options: Array<{ value: string; text: string }>;
  placeholder?: string;
}

const props = withDefaults(defineProps<Props>(), {
  placeholder: 'All categories',
});

const emit = defineEmits<{
  'update:modelValue': [value: string | null];
}>();

const selected = computed({
  get: () => props.modelValue,
  set: (value) => emit('update:modelValue', value),
});
</script>

<style scoped>
.filter-active {
  border-color: var(--bs-primary);
}
</style>
```
  </action>
  <verify>
File exists and TypeScript compiles:
```bash
ls -la /home/bernt-popp/development/sysndd/app/src/components/filters/CategoryFilter.vue
cd /home/bernt-popp/development/sysndd/app && npx vue-tsc --noEmit
```
  </verify>
  <done>CategoryFilter.vue provides dropdown filter with active state styling</done>
</task>

<task type="auto">
  <name>Task 2: Create ScoreSlider component</name>
  <files>app/src/components/filters/ScoreSlider.vue</files>
  <action>
Create ScoreSlider.vue component for FDR numeric filtering with preset thresholds.

Implementation (follow RESEARCH.md Example 2):
1. Use script setup with TypeScript
2. Props:
   - modelValue: number | null (v-model binding)
   - presets: Array<{ value: number; label: string }> (default FDR presets)

3. Default presets per user decision:
   - { value: 0.01, label: '< 0.01' }
   - { value: 0.05, label: '< 0.05' }
   - { value: 0.1, label: '< 0.1' }

4. Template:
   - BInputGroup with BFormSelect for preset/custom selection
   - Conditional BFormInput for custom value (shown when 'custom' selected)
   - Apply 'filter-active' class when value is non-null

5. Logic:
   - selectedPreset tracks dropdown (null | number | 'custom')
   - customValue tracks custom input
   - Watch selectedPreset to emit appropriate value
   - Watch customValue when in custom mode
   - Initialize from modelValue (detect if preset or custom)

6. Style:
   - .custom-input: max-width: 80px

Code structure (key parts):
```vue
<template>
  <div class="score-slider">
    <BInputGroup size="sm">
      <BFormSelect
        v-model="selectedPreset"
        :options="presetOptions"
        :class="{ 'filter-active': modelValue !== null }"
      >
        <template #first>
          <BFormSelectOption :value="null">
            All FDR values
          </BFormSelectOption>
        </template>
      </BFormSelect>

      <BFormInput
        v-if="selectedPreset === 'custom'"
        v-model.number="customValue"
        type="number"
        step="0.001"
        min="0"
        max="1"
        placeholder="0.05"
        class="custom-input"
      />
    </BInputGroup>
  </div>
</template>
```

Handle bidirectional sync:
- When preset selected -> emit preset value
- When custom selected -> emit customValue
- When modelValue changes from outside -> update selectedPreset/customValue
  </action>
  <verify>
TypeScript compiles:
```bash
cd /home/bernt-popp/development/sysndd/app && npx vue-tsc --noEmit
```
  </verify>
  <done>ScoreSlider.vue provides FDR filter with presets (0.01, 0.05, 0.1) and custom input</done>
</task>

<task type="auto">
  <name>Task 3: Create TermSearch component</name>
  <files>app/src/components/filters/TermSearch.vue</files>
  <action>
Create TermSearch.vue component wrapping TableSearchInput with wildcard support.

Implementation (follow RESEARCH.md Example 3):
1. Use script setup with TypeScript
2. Props:
   - modelValue: string (v-model binding)
   - matchCount: number (optional, for no-results feedback)
   - isSearching: boolean (optional, loading state)
   - placeholder: string (default: 'Search genes (e.g., PKD*, BRCA?)')

3. Template:
   - Wrap existing TableSearchInput component
   - Pass through props (placeholder, debounce-time=300, loading)
   - Show no-results message when matchCount === 0 and pattern non-empty and not searching
   - Show wildcard hint when pattern is entered

4. Key UX from CONTEXT.md:
   - ~300ms debounce
   - Subtle no-results message below input
   - Wildcard syntax help: * (any chars), ? (one char)

Code structure:
```vue
<template>
  <div class="term-search">
    <TableSearchInput
      v-model="searchPattern"
      :placeholder="placeholder"
      :debounce-time="300"
      :loading="isSearching"
    />
    <small v-if="noResults && searchPattern" class="text-muted d-block mt-1">
      No genes match '{{ searchPattern }}'
    </small>
    <small v-else-if="searchPattern" class="text-muted d-block mt-1">
      Wildcards: * (any chars), ? (one char)
    </small>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import TableSearchInput from '@/components/small/TableSearchInput.vue';

interface Props {
  modelValue: string;
  matchCount?: number;
  isSearching?: boolean;
  placeholder?: string;
}

const props = withDefaults(defineProps<Props>(), {
  matchCount: 0,
  isSearching: false,
  placeholder: 'Search genes (e.g., PKD*, BRCA?)',
});

const emit = defineEmits<{
  'update:modelValue': [value: string];
}>();

const searchPattern = computed({
  get: () => props.modelValue,
  set: (value) => emit('update:modelValue', value),
});

const noResults = computed(() =>
  props.matchCount === 0 && props.modelValue.length > 0 && !props.isSearching
);
</script>

<style scoped>
.term-search {
  min-width: 200px;
}
</style>
```
  </action>
  <verify>
TypeScript compiles:
```bash
cd /home/bernt-popp/development/sysndd/app && npx vue-tsc --noEmit
```
  </verify>
  <done>TermSearch.vue wraps TableSearchInput with wildcard hints and no-match feedback</done>
</task>

</tasks>

<verification>
1. Directory exists: ls -la app/src/components/filters/
2. TypeScript compiles: npm run type-check passes
3. Components use v-model pattern correctly
4. CategoryFilter shows active state when non-null
5. ScoreSlider handles preset + custom modes
6. TermSearch shows wildcard hints and no-results feedback
</verification>

<success_criteria>
- CategoryFilter (FILT-06): Dropdown with v-model, active state styling, placeholder option
- ScoreSlider (FILT-07): FDR presets (0.01, 0.05, 0.1) + custom input, bidirectional sync
- TermSearch (FILT-08): Wraps TableSearchInput, 300ms debounce, wildcard hints, no-match message
- All components use script setup with TypeScript
- Components follow existing SysNDD patterns (see TableSearchInput.vue, GenericTable.vue)
</success_criteria>

<output>
After completion, create `.planning/phases/27-advanced-features-filters/27-02-SUMMARY.md`
</output>
