---
phase: 70-analysis-optimization
plan: 02
type: execute
wave: 2
depends_on: ["70-01"]
files_modified:
  - api/functions/analyses-functions.R
  - api/tests/testthat/test-unit-network-edges.R
autonomous: true

must_haves:
  truths:
    - "Network visualization uses DrL layout for graphs >1000 nodes"
    - "Network visualization uses FR-grid for graphs 500-1000 nodes"
    - "Network visualization uses standard FR for graphs <500 nodes"
    - "Network metadata reports actual layout algorithm used"
  artifacts:
    - path: "api/functions/analyses-functions.R"
      provides: "Adaptive layout algorithm selection in gen_network_edges()"
      contains: "layout_with_drl"
    - path: "api/tests/testthat/test-unit-network-edges.R"
      provides: "Tests for adaptive layout selection"
  key_links:
    - from: "gen_network_edges()"
      to: "igraph::layout_with_drl()"
      via: "conditional on vcount > 1000"
      pattern: "if.*node_count > 1000.*layout_with_drl"
    - from: "gen_network_edges()"
      to: "metadata$layout_algorithm"
      via: "dynamic assignment"
      pattern: "layout_algorithm = layout_algo"
---

<objective>
Implement adaptive layout algorithm selection based on graph size in gen_network_edges().

Purpose: Improve layout computation performance for large graphs by using DrL (designed for >1000 nodes), while preserving current quality for smaller graphs. The current production network has ~2259 nodes, making it a candidate for DrL.

Output: Updated gen_network_edges() with adaptive algorithm selection and dynamic metadata reporting.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/70-analysis-optimization/70-RESEARCH.md
@.planning/phases/70-analysis-optimization/70-01-SUMMARY.md

@api/functions/analyses-functions.R
@api/tests/testthat/test-unit-network-edges.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement adaptive layout selection in gen_network_edges()</name>
  <files>api/functions/analyses-functions.R</files>
  <action>
Replace the current layout computation block (lines ~485-497) with adaptive selection:

Find this block:
```r
# Compute layout using igraph - much faster than browser-side JavaScript
# Use layout_with_fr (Fruchterman-Reingold) for good cluster separation
layout_matrix <- igraph::layout_with_fr(
  subgraph,
  niter = 500, # Sufficient iterations for convergence
  weights = igraph::E(subgraph)$combined_score / 1000 # Use edge weights
)
```

Replace with:
```r
# Adaptive layout algorithm selection based on graph size
# - DrL for large graphs (>1000 nodes): Designed for large-scale networks
# - FR with grid for medium graphs (500-1000): Faster but less accurate
# - Standard FR for small graphs (<500): Best quality, current behavior
# See: https://r.igraph.org/reference/layout_nicely.html
node_count <- nrow(nodes)

if (node_count > 1000) {
  # DrL for large graphs - designed for large-scale networks
  # Does not use edge weights (DrL implementation limitation)
  message(sprintf("[gen_network_edges] Using DrL layout for %d nodes (large graph)", node_count))
  layout_matrix <- igraph::layout_with_drl(subgraph)
  layout_algo <- "drl"
} else if (node_count > 500) {
  # FR with grid optimization for medium graphs
  # Grid-based version is faster but less accurate
  message(sprintf("[gen_network_edges] Using FR-grid layout for %d nodes (medium graph)", node_count))
  layout_matrix <- igraph::layout_with_fr(
    subgraph,
    niter = 300,  # Reduced iterations for speed
    grid = "grid",
    weights = igraph::E(subgraph)$combined_score / 1000
  )
  layout_algo <- "fruchterman_reingold_grid"
} else {
  # Standard FR for small graphs - best quality, current behavior preserved
  message(sprintf("[gen_network_edges] Using FR layout for %d nodes (small graph)", node_count))
  layout_matrix <- igraph::layout_with_fr(
    subgraph,
    niter = 500,
    weights = igraph::E(subgraph)$combined_score / 1000
  )
  layout_algo <- "fruchterman_reingold"
}
```

Then update the metadata block (line ~533) to use the dynamic layout_algo:
Find: `layout_algorithm = "fruchterman_reingold",`
Replace: `layout_algorithm = layout_algo,`

Note: Keep the existing layout_time calculation - it should work with any algorithm.
  </action>
  <verify>
Run `grep -n "layout_with_drl\|layout_algo\|layout_algorithm" api/functions/analyses-functions.R` to verify:
- layout_with_drl is used for large graphs
- layout_algo variable is set in each branch
- metadata uses layout_algo (not hardcoded string)
  </verify>
  <done>
gen_network_edges() selects layout algorithm based on node count:
- >1000 nodes: DrL
- 500-1000 nodes: FR-grid
- <500 nodes: Standard FR
Metadata reports actual algorithm used.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for adaptive layout selection</name>
  <files>api/tests/testthat/test-unit-network-edges.R</files>
  <action>
Add tests at end of test-unit-network-edges.R to verify adaptive layout behavior:

```r
# =============================================================================
# Adaptive Layout Algorithm Tests
# =============================================================================

test_that("layout algorithm selection uses DrL for large graphs (>1000 nodes)", {
  # Verify the threshold for DrL selection
  node_count <- 1500  # Large graph

  expected_algorithm <- if (node_count > 1000) "drl" else "other"

  expect_equal(expected_algorithm, "drl")
})

test_that("layout algorithm selection uses FR-grid for medium graphs (500-1000 nodes)", {
  # Verify the threshold for FR-grid selection
  node_count <- 750  # Medium graph

  expected_algorithm <- if (node_count > 1000) {
    "drl"
  } else if (node_count > 500) {
    "fruchterman_reingold_grid"
  } else {
    "fruchterman_reingold"
  }

  expect_equal(expected_algorithm, "fruchterman_reingold_grid")
})

test_that("layout algorithm selection uses standard FR for small graphs (<500 nodes)", {
  # Verify small graphs use standard FR (current behavior)
  node_count <- 300  # Small graph

  expected_algorithm <- if (node_count > 1000) {
    "drl"
  } else if (node_count > 500) {
    "fruchterman_reingold_grid"
  } else {
    "fruchterman_reingold"
  }

  expect_equal(expected_algorithm, "fruchterman_reingold")
})

test_that("layout algorithm thresholds are correctly defined", {
  # Document the threshold values
  drl_threshold <- 1000
  grid_threshold <- 500

  expect_true(drl_threshold > grid_threshold)
  expect_equal(drl_threshold, 1000)
  expect_equal(grid_threshold, 500)
})

test_that("metadata layout_algorithm field can be dynamic", {
  # Verify metadata can hold different algorithm names
  algorithms <- c("drl", "fruchterman_reingold_grid", "fruchterman_reingold")

  expect_true(all(nchar(algorithms) > 0))
  expect_equal(length(algorithms), 3)
})
```
  </action>
  <verify>
Run tests:
```bash
cd /home/bernt-popp/development/sysndd/api && Rscript -e "testthat::test_file('tests/testthat/test-unit-network-edges.R')"
```
All tests should pass.
  </verify>
  <done>
Unit tests verify adaptive layout selection logic for all three size categories.
  </done>
</task>

</tasks>

<verification>
1. Grep for layout algorithms in analyses-functions.R shows:
   - layout_with_drl for large graphs
   - layout_with_fr with grid="grid" for medium graphs
   - layout_with_fr standard for small graphs
   - Dynamic layout_algo variable used in metadata

2. All unit tests pass:
```bash
cd /home/bernt-popp/development/sysndd/api && Rscript -e "testthat::test_file('tests/testthat/test-unit-network-edges.R')"
```

3. Lint check passes:
```bash
cd /home/bernt-popp/development/sysndd && make lint-api
```
</verification>

<success_criteria>
- LAY-01: Layout uses DrL for >1000 nodes
- LAY-02: Layout uses FR-grid for 500-1000 nodes
- LAY-03: Layout uses standard FR for <500 nodes (current behavior)
- LAY-04: Metadata reports actual algorithm used
- No lint errors
- All existing tests pass
- New layout tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/70-analysis-optimization/70-02-SUMMARY.md`
</output>
