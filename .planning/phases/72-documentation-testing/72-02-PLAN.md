---
phase: 72-documentation-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - api/tests/testthat/test-integration-logs-pagination.R
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Integration tests verify /api/logs endpoint returns paginated response"
    - "Integration tests verify different pages return different data"
    - "Integration tests verify pagination metadata includes totalCount, pageSize, hasMore"
    - "Tests skip gracefully when API not running or database unavailable"
  artifacts:
    - path: "api/tests/testthat/test-integration-logs-pagination.R"
      provides: "Integration tests for logs endpoint pagination"
      min_lines: 100
  key_links:
    - from: "api/tests/testthat/test-integration-logs-pagination.R"
      to: "/api/logs endpoint"
      via: "httr2 HTTP requests"
      pattern: "request.*localhost.*logs"
---

<objective>
Write integration tests for the ViewLogs pagination endpoint to verify database-side filtering and pagination work correctly.

Purpose: Integration tests confirm that the query builder, pagination, and endpoint work together correctly. These tests hit the real API with a real database to catch integration issues.

Output: New test file covering TST-07 and TST-08 requirements.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/72-documentation-testing/72-RESEARCH.md

# Test patterns to follow:
@api/tests/testthat/test-integration-pagination.R (skip_if_api_not_running pattern)
@api/tests/testthat/helper-db.R (skip_if_no_test_db helper)

# Endpoint being tested (from Phase 71 plan):
@.planning/phases/71-viewlogs-database-filtering/71-04-PLAN.md (logs endpoint refactoring)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create integration tests for logs endpoint pagination</name>
  <files>api/tests/testthat/test-integration-logs-pagination.R</files>
  <action>
Create `api/tests/testthat/test-integration-logs-pagination.R` following the pattern from test-integration-pagination.R.

The file structure:

```r
# tests/testthat/test-integration-logs-pagination.R
# Integration tests for /api/logs endpoint pagination
#
# These tests verify that the logs endpoint:
# - Returns paginated responses with correct structure
# - Returns different data for different pages
# - Includes proper pagination metadata (totalCount, pageSize, etc.)
# - Handles database-side filtering correctly
#
# Prerequisites:
# - API running on localhost:8000
# - Database available with logging data

library(testthat)
library(httr2)

# =============================================================================
# Helper: Check if API is running
# =============================================================================

skip_if_api_not_running <- function() {
  is_running <- tryCatch(
    {
      request("http://localhost:8000/health") %>%
        req_timeout(2) %>%
        req_perform()
      TRUE
    },
    error = function(e) FALSE
  )

  if (!is_running) {
    testthat::skip("API not running on localhost:8000")
  }
}

# =============================================================================
# Helper: Check if logs endpoint requires auth
# =============================================================================

check_logs_access <- function() {
  resp <- tryCatch(
    {
      request("http://localhost:8000/api/logs") %>%
        req_url_query(page = 1, per_page = 1) %>%
        req_timeout(5) %>%
        req_perform()
    },
    error = function(e) {
      list(status_code = 500, error = e$message)
    }
  )

  if (inherits(resp, "list") && !is.null(resp$error)) {
    return(list(accessible = FALSE, reason = resp$error))
  }

  status <- resp_status(resp)
  if (status == 401 || status == 403) {
    return(list(accessible = FALSE, reason = "Requires authentication"))
  }
  if (status >= 400) {
    return(list(accessible = FALSE, reason = paste("Status", status)))
  }

  list(accessible = TRUE)
}

# =============================================================================
# Logs Endpoint Pagination Structure Tests (TST-07)
# =============================================================================

describe("logs endpoint pagination structure", {
  it("returns 200 with pagination structure", {
    skip_if_api_not_running()
    access <- check_logs_access()
    if (!access$accessible) {
      skip(paste("Logs endpoint not accessible:", access$reason))
    }

    resp <- request("http://localhost:8000/api/logs") %>%
      req_url_query(page = 1, per_page = 5) %>%
      req_perform()

    expect_equal(resp_status(resp), 200)

    body <- resp_body_json(resp)

    # Verify response has data and meta
    expect_true("data" %in% names(body) || is.list(body))
  })

  it("includes pagination metadata", {
    skip_if_api_not_running()
    access <- check_logs_access()
    if (!access$accessible) {
      skip(paste("Logs endpoint not accessible:", access$reason))
    }

    resp <- request("http://localhost:8000/api/logs") %>%
      req_url_query(page = 1, per_page = 10) %>%
      req_perform()

    body <- resp_body_json(resp)

    # Check for pagination metadata fields
    # May be in body directly or in body$meta
    meta <- if ("meta" %in% names(body)) body$meta else body

    # At least one of these pagination fields should exist
    pagination_fields <- c("totalCount", "total_count", "pageSize", "per_page",
                           "perPage", "hasMore", "has_more", "currentPage",
                           "current_page", "totalPages", "total_pages", "offset")

    has_pagination <- any(pagination_fields %in% names(meta))
    expect_true(has_pagination,
                info = paste("Expected pagination fields, got:", paste(names(meta), collapse = ", ")))
  })

  it("respects per_page parameter", {
    skip_if_api_not_running()
    access <- check_logs_access()
    if (!access$accessible) {
      skip(paste("Logs endpoint not accessible:", access$reason))
    }

    resp <- request("http://localhost:8000/api/logs") %>%
      req_url_query(page = 1, per_page = 3) %>%
      req_perform()

    body <- resp_body_json(resp)

    # Data should have at most 3 items
    data <- if ("data" %in% names(body)) body$data else body
    if (is.list(data) && length(data) > 0) {
      expect_lte(length(data), 3)
    }
  })
})

# =============================================================================
# Pagination Different Pages Tests (TST-08)
# =============================================================================

describe("logs pagination returns different pages", {
  it("page 2 contains different data than page 1", {
    skip_if_api_not_running()
    access <- check_logs_access()
    if (!access$accessible) {
      skip(paste("Logs endpoint not accessible:", access$reason))
    }

    # Use small page size to ensure we have multiple pages
    resp1 <- request("http://localhost:8000/api/logs") %>%
      req_url_query(page = 1, per_page = 2) %>%
      req_perform()

    body1 <- resp_body_json(resp1)
    data1 <- if ("data" %in% names(body1)) body1$data else body1

    # Skip if not enough data for multiple pages
    if (length(data1) < 2) {
      skip("Not enough log data for pagination test (need at least 4 rows)")
    }

    resp2 <- request("http://localhost:8000/api/logs") %>%
      req_url_query(page = 2, per_page = 2) %>%
      req_perform()

    body2 <- resp_body_json(resp2)
    data2 <- if ("data" %in% names(body2)) body2$data else body2

    # Skip if page 2 is empty (not enough data)
    if (length(data2) == 0) {
      skip("Not enough log data for page 2 (need more than 2 rows)")
    }

    # Compare first items from each page
    # They should be different (different IDs)
    if (length(data1) > 0 && length(data2) > 0) {
      id1 <- data1[[1]]$id
      id2 <- data2[[1]]$id
      expect_false(identical(id1, id2),
                   info = "Page 1 and page 2 should have different first items")
    }
  })

  it("offset pagination returns correct data", {
    skip_if_api_not_running()
    access <- check_logs_access()
    if (!access$accessible) {
      skip(paste("Logs endpoint not accessible:", access$reason))
    }

    # Get first page with offset 0
    resp1 <- request("http://localhost:8000/api/logs") %>%
      req_url_query(offset = 0, per_page = 2) %>%
      req_perform()

    body1 <- resp_body_json(resp1)
    data1 <- if ("data" %in% names(body1)) body1$data else body1

    if (length(data1) < 2) {
      skip("Not enough log data for offset pagination test")
    }

    # Get with offset 2 (should skip first 2 items)
    resp2 <- request("http://localhost:8000/api/logs") %>%
      req_url_query(offset = 2, per_page = 2) %>%
      req_perform()

    body2 <- resp_body_json(resp2)
    data2 <- if ("data" %in% names(body2)) body2$data else body2

    if (length(data2) == 0) {
      skip("Not enough log data beyond offset 2")
    }

    # IDs should be different
    if (length(data1) > 0 && length(data2) > 0) {
      expect_false(identical(data1[[1]]$id, data2[[1]]$id),
                   info = "Offset 0 and offset 2 should return different first items")
    }
  })
})

# =============================================================================
# Database Query Execution Tests (TST-07)
# =============================================================================

describe("logs database-side filtering", {
  it("filters by status parameter", {
    skip_if_api_not_running()
    access <- check_logs_access()
    if (!access$accessible) {
      skip(paste("Logs endpoint not accessible:", access$reason))
    }

    # Request only 200 status logs
    resp <- request("http://localhost:8000/api/logs") %>%
      req_url_query(status = 200, per_page = 10) %>%
      req_perform()

    # Should return 200 OK (filter is valid)
    expect_equal(resp_status(resp), 200)

    body <- resp_body_json(resp)
    data <- if ("data" %in% names(body)) body$data else body

    # If data returned, all should have status 200
    if (length(data) > 0) {
      for (item in data) {
        expect_equal(item$status, 200,
                     info = "All items should have status 200 when filtered")
      }
    }
  })

  it("filters by path_prefix parameter", {
    skip_if_api_not_running()
    access <- check_logs_access()
    if (!access$accessible) {
      skip(paste("Logs endpoint not accessible:", access$reason))
    }

    # Request only /api/ path logs
    resp <- request("http://localhost:8000/api/logs") %>%
      req_url_query(path_prefix = "/api/", per_page = 10) %>%
      req_perform()

    expect_equal(resp_status(resp), 200)

    body <- resp_body_json(resp)
    data <- if ("data" %in% names(body)) body$data else body

    # If data returned, all paths should start with /api/
    if (length(data) > 0) {
      for (item in data) {
        expect_true(startsWith(item$path, "/api/"),
                    info = paste("Path should start with /api/, got:", item$path))
      }
    }
  })

  it("handles combined filters", {
    skip_if_api_not_running()
    access <- check_logs_access()
    if (!access$accessible) {
      skip(paste("Logs endpoint not accessible:", access$reason))
    }

    # Combine status and method filters
    resp <- request("http://localhost:8000/api/logs") %>%
      req_url_query(
        status = 200,
        request_method = "GET",
        per_page = 5
      ) %>%
      req_perform()

    expect_equal(resp_status(resp), 200)

    body <- resp_body_json(resp)
    data <- if ("data" %in% names(body)) body$data else body

    # If data returned, verify filters applied
    if (length(data) > 0) {
      for (item in data) {
        expect_equal(item$status, 200)
        expect_equal(item$request_method, "GET")
      }
    }
  })

  it("rejects invalid filter column with 400", {
    skip_if_api_not_running()
    access <- check_logs_access()
    if (!access$accessible) {
      skip(paste("Logs endpoint not accessible:", access$reason))
    }

    # Request with invalid sort column (SQL injection attempt)
    resp <- tryCatch(
      {
        request("http://localhost:8000/api/logs") %>%
          req_url_query(sort = "id; DROP TABLE logging") %>%
          req_error(is_error = function(resp) FALSE) %>%
          req_perform()
      },
      error = function(e) NULL
    )

    if (!is.null(resp)) {
      # Should return 400 Bad Request for invalid column
      status <- resp_status(resp)
      expect_true(status %in% c(400, 422),
                  info = paste("Expected 400 or 422 for invalid column, got:", status))
    }
  })
})

# =============================================================================
# Pagination Metadata Tests (TST-08)
# =============================================================================

describe("logs pagination metadata", {
  it("includes totalCount in response", {
    skip_if_api_not_running()
    access <- check_logs_access()
    if (!access$accessible) {
      skip(paste("Logs endpoint not accessible:", access$reason))
    }

    resp <- request("http://localhost:8000/api/logs") %>%
      req_url_query(page = 1, per_page = 5) %>%
      req_perform()

    body <- resp_body_json(resp)
    meta <- if ("meta" %in% names(body)) body$meta else body

    # Check for totalCount (may be named differently)
    total_count_field <- intersect(names(meta), c("totalCount", "total_count", "total"))
    expect_true(length(total_count_field) > 0,
                info = paste("Expected totalCount field, got:", paste(names(meta), collapse = ", ")))

    if (length(total_count_field) > 0) {
      total <- meta[[total_count_field[1]]]
      expect_true(is.numeric(total) || is.integer(total))
      expect_gte(total, 0)
    }
  })

  it("includes hasMore indicator", {
    skip_if_api_not_running()
    access <- check_logs_access()
    if (!access$accessible) {
      skip(paste("Logs endpoint not accessible:", access$reason))
    }

    resp <- request("http://localhost:8000/api/logs") %>%
      req_url_query(page = 1, per_page = 2) %>%
      req_perform()

    body <- resp_body_json(resp)
    meta <- if ("meta" %in% names(body)) body$meta else body

    # Check for hasMore indicator
    has_more_field <- intersect(names(meta), c("hasMore", "has_more", "hasNext", "has_next"))

    # If we have totalCount, we can compute hasMore ourselves
    if (length(has_more_field) == 0) {
      total_field <- intersect(names(meta), c("totalCount", "total_count", "total"))
      if (length(total_field) > 0) {
        # hasMore can be computed from totalCount > offset + perPage
        skip("hasMore not directly exposed, but totalCount available for computation")
      }
    }

    # Either hasMore exists or we have enough info to compute it
    expect_true(
      length(has_more_field) > 0 ||
        length(intersect(names(meta), c("totalCount", "total_count", "totalPages", "total_pages"))) > 0,
      info = "Response should include hasMore or totalCount/totalPages for pagination"
    )
  })
})

# =============================================================================
# Existing Tests Regression (TST-09)
# =============================================================================

describe("existing pagination tests compatibility", {
  it("entity endpoint pagination still works (regression check)", {
    skip_if_api_not_running()

    resp <- request("http://localhost:8000/api/entity") %>%
      req_url_query(page_size = 5) %>%
      req_perform()

    expect_equal(resp_status(resp), 200)

    body <- resp_body_json(resp)
    expect_true("data" %in% names(body) || is.list(body))
  })
})
```

Key points:
- Use `skip_if_api_not_running()` helper at start of each test
- Check if endpoint requires authentication and skip gracefully
- Use small `per_page` values (2-3) to ensure pagination works with minimal data
- Test filters (status, path_prefix, combined)
- Test pagination metadata (totalCount, hasMore)
- Include regression test for existing entity endpoint
  </action>
  <verify>
```bash
# File exists
test -f api/tests/testthat/test-integration-logs-pagination.R && echo "File exists"

# Check structure
grep -c "describe\|test_that" api/tests/testthat/test-integration-logs-pagination.R

# Lint check
cd /home/bernt-popp/development/sysndd/api && Rscript -e "lintr::lint('tests/testthat/test-integration-logs-pagination.R')" 2>&1 | head -20
```
  </verify>
  <done>
- test-integration-logs-pagination.R exists with comprehensive integration tests
- Tests verify database query execution (TST-07)
- Tests verify pagination returns different pages (TST-08)
- Tests include regression check for existing endpoints (TST-09)
- Tests skip gracefully when API not running or endpoint requires auth
  </done>
</task>

</tasks>

<verification>
After task completes:

1. **Test file exists:**
   ```bash
   ls -la api/tests/testthat/test-integration-logs-pagination.R
   ```

2. **File has proper structure:**
   ```bash
   grep -E "describe|it\(|test_that" api/tests/testthat/test-integration-logs-pagination.R | head -20
   ```

3. **Lint check (no issues):**
   ```bash
   cd api && Rscript -e "lintr::lint('tests/testthat/test-integration-logs-pagination.R')"
   ```

4. **Tests run (skip if API not running - expected):**
   ```bash
   cd api && Rscript -e "testthat::test_file('tests/testthat/test-integration-logs-pagination.R')" 2>&1 | tail -20
   ```
</verification>

<success_criteria>
Requirements coverage:
- [x] TST-07: Integration tests verify database query execution
- [x] TST-08: Integration tests verify pagination returns different pages
- [x] TST-09: Includes regression check for existing endpoints

Observable behaviors:
1. test-integration-logs-pagination.R exists with proper test structure
2. Tests skip gracefully when API not running (expected in CI without full stack)
3. Tests verify pagination metadata (totalCount, hasMore)
4. Tests verify different pages return different data
</success_criteria>

<output>
After completion, create `.planning/phases/72-documentation-testing/72-02-SUMMARY.md`
</output>
