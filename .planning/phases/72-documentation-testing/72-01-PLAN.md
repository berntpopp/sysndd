---
phase: 72-documentation-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/tests/testthat/test-unit-mirai-workers.R
  - api/tests/testthat/test-unit-logging-repository.R
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Unit tests verify MIRAI_WORKERS parsing defaults to 2 when not set"
    - "Unit tests verify MIRAI_WORKERS parsing handles non-numeric values"
    - "Unit tests verify MIRAI_WORKERS parsing bounds values to 1-8 range"
    - "Unit tests verify column whitelist rejects unknown columns with invalid_filter_error"
    - "Unit tests verify SQL injection patterns are rejected"
    - "Unit tests verify WHERE clause builder produces parameterized queries"
    - "Unit tests verify ORDER BY clause builder validates column and direction"
  artifacts:
    - path: "api/tests/testthat/test-unit-mirai-workers.R"
      provides: "Unit tests for MIRAI_WORKERS environment variable parsing"
      min_lines: 50
    - path: "api/tests/testthat/test-unit-logging-repository.R"
      provides: "Unit tests for logging query builder functions"
      min_lines: 150
  key_links:
    - from: "api/tests/testthat/test-unit-mirai-workers.R"
      to: "MIRAI_WORKERS env var"
      via: "withr::local_envvar() for isolated testing"
      pattern: "local_envvar\\(MIRAI_WORKERS"
    - from: "api/tests/testthat/test-unit-logging-repository.R"
      to: "api/functions/logging-repository.R"
      via: "source_api_file()"
      pattern: "source_api_file.*logging-repository"
---

<objective>
Write unit tests for MIRAI_WORKERS configuration parsing (Phase 69) and logging-repository.R query builder functions (Phase 71).

Purpose: Test coverage for the new configuration and security features ensures regressions are caught. The query builder tests are especially critical since they verify SQL injection prevention.

Output: Two new test files covering TST-01 through TST-06 requirements.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/72-documentation-testing/72-RESEARCH.md

# Test patterns to follow:
@api/tests/testthat/test-unit-security.R (describe/it pattern, source_api_file usage)
@api/tests/testthat/helper-paths.R (source_api_file function)

# Functions being tested (from Phase 69 and 71 plans):
@.planning/phases/69-configurable-workers/69-01-PLAN.md (MIRAI_WORKERS parsing logic)
@.planning/phases/71-viewlogs-database-filtering/71-02-PLAN.md (logging-repository.R functions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unit tests for MIRAI_WORKERS parsing</name>
  <files>api/tests/testthat/test-unit-mirai-workers.R</files>
  <action>
Create `api/tests/testthat/test-unit-mirai-workers.R` following the describe/it pattern from test-unit-security.R.

The file structure:

```r
# tests/testthat/test-unit-mirai-workers.R
# Unit tests for MIRAI_WORKERS environment variable parsing
#
# Tests verify that the worker count configuration:
# - Defaults to 2 when not set
# - Handles invalid (non-numeric) values by falling back to default
# - Bounds values to 1-8 range
#
# Note: These tests verify the parsing PATTERN since the actual logic
# is inline in start_sysndd_api.R. The tests document expected behavior.

library(testthat)
library(withr)

# ============================================================================
# Helper: Parse MIRAI_WORKERS as implemented in start_sysndd_api.R
# ============================================================================

#' Parse MIRAI_WORKERS environment variable
#'
#' This function replicates the logic from start_sysndd_api.R for testing.
#' The actual implementation is inline in the API startup script.
#'
#' @return Integer worker count (1-8)
parse_mirai_workers <- function() {
  worker_count <- as.integer(Sys.getenv("MIRAI_WORKERS", "2"))
  if (is.na(worker_count)) worker_count <- 2L
  max(1L, min(worker_count, 8L))
}

# ============================================================================
# MIRAI_WORKERS Parsing Tests (TST-01)
# ============================================================================

describe("MIRAI_WORKERS parsing", {

  it("defaults to 2 when not set", {
    withr::local_envvar(MIRAI_WORKERS = NA)  # Unset

    result <- parse_mirai_workers()
    expect_equal(result, 2L)
  })

  it("defaults to 2 when set to empty string", {
    withr::local_envvar(MIRAI_WORKERS = "")

    result <- parse_mirai_workers()
    expect_equal(result, 2L)
  })

  it("parses valid integer values", {
    withr::local_envvar(MIRAI_WORKERS = "4")
    expect_equal(parse_mirai_workers(), 4L)

    withr::local_envvar(MIRAI_WORKERS = "1")
    expect_equal(parse_mirai_workers(), 1L)

    withr::local_envvar(MIRAI_WORKERS = "8")
    expect_equal(parse_mirai_workers(), 8L)
  })

  it("handles non-numeric values by defaulting to 2", {
    withr::local_envvar(MIRAI_WORKERS = "abc")
    expect_equal(parse_mirai_workers(), 2L)

    withr::local_envvar(MIRAI_WORKERS = "two")
    expect_equal(parse_mirai_workers(), 2L)

    withr::local_envvar(MIRAI_WORKERS = "4.5")  # Float strings
    expect_equal(parse_mirai_workers(), 4L)  # as.integer truncates
  })

  it("bounds value to minimum of 1", {
    withr::local_envvar(MIRAI_WORKERS = "0")
    expect_equal(parse_mirai_workers(), 1L)

    withr::local_envvar(MIRAI_WORKERS = "-1")
    expect_equal(parse_mirai_workers(), 1L)

    withr::local_envvar(MIRAI_WORKERS = "-99")
    expect_equal(parse_mirai_workers(), 1L)
  })

  it("bounds value to maximum of 8", {
    withr::local_envvar(MIRAI_WORKERS = "9")
    expect_equal(parse_mirai_workers(), 8L)

    withr::local_envvar(MIRAI_WORKERS = "10")
    expect_equal(parse_mirai_workers(), 8L)

    withr::local_envvar(MIRAI_WORKERS = "100")
    expect_equal(parse_mirai_workers(), 8L)
  })

  it("handles edge cases at boundaries", {
    # Exactly at minimum
    withr::local_envvar(MIRAI_WORKERS = "1")
    expect_equal(parse_mirai_workers(), 1L)

    # Exactly at maximum
    withr::local_envvar(MIRAI_WORKERS = "8")
    expect_equal(parse_mirai_workers(), 8L)

    # One below minimum (should bound)
    withr::local_envvar(MIRAI_WORKERS = "0")
    expect_equal(parse_mirai_workers(), 1L)

    # One above maximum (should bound)
    withr::local_envvar(MIRAI_WORKERS = "9")
    expect_equal(parse_mirai_workers(), 8L)
  })
})
```

Key points:
- Use `withr::local_envvar()` for isolated environment variable testing
- Include a helper function that replicates the parsing logic
- Test all edge cases: unset, empty, valid, invalid, and boundary values
- Use `describe/it` pattern for consistency with test-unit-security.R
  </action>
  <verify>
```bash
# File exists
test -f api/tests/testthat/test-unit-mirai-workers.R && echo "File exists"

# Run the tests
cd /home/bernt-popp/development/sysndd/api && Rscript -e "testthat::test_file('tests/testthat/test-unit-mirai-workers.R')"
```
  </verify>
  <done>
- test-unit-mirai-workers.R exists with comprehensive MIRAI_WORKERS parsing tests
- Tests cover default value, invalid input handling, and bounds validation
- All tests pass (TST-01 complete)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for logging-repository.R query builder</name>
  <files>api/tests/testthat/test-unit-logging-repository.R</files>
  <action>
Create `api/tests/testthat/test-unit-logging-repository.R` with comprehensive tests for the query builder functions.

The file structure:

```r
# tests/testthat/test-unit-logging-repository.R
# Unit tests for logging-repository.R query builder functions
#
# Tests verify:
# - Column validation rejects unknown columns with invalid_filter_error
# - SQL injection patterns are blocked
# - WHERE clause builder produces parameterized queries
# - ORDER BY clause builder validates column and direction

library(testthat)

# Source the module under test
source_api_file("functions/logging-repository.R", local = FALSE)

# ============================================================================
# LOGGING_ALLOWED_COLUMNS constant tests (TST-02)
# ============================================================================

describe("LOGGING_ALLOWED_COLUMNS", {
  it("contains expected logging table columns", {
    expect_true("id" %in% LOGGING_ALLOWED_COLUMNS)
    expect_true("timestamp" %in% LOGGING_ALLOWED_COLUMNS)
    expect_true("status" %in% LOGGING_ALLOWED_COLUMNS)
    expect_true("path" %in% LOGGING_ALLOWED_COLUMNS)
    expect_true("request_method" %in% LOGGING_ALLOWED_COLUMNS)
    expect_true("address" %in% LOGGING_ALLOWED_COLUMNS)
    expect_true("duration" %in% LOGGING_ALLOWED_COLUMNS)
  })

  it("does not contain dangerous columns", {
    # Columns that should NOT be in the whitelist
    expect_false("password" %in% LOGGING_ALLOWED_COLUMNS)
    expect_false("secret" %in% LOGGING_ALLOWED_COLUMNS)
    expect_false("token" %in% LOGGING_ALLOWED_COLUMNS)
  })
})

describe("LOGGING_ALLOWED_SORT_COLUMNS", {
  it("is a subset of LOGGING_ALLOWED_COLUMNS", {
    # All sort columns should also be in allowed columns
    for (col in LOGGING_ALLOWED_SORT_COLUMNS) {
      expect_true(col %in% LOGGING_ALLOWED_COLUMNS,
                  info = paste("Sort column", col, "not in allowed columns"))
    }
  })

  it("contains expected sortable columns", {
    expect_true("id" %in% LOGGING_ALLOWED_SORT_COLUMNS)
    expect_true("timestamp" %in% LOGGING_ALLOWED_SORT_COLUMNS)
    expect_true("status" %in% LOGGING_ALLOWED_SORT_COLUMNS)
  })
})

# ============================================================================
# validate_logging_column() tests (TST-02)
# ============================================================================

describe("validate_logging_column", {
  it("accepts valid columns", {
    expect_no_error(validate_logging_column("status"))
    expect_no_error(validate_logging_column("timestamp"))
    expect_no_error(validate_logging_column("id"))
    expect_no_error(validate_logging_column("path"))
  })

  it("returns the column name when valid", {
    expect_equal(validate_logging_column("status"), "status")
    expect_equal(validate_logging_column("timestamp"), "timestamp")
  })

  it("rejects invalid columns with invalid_filter_error", {
    expect_error(
      validate_logging_column("nonexistent"),
      class = "invalid_filter_error"
    )
    expect_error(
      validate_logging_column("unknown_column"),
      class = "invalid_filter_error"
    )
  })

  it("uses custom allowed list when provided", {
    custom_allowed <- c("foo", "bar")
    expect_no_error(validate_logging_column("foo", allowed = custom_allowed))
    expect_error(
      validate_logging_column("status", allowed = custom_allowed),
      class = "invalid_filter_error"
    )
  })
})

# ============================================================================
# SQL injection prevention tests (TST-05)
# ============================================================================

describe("SQL injection prevention", {
  # Common SQL injection patterns
  injection_attempts <- c(
    "id; DROP TABLE logging; --",
    "id' OR '1'='1",
    "id/**/OR/**/1=1",
    "id UNION SELECT * FROM users",
    "'; DELETE FROM logging WHERE '1'='1",
    "status\n-- comment",
    "id; SELECT password FROM users; --",
    "1 OR 1=1",
    "admin'--",
    "status' AND '1'='1",
    "id`; DROP TABLE logging; --",
    "status; TRUNCATE TABLE logging",
    "path' OR 'x'='x"
  )

  for (attempt in injection_attempts) {
    it(paste("rejects injection:", substr(attempt, 1, 40)), {
      expect_error(
        validate_logging_column(attempt),
        class = "invalid_filter_error"
      )
    })
  }

  it("rejects column names with special characters", {
    expect_error(validate_logging_column("status;"), class = "invalid_filter_error")
    expect_error(validate_logging_column("status'"), class = "invalid_filter_error")
    expect_error(validate_logging_column("status--"), class = "invalid_filter_error")
    expect_error(validate_logging_column("status/*"), class = "invalid_filter_error")
  })
})

# ============================================================================
# validate_sort_direction() tests (TST-03)
# ============================================================================

describe("validate_sort_direction", {
  it("accepts ASC and DESC (case insensitive)", {
    expect_equal(validate_sort_direction("ASC"), "ASC")
    expect_equal(validate_sort_direction("DESC"), "DESC")
    expect_equal(validate_sort_direction("asc"), "ASC")
    expect_equal(validate_sort_direction("desc"), "DESC")
    expect_equal(validate_sort_direction("Asc"), "ASC")
    expect_equal(validate_sort_direction("Desc"), "DESC")
  })

  it("trims whitespace", {
    expect_equal(validate_sort_direction("  ASC  "), "ASC")
    expect_equal(validate_sort_direction("\tDESC\n"), "DESC")
  })

  it("rejects invalid directions with invalid_filter_error", {
    expect_error(
      validate_sort_direction("ASCENDING"),
      class = "invalid_filter_error"
    )
    expect_error(
      validate_sort_direction("UP"),
      class = "invalid_filter_error"
    )
    expect_error(
      validate_sort_direction("ASC; DROP TABLE"),
      class = "invalid_filter_error"
    )
  })
})

# ============================================================================
# build_logging_where_clause() tests (TST-04)
# ============================================================================

describe("build_logging_where_clause", {
  it("returns 1=1 for empty filters", {
    result <- build_logging_where_clause(list())
    expect_equal(result$clause, "1=1")
    expect_equal(length(result$params), 0)
  })

  it("returns 1=1 for NULL filters", {
    result <- build_logging_where_clause(NULL)
    expect_equal(result$clause, "1=1")
  })

  it("builds status filter with parameterization", {
    result <- build_logging_where_clause(list(status = 200))
    expect_match(result$clause, "status = \\?")
    expect_equal(result$params[[1]], 200L)
  })

  it("builds request_method filter", {
    result <- build_logging_where_clause(list(request_method = "GET"))
    expect_match(result$clause, "request_method = \\?")
    expect_equal(result$params[[1]], "GET")
  })

  it("builds path prefix filter with LIKE", {
    result <- build_logging_where_clause(list(path_prefix = "/api/"))
    expect_match(result$clause, "path LIKE \\?")
    expect_equal(result$params[[1]], "/api/%")  # % appended
  })

  it("builds timestamp range filters", {
    result <- build_logging_where_clause(list(
      timestamp_from = "2026-01-01 00:00:00",
      timestamp_to = "2026-01-31 23:59:59"
    ))
    expect_match(result$clause, "timestamp >= \\?")
    expect_match(result$clause, "timestamp <= \\?")
    expect_equal(length(result$params), 2)
    expect_equal(result$params[[1]], "2026-01-01 00:00:00")
    expect_equal(result$params[[2]], "2026-01-31 23:59:59")
  })

  it("builds address filter", {
    result <- build_logging_where_clause(list(address = "192.168.1.1"))
    expect_match(result$clause, "address = \\?")
    expect_equal(result$params[[1]], "192.168.1.1")
  })

  it("combines multiple filters with AND", {
    result <- build_logging_where_clause(list(
      status = 200,
      request_method = "GET"
    ))
    expect_match(result$clause, "AND status = \\?")
    expect_match(result$clause, "AND request_method = \\?")
    expect_equal(length(result$params), 2)
  })

  it("ignores NULL and empty string filter values", {
    result <- build_logging_where_clause(list(
      status = NULL,
      request_method = "",
      path_prefix = "/api/"
    ))
    expect_false(grepl("status", result$clause))
    expect_false(grepl("request_method", result$clause))
    expect_match(result$clause, "path LIKE \\?")
    expect_equal(length(result$params), 1)
  })

  it("preserves parameter order", {
    result <- build_logging_where_clause(list(
      status = 404,
      request_method = "POST",
      address = "10.0.0.1"
    ))
    # Params should be in same order as they appear in clause
    expect_equal(length(result$params), 3)
  })
})

# ============================================================================
# build_logging_order_clause() tests (TST-03)
# ============================================================================

describe("build_logging_order_clause", {
  it("returns default ORDER BY id DESC", {
    result <- build_logging_order_clause()
    expect_equal(result, "ORDER BY id DESC")
  })

  it("accepts valid sort column", {
    result <- build_logging_order_clause(sort_column = "timestamp")
    expect_equal(result, "ORDER BY timestamp DESC")
  })

  it("accepts valid sort direction", {
    result <- build_logging_order_clause(sort_direction = "ASC")
    expect_equal(result, "ORDER BY id ASC")
  })

  it("combines column and direction", {
    result <- build_logging_order_clause(sort_column = "status", sort_direction = "ASC")
    expect_equal(result, "ORDER BY status ASC")
  })

  it("rejects invalid sort column with invalid_filter_error", {
    expect_error(
      build_logging_order_clause(sort_column = "invalid_column"),
      class = "invalid_filter_error"
    )
  })

  it("rejects SQL injection in sort column", {
    expect_error(
      build_logging_order_clause(sort_column = "id; DROP TABLE logging"),
      class = "invalid_filter_error"
    )
  })

  it("rejects invalid direction", {
    expect_error(
      build_logging_order_clause(sort_direction = "RANDOM"),
      class = "invalid_filter_error"
    )
  })
})

# ============================================================================
# Unparseable filter syntax tests (TST-06)
# ============================================================================

describe("unparseable filter handling", {
  it("filter values with special characters are parameterized, not rejected", {
    # Values should be safe because they're parameterized
    # Only column NAMES need whitelist validation
    result <- build_logging_where_clause(list(
      path_prefix = "/api/test'; DROP TABLE--"
    ))
    # Should still build the query (value is parameterized)
    expect_match(result$clause, "path LIKE \\?")
    # The dangerous value is a PARAMETER, not embedded SQL
    expect_true(grepl("DROP", result$params[[1]]))
  })
})
```

Key points:
- Use `source_api_file()` to load the module under test
- Test all exported functions: validate_logging_column, validate_sort_direction, build_logging_where_clause, build_logging_order_clause
- Include comprehensive SQL injection tests
- Use `class = "invalid_filter_error"` for precise error matching
- Test edge cases: empty filters, NULL values, boundary conditions
  </action>
  <verify>
```bash
# File exists
test -f api/tests/testthat/test-unit-logging-repository.R && echo "File exists"

# Run the tests (will fail if logging-repository.R doesn't exist yet - that's expected)
cd /home/bernt-popp/development/sysndd/api && Rscript -e "testthat::test_file('tests/testthat/test-unit-logging-repository.R')" 2>&1 | head -50
```
  </verify>
  <done>
- test-unit-logging-repository.R exists with comprehensive query builder tests
- Tests cover column validation (TST-02)
- Tests cover ORDER BY building (TST-03)
- Tests cover WHERE clause building with parameterization (TST-04)
- Tests cover SQL injection rejection (TST-05)
- Tests cover unparseable filter handling (TST-06)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Both test files exist:**
   ```bash
   ls -la api/tests/testthat/test-unit-mirai-workers.R api/tests/testthat/test-unit-logging-repository.R
   ```

2. **MIRAI_WORKERS tests pass:**
   ```bash
   cd api && Rscript -e "testthat::test_file('tests/testthat/test-unit-mirai-workers.R')"
   ```

3. **Logging repository tests pass (or skip if source doesn't exist):**
   ```bash
   cd api && Rscript -e "testthat::test_file('tests/testthat/test-unit-logging-repository.R')"
   ```

4. **Lint check (no issues):**
   ```bash
   cd api && Rscript -e "lintr::lint('tests/testthat/test-unit-mirai-workers.R')"
   cd api && Rscript -e "lintr::lint('tests/testthat/test-unit-logging-repository.R')"
   ```
</verification>

<success_criteria>
Requirements coverage:
- [x] TST-01: Unit tests for MIRAI_WORKERS parsing and bounds
- [x] TST-02: Unit tests for column validation in query builder
- [x] TST-03: Unit tests for ORDER BY clause building
- [x] TST-04: Unit tests for WHERE clause building with parameterization
- [x] TST-05: Unit tests reject SQL injection attempts
- [x] TST-06: Unit tests reject unparseable filter syntax

Observable behaviors:
1. test-unit-mirai-workers.R tests all pass
2. test-unit-logging-repository.R tests pass when source file exists
3. No new lintr issues introduced
</success_criteria>

<output>
After completion, create `.planning/phases/72-documentation-testing/72-01-SUMMARY.md`
</output>
