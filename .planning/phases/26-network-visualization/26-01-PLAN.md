---
phase: 26-network-visualization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/functions/analyses-functions.R
  - api/endpoints/analysis_endpoints.R
  - api/tests/testthat/test-unit-network-edges.R
  - app/src/types/network.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/analysis/network_edges returns nodes and edges in Cytoscape.js format"
    - "Each node includes hgnc_id, symbol, cluster, and degree"
    - "Each edge includes source, target, and confidence score"
    - "Response includes metadata with node_count, edge_count, cluster_count"
  artifacts:
    - path: "api/functions/analyses-functions.R"
      provides: "gen_network_edges function"
      contains: "gen_network_edges"
    - path: "api/endpoints/analysis_endpoints.R"
      provides: "GET /api/analysis/network_edges endpoint"
      contains: "network_edges"
    - path: "app/src/types/network.ts"
      provides: "TypeScript types for network data"
      exports: ["NetworkNode", "NetworkEdge", "NetworkResponse"]
  key_links:
    - from: "api/endpoints/analysis_endpoints.R"
      to: "api/functions/analyses-functions.R"
      via: "gen_network_edges() call"
      pattern: "gen_network_edges\\("
---

<objective>
Create backend endpoint for network edge extraction and TypeScript types

Purpose: Provide the data foundation for Cytoscape.js network visualization by extracting protein-protein interaction edges from STRINGdb and returning them in Cytoscape.js-compatible JSON format

Output: Working `/api/analysis/network_edges` endpoint and TypeScript type definitions
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-network-visualization/26-CONTEXT.md
@.planning/phases/26-network-visualization/26-RESEARCH.md
@.planning/phases/25-performance-optimization/25-01-SUMMARY.md
@api/functions/analyses-functions.R
@api/endpoints/analysis_endpoints.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gen_network_edges function</name>
  <files>api/functions/analyses-functions.R</files>
  <action>
Add gen_network_edges function to analyses-functions.R that extracts PPI edges from STRINGdb.

Implementation:
1. Accept parameters: cluster_type ("clusters" or "subclusters"), min_confidence (0-1000, default 400)
2. Reuse Phase 25 pattern: call gen_string_clust_obj to get cluster data with Leiden clustering
3. Extract HGNC IDs from clusters, load gene table with STRING IDs from non_alt_loci_set
4. Initialize STRINGdb (version 11.5, species 9606, score_threshold = min_confidence)
5. Get STRING graph via string_db$get_graph(), create induced_subgraph for input genes
6. Build nodes tibble: hgnc_id, symbol, cluster (from cluster_map), degree (from igraph::degree)
7. Build edges tibble: source, target (mapped to HGNC IDs), confidence (combined_score / 1000)
8. Return list with nodes, edges, metadata (node_count, edge_count, cluster_count, string_version, min_confidence)

Add memoized wrapper gen_network_edges_mem using memoise::memoise with cache_filesystem("cache/network_edges").

Use same cache versioning pattern as gen_string_clust_obj (include CACHE_VERSION env var).

Key code structure:
```r
gen_network_edges <- function(cluster_type = "clusters", min_confidence = 400) {
  cache_version <- Sys.getenv("CACHE_VERSION", "1")
  # ... implementation ...
}
gen_network_edges_mem <- memoise::memoise(
  gen_network_edges,
  cache = memoise::cache_filesystem("cache/network_edges")
)
```
  </action>
  <verify>
Source the file in R and verify function exists:
```bash
docker exec sysndd_api R -e "source('functions/analyses-functions.R'); exists('gen_network_edges')"
```
  </verify>
  <done>gen_network_edges function returns nodes/edges/metadata structure</done>
</task>

<task type="auto">
  <name>Task 2: Create network_edges API endpoint</name>
  <files>api/endpoints/analysis_endpoints.R</files>
  <action>
Add GET /api/analysis/network_edges endpoint to analysis_endpoints.R.

Implementation:
1. Add plumber annotations: @tag analysis, @serializer json list(na="string")
2. Parameters: cluster_type (default "clusters"), min_confidence (default "400")
3. Validate cluster_type is "clusters" or "subclusters"
4. Parse min_confidence to integer, clamp to 0-1000 range
5. Call gen_network_edges_mem(cluster_type, min_confidence)
6. Return response with nodes, edges, metadata

Follow existing pattern from functional_clustering endpoint for error handling.

Endpoint signature:
```r
#* Retrieve Network Edges for Cytoscape.js Visualization
#*
#* Returns protein-protein interaction edges from STRINGdb in Cytoscape.js format.
#* Nodes include gene identifiers and cluster membership.
#* Edges include STRING confidence scores.
#*
#* @tag analysis
#* @serializer json list(na="string")
#* @param cluster_type:str Type of clusters: "clusters" (default) or "subclusters"
#* @param min_confidence:str Minimum STRING confidence (0-1000, default "400")
#*
#* @response 200 OK. Returns nodes, edges, and metadata
#*
#* @get network_edges
function(cluster_type = "clusters", min_confidence = "400") {
  # ... validation and call ...
}
```
  </action>
  <verify>
Test endpoint returns valid response:
```bash
curl -s "http://localhost:3838/api/analysis/network_edges?cluster_type=clusters&min_confidence=400" | jq '.metadata'
```
Expected: JSON object with node_count, edge_count, cluster_count
  </verify>
  <done>GET /api/analysis/network_edges returns Cytoscape.js-compatible JSON</done>
</task>

<task type="auto">
  <name>Task 3: Create TypeScript types and unit tests</name>
  <files>app/src/types/network.ts, api/tests/testthat/test-unit-network-edges.R</files>
  <action>
Part A: Create TypeScript types in app/src/types/network.ts

```typescript
/**
 * Network visualization types for Cytoscape.js integration
 */

export interface NetworkNode {
  hgnc_id: string;
  symbol: string;
  cluster: number;
  degree: number;
}

export interface NetworkEdge {
  source: string;
  target: string;
  confidence: number;
}

export interface NetworkMetadata {
  node_count: number;
  edge_count: number;
  cluster_count: number;
  string_version: string;
  min_confidence: number;
}

export interface NetworkResponse {
  nodes: NetworkNode[];
  edges: NetworkEdge[];
  metadata: NetworkMetadata;
}
```

Part B: Create unit tests in api/tests/testthat/test-unit-network-edges.R

Test cases:
1. gen_network_edges returns list with nodes, edges, metadata keys
2. nodes have required fields (hgnc_id, symbol, cluster, degree)
3. edges have required fields (source, target, confidence)
4. metadata has required fields (node_count, edge_count, cluster_count)
5. confidence values are in 0-1 range (normalized from STRING 0-1000)
6. min_confidence parameter filters edges appropriately

Note: Use existing test patterns from test-unit-analyses-functions.R
  </action>
  <verify>
TypeScript: `cd /home/bernt-popp/development/sysndd/app && npx tsc --noEmit src/types/network.ts`
R tests: `docker exec sysndd_api Rscript -e "testthat::test_file('tests/testthat/test-unit-network-edges.R')"`
  </verify>
  <done>TypeScript types compile without errors, R unit tests pass</done>
</task>

</tasks>

<verification>
1. Endpoint returns valid JSON: `curl -s "http://localhost:3838/api/analysis/network_edges" | jq '.nodes | length'` returns positive number
2. TypeScript compiles: `cd app && npm run type-check` passes
3. Unit tests pass: All tests in test-unit-network-edges.R pass
4. Response matches types: nodes have hgnc_id/symbol/cluster/degree, edges have source/target/confidence
</verification>

<success_criteria>
- GET /api/analysis/network_edges returns nodes, edges, metadata
- Nodes include hgnc_id, symbol, cluster assignment, degree (connection count)
- Edges include source, target (HGNC IDs), confidence (0-1 normalized)
- Response cached via memoise for performance
- TypeScript types match API response structure
- Unit tests verify data structure and edge filtering
</success_criteria>

<output>
After completion, create `.planning/phases/26-network-visualization/26-01-SUMMARY.md`
</output>
